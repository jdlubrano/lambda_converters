# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _Approx.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Approx', [dirname(__file__)])
        except ImportError:
            import _Approx
            return _Approx
        if fp is not None:
            try:
                _mod = imp.load_module('_Approx', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _Approx = swig_import_helper()
    del swig_import_helper
else:
    import _Approx
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Approx.delete_SwigPyIterator
    def __iter__(self): return self
SwigPyIterator.value = new_instancemethod(_Approx.SwigPyIterator_value,None,SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_Approx.SwigPyIterator_incr,None,SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_Approx.SwigPyIterator_decr,None,SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_Approx.SwigPyIterator_distance,None,SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_Approx.SwigPyIterator_equal,None,SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_Approx.SwigPyIterator_copy,None,SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_Approx.SwigPyIterator_next,None,SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_Approx.SwigPyIterator___next__,None,SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_Approx.SwigPyIterator_previous,None,SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_Approx.SwigPyIterator_advance,None,SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_Approx.SwigPyIterator___eq__,None,SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_Approx.SwigPyIterator___ne__,None,SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_Approx.SwigPyIterator___iadd__,None,SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_Approx.SwigPyIterator___isub__,None,SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_Approx.SwigPyIterator___add__,None,SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_Approx.SwigPyIterator___sub__,None,SwigPyIterator)
SwigPyIterator_swigregister = _Approx.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import OCC.Standard
import OCC.Adaptor3d
import OCC.GeomAbs
import OCC.TColStd
import OCC.TCollection
import OCC.MMgt
import OCC.gp
import OCC.Geom
import OCC.TColgp
import OCC.Adaptor2d
import OCC.Geom2d
import OCC.TopAbs
import OCC.math
import OCC.AppCont
import OCC.AppParCurves
def register_handle(handle, base_object):
    """
    Inserts the handle into the base object to
    prevent memory corruption in certain cases
    """
    try:
        if base_object.IsKind("Standard_Transient"):
            base_object.thisHandle = handle
            base_object.thisown = False
    except:
        pass

Approx_ChordLength = _Approx.Approx_ChordLength
Approx_Centripetal = _Approx.Approx_Centripetal
Approx_IsoParametric = _Approx.Approx_IsoParametric
Approx_PointsAdded = _Approx.Approx_PointsAdded
Approx_NoPointsAdded = _Approx.Approx_NoPointsAdded
Approx_NoApproximation = _Approx.Approx_NoApproximation
class Approx_Array1OfAdHSurface(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param Low:
        :type Low: int
        :param Up:
        :type Up: int
        :rtype: None

        :param Item:
        :type Item: Handle_Adaptor3d_HSurface &
        :param Low:
        :type Low: int
        :param Up:
        :type Up: int
        :rtype: None

        """
        _Approx.Approx_Array1OfAdHSurface_swiginit(self,_Approx.new_Approx_Array1OfAdHSurface(*args))
    def Init(self, *args):
        """
        :param V:
        :type V: Handle_Adaptor3d_HSurface &
        :rtype: None

        """
        return _Approx.Approx_Array1OfAdHSurface_Init(self, *args)

    def Destroy(self, *args):
        """
        :rtype: None

        """
        return _Approx.Approx_Array1OfAdHSurface_Destroy(self, *args)

    def IsAllocated(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_Array1OfAdHSurface_IsAllocated(self, *args)

    def Assign(self, *args):
        """
        :param Other:
        :type Other: Approx_Array1OfAdHSurface &
        :rtype: Approx_Array1OfAdHSurface

        """
        return _Approx.Approx_Array1OfAdHSurface_Assign(self, *args)

    def Set(self, *args):
        """
        :param Other:
        :type Other: Approx_Array1OfAdHSurface &
        :rtype: Approx_Array1OfAdHSurface

        """
        return _Approx.Approx_Array1OfAdHSurface_Set(self, *args)

    def Length(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_Array1OfAdHSurface_Length(self, *args)

    def Lower(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_Array1OfAdHSurface_Lower(self, *args)

    def Upper(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_Array1OfAdHSurface_Upper(self, *args)

    def SetValue(self, *args):
        """
        :param Index:
        :type Index: int
        :param Value:
        :type Value: Handle_Adaptor3d_HSurface &
        :rtype: None

        """
        return _Approx.Approx_Array1OfAdHSurface_SetValue(self, *args)

    def Value(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_Adaptor3d_HSurface

        """
        return _Approx.Approx_Array1OfAdHSurface_Value(self, *args)

    def ChangeValue(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_Adaptor3d_HSurface

        """
        return _Approx.Approx_Array1OfAdHSurface_ChangeValue(self, *args)

    __swig_destroy__ = _Approx.delete_Approx_Array1OfAdHSurface
Approx_Array1OfAdHSurface.Init = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Init,None,Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Destroy = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Destroy,None,Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.IsAllocated = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_IsAllocated,None,Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Assign = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Assign,None,Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Set = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Set,None,Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Length = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Length,None,Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Lower = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Lower,None,Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Upper = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Upper,None,Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.SetValue = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_SetValue,None,Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.Value = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_Value,None,Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface.ChangeValue = new_instancemethod(_Approx.Approx_Array1OfAdHSurface_ChangeValue,None,Approx_Array1OfAdHSurface)
Approx_Array1OfAdHSurface_swigregister = _Approx.Approx_Array1OfAdHSurface_swigregister
Approx_Array1OfAdHSurface_swigregister(Approx_Array1OfAdHSurface)

class Approx_Array1OfGTrsf2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param Low:
        :type Low: int
        :param Up:
        :type Up: int
        :rtype: None

        :param Item:
        :type Item: gp_GTrsf2d
        :param Low:
        :type Low: int
        :param Up:
        :type Up: int
        :rtype: None

        """
        _Approx.Approx_Array1OfGTrsf2d_swiginit(self,_Approx.new_Approx_Array1OfGTrsf2d(*args))
    def Init(self, *args):
        """
        :param V:
        :type V: gp_GTrsf2d
        :rtype: None

        """
        return _Approx.Approx_Array1OfGTrsf2d_Init(self, *args)

    def Destroy(self, *args):
        """
        :rtype: None

        """
        return _Approx.Approx_Array1OfGTrsf2d_Destroy(self, *args)

    def IsAllocated(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_Array1OfGTrsf2d_IsAllocated(self, *args)

    def Assign(self, *args):
        """
        :param Other:
        :type Other: Approx_Array1OfGTrsf2d &
        :rtype: Approx_Array1OfGTrsf2d

        """
        return _Approx.Approx_Array1OfGTrsf2d_Assign(self, *args)

    def Set(self, *args):
        """
        :param Other:
        :type Other: Approx_Array1OfGTrsf2d &
        :rtype: Approx_Array1OfGTrsf2d

        """
        return _Approx.Approx_Array1OfGTrsf2d_Set(self, *args)

    def Length(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_Array1OfGTrsf2d_Length(self, *args)

    def Lower(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_Array1OfGTrsf2d_Lower(self, *args)

    def Upper(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_Array1OfGTrsf2d_Upper(self, *args)

    def SetValue(self, *args):
        """
        :param Index:
        :type Index: int
        :param Value:
        :type Value: gp_GTrsf2d
        :rtype: None

        """
        return _Approx.Approx_Array1OfGTrsf2d_SetValue(self, *args)

    def Value(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: gp_GTrsf2d

        """
        return _Approx.Approx_Array1OfGTrsf2d_Value(self, *args)

    def ChangeValue(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: gp_GTrsf2d

        """
        return _Approx.Approx_Array1OfGTrsf2d_ChangeValue(self, *args)

    __swig_destroy__ = _Approx.delete_Approx_Array1OfGTrsf2d
Approx_Array1OfGTrsf2d.Init = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Init,None,Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Destroy = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Destroy,None,Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.IsAllocated = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_IsAllocated,None,Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Assign = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Assign,None,Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Set = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Set,None,Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Length = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Length,None,Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Lower = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Lower,None,Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Upper = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Upper,None,Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.SetValue = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_SetValue,None,Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.Value = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_Value,None,Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d.ChangeValue = new_instancemethod(_Approx.Approx_Array1OfGTrsf2d_ChangeValue,None,Approx_Array1OfGTrsf2d)
Approx_Array1OfGTrsf2d_swigregister = _Approx.Approx_Array1OfGTrsf2d_swigregister
Approx_Array1OfGTrsf2d_swigregister(Approx_Array1OfGTrsf2d)

class Approx_Curve2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param C2D:
        :type C2D: Handle_Adaptor2d_HCurve2d &
        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param TolU:
        :type TolU: float
        :param TolV:
        :type TolV: float
        :param Continuity:
        :type Continuity: GeomAbs_Shape
        :param MaxDegree:
        :type MaxDegree: int
        :param MaxSegments:
        :type MaxSegments: int
        :rtype: None

        """
        _Approx.Approx_Curve2d_swiginit(self,_Approx.new_Approx_Curve2d(*args))
    def IsDone(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_Curve2d_IsDone(self, *args)

    def HasResult(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_Curve2d_HasResult(self, *args)

    def Curve(self, *args):
        """
        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _Approx.Approx_Curve2d_Curve(self, *args)

    def MaxError2dU(self, *args):
        """
        :rtype: float

        """
        return _Approx.Approx_Curve2d_MaxError2dU(self, *args)

    def MaxError2dV(self, *args):
        """
        :rtype: float

        """
        return _Approx.Approx_Curve2d_MaxError2dV(self, *args)

    __swig_destroy__ = _Approx.delete_Approx_Curve2d
Approx_Curve2d.IsDone = new_instancemethod(_Approx.Approx_Curve2d_IsDone,None,Approx_Curve2d)
Approx_Curve2d.HasResult = new_instancemethod(_Approx.Approx_Curve2d_HasResult,None,Approx_Curve2d)
Approx_Curve2d.Curve = new_instancemethod(_Approx.Approx_Curve2d_Curve,None,Approx_Curve2d)
Approx_Curve2d.MaxError2dU = new_instancemethod(_Approx.Approx_Curve2d_MaxError2dU,None,Approx_Curve2d)
Approx_Curve2d.MaxError2dV = new_instancemethod(_Approx.Approx_Curve2d_MaxError2dV,None,Approx_Curve2d)
Approx_Curve2d_swigregister = _Approx.Approx_Curve2d_swigregister
Approx_Curve2d_swigregister(Approx_Curve2d)

class Approx_Curve3d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Approximation of a curve with respect of the requiered tolerance Tol3D.

        :param Curve:
        :type Curve: Handle_Adaptor3d_HCurve &
        :param Tol3d:
        :type Tol3d: float
        :param Order:
        :type Order: GeomAbs_Shape
        :param MaxSegments:
        :type MaxSegments: int
        :param MaxDegree:
        :type MaxDegree: int
        :rtype: None

        """
        _Approx.Approx_Curve3d_swiginit(self,_Approx.new_Approx_Curve3d(*args))
    def Curve(self, *args):
        """
        :rtype: Handle_Geom_BSplineCurve

        """
        return _Approx.Approx_Curve3d_Curve(self, *args)

    def IsDone(self, *args):
        """
        * returns Standard_True if the approximation has been done within requiered tolerance

        :rtype: bool

        """
        return _Approx.Approx_Curve3d_IsDone(self, *args)

    def HasResult(self, *args):
        """
        * returns Standard_True if the approximation did come out with a result that is not NECESSARELY within the required tolerance

        :rtype: bool

        """
        return _Approx.Approx_Curve3d_HasResult(self, *args)

    def MaxError(self, *args):
        """
        * returns the Maximum Error (>0 when an approximation has been done, 0 if no approximation)

        :rtype: float

        """
        return _Approx.Approx_Curve3d_MaxError(self, *args)

    def DumpToString(self):
        """DumpToString(Approx_Curve3d self) -> std::string"""
        return _Approx.Approx_Curve3d_DumpToString(self)

    __swig_destroy__ = _Approx.delete_Approx_Curve3d
Approx_Curve3d.Curve = new_instancemethod(_Approx.Approx_Curve3d_Curve,None,Approx_Curve3d)
Approx_Curve3d.IsDone = new_instancemethod(_Approx.Approx_Curve3d_IsDone,None,Approx_Curve3d)
Approx_Curve3d.HasResult = new_instancemethod(_Approx.Approx_Curve3d_HasResult,None,Approx_Curve3d)
Approx_Curve3d.MaxError = new_instancemethod(_Approx.Approx_Curve3d_MaxError,None,Approx_Curve3d)
Approx_Curve3d.DumpToString = new_instancemethod(_Approx.Approx_Curve3d_DumpToString,None,Approx_Curve3d)
Approx_Curve3d_swigregister = _Approx.Approx_Curve3d_swigregister
Approx_Curve3d_swigregister(Approx_Curve3d)

class Approx_CurveOnSurface(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param C2D:
        :type C2D: Handle_Adaptor2d_HCurve2d &
        :param Surf:
        :type Surf: Handle_Adaptor3d_HSurface &
        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param Tol:
        :type Tol: float
        :param Continuity:
        :type Continuity: GeomAbs_Shape
        :param MaxDegree:
        :type MaxDegree: int
        :param MaxSegments:
        :type MaxSegments: int
        :param Only3d: default value is Standard_False
        :type Only3d: bool
        :param Only2d: default value is Standard_False
        :type Only2d: bool
        :rtype: None

        """
        _Approx.Approx_CurveOnSurface_swiginit(self,_Approx.new_Approx_CurveOnSurface(*args))
    def IsDone(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_CurveOnSurface_IsDone(self, *args)

    def HasResult(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_CurveOnSurface_HasResult(self, *args)

    def Curve3d(self, *args):
        """
        :rtype: Handle_Geom_BSplineCurve

        """
        return _Approx.Approx_CurveOnSurface_Curve3d(self, *args)

    def MaxError3d(self, *args):
        """
        :rtype: float

        """
        return _Approx.Approx_CurveOnSurface_MaxError3d(self, *args)

    def Curve2d(self, *args):
        """
        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _Approx.Approx_CurveOnSurface_Curve2d(self, *args)

    def MaxError2dU(self, *args):
        """
        :rtype: float

        """
        return _Approx.Approx_CurveOnSurface_MaxError2dU(self, *args)

    def MaxError2dV(self, *args):
        """
        * returns the maximum errors relativly to the U component or the V component of the  2d Curve

        :rtype: float

        """
        return _Approx.Approx_CurveOnSurface_MaxError2dV(self, *args)

    __swig_destroy__ = _Approx.delete_Approx_CurveOnSurface
Approx_CurveOnSurface.IsDone = new_instancemethod(_Approx.Approx_CurveOnSurface_IsDone,None,Approx_CurveOnSurface)
Approx_CurveOnSurface.HasResult = new_instancemethod(_Approx.Approx_CurveOnSurface_HasResult,None,Approx_CurveOnSurface)
Approx_CurveOnSurface.Curve3d = new_instancemethod(_Approx.Approx_CurveOnSurface_Curve3d,None,Approx_CurveOnSurface)
Approx_CurveOnSurface.MaxError3d = new_instancemethod(_Approx.Approx_CurveOnSurface_MaxError3d,None,Approx_CurveOnSurface)
Approx_CurveOnSurface.Curve2d = new_instancemethod(_Approx.Approx_CurveOnSurface_Curve2d,None,Approx_CurveOnSurface)
Approx_CurveOnSurface.MaxError2dU = new_instancemethod(_Approx.Approx_CurveOnSurface_MaxError2dU,None,Approx_CurveOnSurface)
Approx_CurveOnSurface.MaxError2dV = new_instancemethod(_Approx.Approx_CurveOnSurface_MaxError2dV,None,Approx_CurveOnSurface)
Approx_CurveOnSurface_swigregister = _Approx.Approx_CurveOnSurface_swigregister
Approx_CurveOnSurface_swigregister(Approx_CurveOnSurface)

class Approx_CurvilinearParameter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * case of a free 3D curve

        :param C3D:
        :type C3D: Handle_Adaptor3d_HCurve &
        :param Tol:
        :type Tol: float
        :param Order:
        :type Order: GeomAbs_Shape
        :param MaxDegree:
        :type MaxDegree: int
        :param MaxSegments:
        :type MaxSegments: int
        :rtype: None

        * case of a curve on one surface

        :param C2D:
        :type C2D: Handle_Adaptor2d_HCurve2d &
        :param Surf:
        :type Surf: Handle_Adaptor3d_HSurface &
        :param Tol:
        :type Tol: float
        :param Order:
        :type Order: GeomAbs_Shape
        :param MaxDegree:
        :type MaxDegree: int
        :param MaxSegments:
        :type MaxSegments: int
        :rtype: None

        * case of a curve on two surfaces

        :param C2D1:
        :type C2D1: Handle_Adaptor2d_HCurve2d &
        :param Surf1:
        :type Surf1: Handle_Adaptor3d_HSurface &
        :param C2D2:
        :type C2D2: Handle_Adaptor2d_HCurve2d &
        :param Surf2:
        :type Surf2: Handle_Adaptor3d_HSurface &
        :param Tol:
        :type Tol: float
        :param Order:
        :type Order: GeomAbs_Shape
        :param MaxDegree:
        :type MaxDegree: int
        :param MaxSegments:
        :type MaxSegments: int
        :rtype: None

        """
        _Approx.Approx_CurvilinearParameter_swiginit(self,_Approx.new_Approx_CurvilinearParameter(*args))
    def IsDone(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_CurvilinearParameter_IsDone(self, *args)

    def HasResult(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_CurvilinearParameter_HasResult(self, *args)

    def Curve3d(self, *args):
        """
        * returns the Bspline curve corresponding to the reparametrized 3D curve

        :rtype: Handle_Geom_BSplineCurve

        """
        return _Approx.Approx_CurvilinearParameter_Curve3d(self, *args)

    def MaxError3d(self, *args):
        """
        * returns the maximum error on the reparametrized 3D curve

        :rtype: float

        """
        return _Approx.Approx_CurvilinearParameter_MaxError3d(self, *args)

    def Curve2d1(self, *args):
        """
        * returns the BsplineCurve representing the reparametrized 2D curve on the first surface (case of a curve on one or two surfaces)

        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _Approx.Approx_CurvilinearParameter_Curve2d1(self, *args)

    def MaxError2d1(self, *args):
        """
        * returns the maximum error on the first reparametrized 2D curve

        :rtype: float

        """
        return _Approx.Approx_CurvilinearParameter_MaxError2d1(self, *args)

    def Curve2d2(self, *args):
        """
        * returns the BsplineCurve representing the reparametrized 2D curve on the second surface (case of a curve on two surfaces)

        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _Approx.Approx_CurvilinearParameter_Curve2d2(self, *args)

    def MaxError2d2(self, *args):
        """
        * returns the maximum error on the second reparametrized 2D curve

        :rtype: float

        """
        return _Approx.Approx_CurvilinearParameter_MaxError2d2(self, *args)

    def DumpToString(self):
        """DumpToString(Approx_CurvilinearParameter self) -> std::string"""
        return _Approx.Approx_CurvilinearParameter_DumpToString(self)

    __swig_destroy__ = _Approx.delete_Approx_CurvilinearParameter
Approx_CurvilinearParameter.IsDone = new_instancemethod(_Approx.Approx_CurvilinearParameter_IsDone,None,Approx_CurvilinearParameter)
Approx_CurvilinearParameter.HasResult = new_instancemethod(_Approx.Approx_CurvilinearParameter_HasResult,None,Approx_CurvilinearParameter)
Approx_CurvilinearParameter.Curve3d = new_instancemethod(_Approx.Approx_CurvilinearParameter_Curve3d,None,Approx_CurvilinearParameter)
Approx_CurvilinearParameter.MaxError3d = new_instancemethod(_Approx.Approx_CurvilinearParameter_MaxError3d,None,Approx_CurvilinearParameter)
Approx_CurvilinearParameter.Curve2d1 = new_instancemethod(_Approx.Approx_CurvilinearParameter_Curve2d1,None,Approx_CurvilinearParameter)
Approx_CurvilinearParameter.MaxError2d1 = new_instancemethod(_Approx.Approx_CurvilinearParameter_MaxError2d1,None,Approx_CurvilinearParameter)
Approx_CurvilinearParameter.Curve2d2 = new_instancemethod(_Approx.Approx_CurvilinearParameter_Curve2d2,None,Approx_CurvilinearParameter)
Approx_CurvilinearParameter.MaxError2d2 = new_instancemethod(_Approx.Approx_CurvilinearParameter_MaxError2d2,None,Approx_CurvilinearParameter)
Approx_CurvilinearParameter.DumpToString = new_instancemethod(_Approx.Approx_CurvilinearParameter_DumpToString,None,Approx_CurvilinearParameter)
Approx_CurvilinearParameter_swigregister = _Approx.Approx_CurvilinearParameter_swigregister
Approx_CurvilinearParameter_swigregister(Approx_CurvilinearParameter)

class Approx_CurvlinFunc(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :param Tol:
        :type Tol: float
        :rtype: None

        :param C2D:
        :type C2D: Handle_Adaptor2d_HCurve2d &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param Tol:
        :type Tol: float
        :rtype: None

        :param C2D1:
        :type C2D1: Handle_Adaptor2d_HCurve2d &
        :param C2D2:
        :type C2D2: Handle_Adaptor2d_HCurve2d &
        :param S1:
        :type S1: Handle_Adaptor3d_HSurface &
        :param S2:
        :type S2: Handle_Adaptor3d_HSurface &
        :param Tol:
        :type Tol: float
        :rtype: None

        """
        _Approx.Approx_CurvlinFunc_swiginit(self,_Approx.new_Approx_CurvlinFunc(*args))
    def SetTol(self, *args):
        """
        * //!---Purpose Update the tolerance to used

        :param Tol:
        :type Tol: float
        :rtype: None

        """
        return _Approx.Approx_CurvlinFunc_SetTol(self, *args)

    def FirstParameter(self, *args):
        """
        :rtype: float

        """
        return _Approx.Approx_CurvlinFunc_FirstParameter(self, *args)

    def LastParameter(self, *args):
        """
        :rtype: float

        """
        return _Approx.Approx_CurvlinFunc_LastParameter(self, *args)

    def NbIntervals(self, *args):
        """
        * Returns the number of intervals for continuity <S>. May be one if Continuity(me) >= <S>

        :param S:
        :type S: GeomAbs_Shape
        :rtype: int

        """
        return _Approx.Approx_CurvlinFunc_NbIntervals(self, *args)

    def Intervals(self, *args):
        """
        * Stores in <T> the parameters bounding the intervals of continuity <S>.  The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals()

        :param T:
        :type T: TColStd_Array1OfReal &
        :param S:
        :type S: GeomAbs_Shape
        :rtype: None

        """
        return _Approx.Approx_CurvlinFunc_Intervals(self, *args)

    def Trim(self, *args):
        """
        * if First < 0 or Last > 1

        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param Tol:
        :type Tol: float
        :rtype: None

        """
        return _Approx.Approx_CurvlinFunc_Trim(self, *args)

    def Length(self, *args):
        """
        * Computes length of the curve.

        :rtype: None

        * Computes length of the curve segment.

        :param C:
        :type C: Adaptor3d_Curve &
        :param FirstU:
        :type FirstU: float
        :param LasrU:
        :type LasrU: float
        :rtype: float

        """
        return _Approx.Approx_CurvlinFunc_Length(self, *args)

    def GetLength(self, *args):
        """
        :rtype: float

        """
        return _Approx.Approx_CurvlinFunc_GetLength(self, *args)

    def GetUParameter(self, *args):
        """
        * returns original parameter correponding S. if Case == 1 computation is performed on myC2D1 and mySurf1, otherwise it is done on myC2D2 and mySurf2.

        :param C:
        :type C: Adaptor3d_Curve &
        :param S:
        :type S: float
        :param NumberOfCurve:
        :type NumberOfCurve: int
        :rtype: float

        """
        return _Approx.Approx_CurvlinFunc_GetUParameter(self, *args)

    def GetSParameter(self, *args):
        """
        * returns original parameter correponding S.

        :param U:
        :type U: float
        :rtype: float

        """
        return _Approx.Approx_CurvlinFunc_GetSParameter(self, *args)

    def EvalCase1(self, *args):
        """
        * if myCase != 1

        :param S:
        :type S: float
        :param Order:
        :type Order: int
        :param Result:
        :type Result: TColStd_Array1OfReal &
        :rtype: bool

        """
        return _Approx.Approx_CurvlinFunc_EvalCase1(self, *args)

    def EvalCase2(self, *args):
        """
        * if myCase != 2

        :param S:
        :type S: float
        :param Order:
        :type Order: int
        :param Result:
        :type Result: TColStd_Array1OfReal &
        :rtype: bool

        """
        return _Approx.Approx_CurvlinFunc_EvalCase2(self, *args)

    def EvalCase3(self, *args):
        """
        * if myCase != 3

        :param S:
        :type S: float
        :param Order:
        :type Order: int
        :param Result:
        :type Result: TColStd_Array1OfReal &
        :rtype: bool

        """
        return _Approx.Approx_CurvlinFunc_EvalCase3(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Approx_CurvlinFunc(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _Approx.delete_Approx_CurvlinFunc
Approx_CurvlinFunc.SetTol = new_instancemethod(_Approx.Approx_CurvlinFunc_SetTol,None,Approx_CurvlinFunc)
Approx_CurvlinFunc.FirstParameter = new_instancemethod(_Approx.Approx_CurvlinFunc_FirstParameter,None,Approx_CurvlinFunc)
Approx_CurvlinFunc.LastParameter = new_instancemethod(_Approx.Approx_CurvlinFunc_LastParameter,None,Approx_CurvlinFunc)
Approx_CurvlinFunc.NbIntervals = new_instancemethod(_Approx.Approx_CurvlinFunc_NbIntervals,None,Approx_CurvlinFunc)
Approx_CurvlinFunc.Intervals = new_instancemethod(_Approx.Approx_CurvlinFunc_Intervals,None,Approx_CurvlinFunc)
Approx_CurvlinFunc.Trim = new_instancemethod(_Approx.Approx_CurvlinFunc_Trim,None,Approx_CurvlinFunc)
Approx_CurvlinFunc.Length = new_instancemethod(_Approx.Approx_CurvlinFunc_Length,None,Approx_CurvlinFunc)
Approx_CurvlinFunc.GetLength = new_instancemethod(_Approx.Approx_CurvlinFunc_GetLength,None,Approx_CurvlinFunc)
Approx_CurvlinFunc.GetUParameter = new_instancemethod(_Approx.Approx_CurvlinFunc_GetUParameter,None,Approx_CurvlinFunc)
Approx_CurvlinFunc.GetSParameter = new_instancemethod(_Approx.Approx_CurvlinFunc_GetSParameter,None,Approx_CurvlinFunc)
Approx_CurvlinFunc.EvalCase1 = new_instancemethod(_Approx.Approx_CurvlinFunc_EvalCase1,None,Approx_CurvlinFunc)
Approx_CurvlinFunc.EvalCase2 = new_instancemethod(_Approx.Approx_CurvlinFunc_EvalCase2,None,Approx_CurvlinFunc)
Approx_CurvlinFunc.EvalCase3 = new_instancemethod(_Approx.Approx_CurvlinFunc_EvalCase3,None,Approx_CurvlinFunc)
Approx_CurvlinFunc_swigregister = _Approx.Approx_CurvlinFunc_swigregister
Approx_CurvlinFunc_swigregister(Approx_CurvlinFunc)

class Handle_Approx_CurvlinFunc(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _Approx.Handle_Approx_CurvlinFunc_swiginit(self,_Approx.new_Handle_Approx_CurvlinFunc(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Approx.Handle_Approx_CurvlinFunc_DownCast)
    __swig_destroy__ = _Approx.delete_Handle_Approx_CurvlinFunc
Handle_Approx_CurvlinFunc.Nullify = new_instancemethod(_Approx.Handle_Approx_CurvlinFunc_Nullify,None,Handle_Approx_CurvlinFunc)
Handle_Approx_CurvlinFunc.IsNull = new_instancemethod(_Approx.Handle_Approx_CurvlinFunc_IsNull,None,Handle_Approx_CurvlinFunc)
Handle_Approx_CurvlinFunc.GetObject = new_instancemethod(_Approx.Handle_Approx_CurvlinFunc_GetObject,None,Handle_Approx_CurvlinFunc)
Handle_Approx_CurvlinFunc_swigregister = _Approx.Handle_Approx_CurvlinFunc_swigregister
Handle_Approx_CurvlinFunc_swigregister(Handle_Approx_CurvlinFunc)

def Handle_Approx_CurvlinFunc_DownCast(*args):
  return _Approx.Handle_Approx_CurvlinFunc_DownCast(*args)
Handle_Approx_CurvlinFunc_DownCast = _Approx.Handle_Approx_CurvlinFunc_DownCast

class Approx_FitAndDivide(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param Line:
        :type Line: AppCont_Function &
        :param degreemin: default value is 3
        :type degreemin: int
        :param degreemax: default value is 8
        :type degreemax: int
        :param Tolerance3d: default value is 1.0e-5
        :type Tolerance3d: float
        :param Tolerance2d: default value is 1.0e-5
        :type Tolerance2d: float
        :param cutting: default value is Standard_False
        :type cutting: bool
        :param FirstC: default value is AppParCurves_TangencyPoint
        :type FirstC: AppParCurves_Constraint
        :param LastC: default value is AppParCurves_TangencyPoint
        :type LastC: AppParCurves_Constraint
        :rtype: None

        :param degreemin: default value is 3
        :type degreemin: int
        :param degreemax: default value is 8
        :type degreemax: int
        :param Tolerance3d: default value is 1.0e-05
        :type Tolerance3d: float
        :param Tolerance2d: default value is 1.0e-05
        :type Tolerance2d: float
        :param cutting: default value is Standard_False
        :type cutting: bool
        :param FirstC: default value is AppParCurves_TangencyPoint
        :type FirstC: AppParCurves_Constraint
        :param LastC: default value is AppParCurves_TangencyPoint
        :type LastC: AppParCurves_Constraint
        :rtype: None

        """
        _Approx.Approx_FitAndDivide_swiginit(self,_Approx.new_Approx_FitAndDivide(*args))
    def Perform(self, *args):
        """
        :param Line:
        :type Line: AppCont_Function &
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide_Perform(self, *args)

    def SetDegrees(self, *args):
        """
        :param degreemin:
        :type degreemin: int
        :param degreemax:
        :type degreemax: int
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide_SetDegrees(self, *args)

    def SetTolerances(self, *args):
        """
        :param Tolerance3d:
        :type Tolerance3d: float
        :param Tolerance2d:
        :type Tolerance2d: float
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide_SetTolerances(self, *args)

    def SetConstraints(self, *args):
        """
        :param FirstC:
        :type FirstC: AppParCurves_Constraint
        :param LastC:
        :type LastC: AppParCurves_Constraint
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide_SetConstraints(self, *args)

    def IsAllApproximated(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_FitAndDivide_IsAllApproximated(self, *args)

    def IsToleranceReached(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_FitAndDivide_IsToleranceReached(self, *args)

    def Error(self, *args):
        """
        :param Index:
        :type Index: int
        :param tol3d:
        :type tol3d: float &
        :param tol2d:
        :type tol2d: float &
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide_Error(self, *args)

    def NbMultiCurves(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_FitAndDivide_NbMultiCurves(self, *args)

    def Value(self, *args):
        """
        :param Index: default value is 1
        :type Index: int
        :rtype: AppParCurves_MultiCurve

        """
        return _Approx.Approx_FitAndDivide_Value(self, *args)

    def Parameters(self, *args):
        """
        :param Index:
        :type Index: int
        :param firstp:
        :type firstp: float &
        :param lastp:
        :type lastp: float &
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide_Parameters(self, *args)

    __swig_destroy__ = _Approx.delete_Approx_FitAndDivide
Approx_FitAndDivide.Perform = new_instancemethod(_Approx.Approx_FitAndDivide_Perform,None,Approx_FitAndDivide)
Approx_FitAndDivide.SetDegrees = new_instancemethod(_Approx.Approx_FitAndDivide_SetDegrees,None,Approx_FitAndDivide)
Approx_FitAndDivide.SetTolerances = new_instancemethod(_Approx.Approx_FitAndDivide_SetTolerances,None,Approx_FitAndDivide)
Approx_FitAndDivide.SetConstraints = new_instancemethod(_Approx.Approx_FitAndDivide_SetConstraints,None,Approx_FitAndDivide)
Approx_FitAndDivide.IsAllApproximated = new_instancemethod(_Approx.Approx_FitAndDivide_IsAllApproximated,None,Approx_FitAndDivide)
Approx_FitAndDivide.IsToleranceReached = new_instancemethod(_Approx.Approx_FitAndDivide_IsToleranceReached,None,Approx_FitAndDivide)
Approx_FitAndDivide.Error = new_instancemethod(_Approx.Approx_FitAndDivide_Error,None,Approx_FitAndDivide)
Approx_FitAndDivide.NbMultiCurves = new_instancemethod(_Approx.Approx_FitAndDivide_NbMultiCurves,None,Approx_FitAndDivide)
Approx_FitAndDivide.Value = new_instancemethod(_Approx.Approx_FitAndDivide_Value,None,Approx_FitAndDivide)
Approx_FitAndDivide.Parameters = new_instancemethod(_Approx.Approx_FitAndDivide_Parameters,None,Approx_FitAndDivide)
Approx_FitAndDivide_swigregister = _Approx.Approx_FitAndDivide_swigregister
Approx_FitAndDivide_swigregister(Approx_FitAndDivide)

class Approx_FitAndDivide2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param Line:
        :type Line: AppCont_Function2d &
        :param degreemin: default value is 3
        :type degreemin: int
        :param degreemax: default value is 8
        :type degreemax: int
        :param Tolerance3d: default value is 1.0e-5
        :type Tolerance3d: float
        :param Tolerance2d: default value is 1.0e-5
        :type Tolerance2d: float
        :param cutting: default value is Standard_False
        :type cutting: bool
        :param FirstC: default value is AppParCurves_TangencyPoint
        :type FirstC: AppParCurves_Constraint
        :param LastC: default value is AppParCurves_TangencyPoint
        :type LastC: AppParCurves_Constraint
        :rtype: None

        :param degreemin: default value is 3
        :type degreemin: int
        :param degreemax: default value is 8
        :type degreemax: int
        :param Tolerance3d: default value is 1.0e-05
        :type Tolerance3d: float
        :param Tolerance2d: default value is 1.0e-05
        :type Tolerance2d: float
        :param cutting: default value is Standard_False
        :type cutting: bool
        :param FirstC: default value is AppParCurves_TangencyPoint
        :type FirstC: AppParCurves_Constraint
        :param LastC: default value is AppParCurves_TangencyPoint
        :type LastC: AppParCurves_Constraint
        :rtype: None

        """
        _Approx.Approx_FitAndDivide2d_swiginit(self,_Approx.new_Approx_FitAndDivide2d(*args))
    def Perform(self, *args):
        """
        :param Line:
        :type Line: AppCont_Function2d &
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide2d_Perform(self, *args)

    def SetDegrees(self, *args):
        """
        :param degreemin:
        :type degreemin: int
        :param degreemax:
        :type degreemax: int
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide2d_SetDegrees(self, *args)

    def SetTolerances(self, *args):
        """
        :param Tolerance3d:
        :type Tolerance3d: float
        :param Tolerance2d:
        :type Tolerance2d: float
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide2d_SetTolerances(self, *args)

    def SetConstraints(self, *args):
        """
        :param FirstC:
        :type FirstC: AppParCurves_Constraint
        :param LastC:
        :type LastC: AppParCurves_Constraint
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide2d_SetConstraints(self, *args)

    def IsAllApproximated(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_FitAndDivide2d_IsAllApproximated(self, *args)

    def IsToleranceReached(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_FitAndDivide2d_IsToleranceReached(self, *args)

    def Error(self, *args):
        """
        :param Index:
        :type Index: int
        :param tol3d:
        :type tol3d: float &
        :param tol2d:
        :type tol2d: float &
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide2d_Error(self, *args)

    def NbMultiCurves(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_FitAndDivide2d_NbMultiCurves(self, *args)

    def Value(self, *args):
        """
        :param Index: default value is 1
        :type Index: int
        :rtype: AppParCurves_MultiCurve

        """
        return _Approx.Approx_FitAndDivide2d_Value(self, *args)

    def Parameters(self, *args):
        """
        :param Index:
        :type Index: int
        :param firstp:
        :type firstp: float &
        :param lastp:
        :type lastp: float &
        :rtype: None

        """
        return _Approx.Approx_FitAndDivide2d_Parameters(self, *args)

    __swig_destroy__ = _Approx.delete_Approx_FitAndDivide2d
Approx_FitAndDivide2d.Perform = new_instancemethod(_Approx.Approx_FitAndDivide2d_Perform,None,Approx_FitAndDivide2d)
Approx_FitAndDivide2d.SetDegrees = new_instancemethod(_Approx.Approx_FitAndDivide2d_SetDegrees,None,Approx_FitAndDivide2d)
Approx_FitAndDivide2d.SetTolerances = new_instancemethod(_Approx.Approx_FitAndDivide2d_SetTolerances,None,Approx_FitAndDivide2d)
Approx_FitAndDivide2d.SetConstraints = new_instancemethod(_Approx.Approx_FitAndDivide2d_SetConstraints,None,Approx_FitAndDivide2d)
Approx_FitAndDivide2d.IsAllApproximated = new_instancemethod(_Approx.Approx_FitAndDivide2d_IsAllApproximated,None,Approx_FitAndDivide2d)
Approx_FitAndDivide2d.IsToleranceReached = new_instancemethod(_Approx.Approx_FitAndDivide2d_IsToleranceReached,None,Approx_FitAndDivide2d)
Approx_FitAndDivide2d.Error = new_instancemethod(_Approx.Approx_FitAndDivide2d_Error,None,Approx_FitAndDivide2d)
Approx_FitAndDivide2d.NbMultiCurves = new_instancemethod(_Approx.Approx_FitAndDivide2d_NbMultiCurves,None,Approx_FitAndDivide2d)
Approx_FitAndDivide2d.Value = new_instancemethod(_Approx.Approx_FitAndDivide2d_Value,None,Approx_FitAndDivide2d)
Approx_FitAndDivide2d.Parameters = new_instancemethod(_Approx.Approx_FitAndDivide2d_Parameters,None,Approx_FitAndDivide2d)
Approx_FitAndDivide2d_swigregister = _Approx.Approx_FitAndDivide2d_swigregister
Approx_FitAndDivide2d_swigregister(Approx_FitAndDivide2d)

class Approx_HArray1OfAdHSurface(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param Low:
        :type Low: int
        :param Up:
        :type Up: int
        :rtype: None

        :param Low:
        :type Low: int
        :param Up:
        :type Up: int
        :param V:
        :type V: Handle_Adaptor3d_HSurface &
        :rtype: None

        """
        _Approx.Approx_HArray1OfAdHSurface_swiginit(self,_Approx.new_Approx_HArray1OfAdHSurface(*args))
    def Init(self, *args):
        """
        :param V:
        :type V: Handle_Adaptor3d_HSurface &
        :rtype: None

        """
        return _Approx.Approx_HArray1OfAdHSurface_Init(self, *args)

    def Length(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_HArray1OfAdHSurface_Length(self, *args)

    def Lower(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_HArray1OfAdHSurface_Lower(self, *args)

    def Upper(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_HArray1OfAdHSurface_Upper(self, *args)

    def SetValue(self, *args):
        """
        :param Index:
        :type Index: int
        :param Value:
        :type Value: Handle_Adaptor3d_HSurface &
        :rtype: None

        """
        return _Approx.Approx_HArray1OfAdHSurface_SetValue(self, *args)

    def Value(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_Adaptor3d_HSurface

        """
        return _Approx.Approx_HArray1OfAdHSurface_Value(self, *args)

    def ChangeValue(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_Adaptor3d_HSurface

        """
        return _Approx.Approx_HArray1OfAdHSurface_ChangeValue(self, *args)

    def Array1(self, *args):
        """
        :rtype: Approx_Array1OfAdHSurface

        """
        return _Approx.Approx_HArray1OfAdHSurface_Array1(self, *args)

    def ChangeArray1(self, *args):
        """
        :rtype: Approx_Array1OfAdHSurface

        """
        return _Approx.Approx_HArray1OfAdHSurface_ChangeArray1(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Approx_HArray1OfAdHSurface(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _Approx.delete_Approx_HArray1OfAdHSurface
Approx_HArray1OfAdHSurface.Init = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface_Init,None,Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface.Length = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface_Length,None,Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface.Lower = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface_Lower,None,Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface.Upper = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface_Upper,None,Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface.SetValue = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface_SetValue,None,Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface.Value = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface_Value,None,Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface.ChangeValue = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface_ChangeValue,None,Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface.Array1 = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface_Array1,None,Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface.ChangeArray1 = new_instancemethod(_Approx.Approx_HArray1OfAdHSurface_ChangeArray1,None,Approx_HArray1OfAdHSurface)
Approx_HArray1OfAdHSurface_swigregister = _Approx.Approx_HArray1OfAdHSurface_swigregister
Approx_HArray1OfAdHSurface_swigregister(Approx_HArray1OfAdHSurface)

class Handle_Approx_HArray1OfAdHSurface(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _Approx.Handle_Approx_HArray1OfAdHSurface_swiginit(self,_Approx.new_Handle_Approx_HArray1OfAdHSurface(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Approx.Handle_Approx_HArray1OfAdHSurface_DownCast)
    __swig_destroy__ = _Approx.delete_Handle_Approx_HArray1OfAdHSurface
Handle_Approx_HArray1OfAdHSurface.Nullify = new_instancemethod(_Approx.Handle_Approx_HArray1OfAdHSurface_Nullify,None,Handle_Approx_HArray1OfAdHSurface)
Handle_Approx_HArray1OfAdHSurface.IsNull = new_instancemethod(_Approx.Handle_Approx_HArray1OfAdHSurface_IsNull,None,Handle_Approx_HArray1OfAdHSurface)
Handle_Approx_HArray1OfAdHSurface.GetObject = new_instancemethod(_Approx.Handle_Approx_HArray1OfAdHSurface_GetObject,None,Handle_Approx_HArray1OfAdHSurface)
Handle_Approx_HArray1OfAdHSurface_swigregister = _Approx.Handle_Approx_HArray1OfAdHSurface_swigregister
Handle_Approx_HArray1OfAdHSurface_swigregister(Handle_Approx_HArray1OfAdHSurface)

def Handle_Approx_HArray1OfAdHSurface_DownCast(*args):
  return _Approx.Handle_Approx_HArray1OfAdHSurface_DownCast(*args)
Handle_Approx_HArray1OfAdHSurface_DownCast = _Approx.Handle_Approx_HArray1OfAdHSurface_DownCast

class Approx_HArray1OfGTrsf2d(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param Low:
        :type Low: int
        :param Up:
        :type Up: int
        :rtype: None

        :param Low:
        :type Low: int
        :param Up:
        :type Up: int
        :param V:
        :type V: gp_GTrsf2d
        :rtype: None

        """
        _Approx.Approx_HArray1OfGTrsf2d_swiginit(self,_Approx.new_Approx_HArray1OfGTrsf2d(*args))
    def Init(self, *args):
        """
        :param V:
        :type V: gp_GTrsf2d
        :rtype: None

        """
        return _Approx.Approx_HArray1OfGTrsf2d_Init(self, *args)

    def Length(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_HArray1OfGTrsf2d_Length(self, *args)

    def Lower(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_HArray1OfGTrsf2d_Lower(self, *args)

    def Upper(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_HArray1OfGTrsf2d_Upper(self, *args)

    def SetValue(self, *args):
        """
        :param Index:
        :type Index: int
        :param Value:
        :type Value: gp_GTrsf2d
        :rtype: None

        """
        return _Approx.Approx_HArray1OfGTrsf2d_SetValue(self, *args)

    def Value(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: gp_GTrsf2d

        """
        return _Approx.Approx_HArray1OfGTrsf2d_Value(self, *args)

    def ChangeValue(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: gp_GTrsf2d

        """
        return _Approx.Approx_HArray1OfGTrsf2d_ChangeValue(self, *args)

    def Array1(self, *args):
        """
        :rtype: Approx_Array1OfGTrsf2d

        """
        return _Approx.Approx_HArray1OfGTrsf2d_Array1(self, *args)

    def ChangeArray1(self, *args):
        """
        :rtype: Approx_Array1OfGTrsf2d

        """
        return _Approx.Approx_HArray1OfGTrsf2d_ChangeArray1(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Approx_HArray1OfGTrsf2d(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _Approx.delete_Approx_HArray1OfGTrsf2d
Approx_HArray1OfGTrsf2d.Init = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d_Init,None,Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d.Length = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d_Length,None,Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d.Lower = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d_Lower,None,Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d.Upper = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d_Upper,None,Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d.SetValue = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d_SetValue,None,Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d.Value = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d_Value,None,Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d.ChangeValue = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d_ChangeValue,None,Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d.Array1 = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d_Array1,None,Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d.ChangeArray1 = new_instancemethod(_Approx.Approx_HArray1OfGTrsf2d_ChangeArray1,None,Approx_HArray1OfGTrsf2d)
Approx_HArray1OfGTrsf2d_swigregister = _Approx.Approx_HArray1OfGTrsf2d_swigregister
Approx_HArray1OfGTrsf2d_swigregister(Approx_HArray1OfGTrsf2d)

class Handle_Approx_HArray1OfGTrsf2d(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _Approx.Handle_Approx_HArray1OfGTrsf2d_swiginit(self,_Approx.new_Handle_Approx_HArray1OfGTrsf2d(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Approx.Handle_Approx_HArray1OfGTrsf2d_DownCast)
    __swig_destroy__ = _Approx.delete_Handle_Approx_HArray1OfGTrsf2d
Handle_Approx_HArray1OfGTrsf2d.Nullify = new_instancemethod(_Approx.Handle_Approx_HArray1OfGTrsf2d_Nullify,None,Handle_Approx_HArray1OfGTrsf2d)
Handle_Approx_HArray1OfGTrsf2d.IsNull = new_instancemethod(_Approx.Handle_Approx_HArray1OfGTrsf2d_IsNull,None,Handle_Approx_HArray1OfGTrsf2d)
Handle_Approx_HArray1OfGTrsf2d.GetObject = new_instancemethod(_Approx.Handle_Approx_HArray1OfGTrsf2d_GetObject,None,Handle_Approx_HArray1OfGTrsf2d)
Handle_Approx_HArray1OfGTrsf2d_swigregister = _Approx.Handle_Approx_HArray1OfGTrsf2d_swigregister
Handle_Approx_HArray1OfGTrsf2d_swigregister(Handle_Approx_HArray1OfGTrsf2d)

def Handle_Approx_HArray1OfGTrsf2d_DownCast(*args):
  return _Approx.Handle_Approx_HArray1OfGTrsf2d_DownCast(*args)
Handle_Approx_HArray1OfGTrsf2d_DownCast = _Approx.Handle_Approx_HArray1OfGTrsf2d_DownCast

class Approx_MCurvesToBSpCurve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        """
        _Approx.Approx_MCurvesToBSpCurve_swiginit(self,_Approx.new_Approx_MCurvesToBSpCurve(*args))
    def Reset(self, *args):
        """
        :rtype: None

        """
        return _Approx.Approx_MCurvesToBSpCurve_Reset(self, *args)

    def Append(self, *args):
        """
        :param MC:
        :type MC: AppParCurves_MultiCurve &
        :rtype: None

        """
        return _Approx.Approx_MCurvesToBSpCurve_Append(self, *args)

    def Perform(self, *args):
        """
        :rtype: None

        :param TheSeq:
        :type TheSeq: AppParCurves_SequenceOfMultiCurve &
        :rtype: None

        """
        return _Approx.Approx_MCurvesToBSpCurve_Perform(self, *args)

    def Value(self, *args):
        """
        * return the composite MultiCurves as a MultiBSpCurve.

        :rtype: AppParCurves_MultiBSpCurve

        """
        return _Approx.Approx_MCurvesToBSpCurve_Value(self, *args)

    def ChangeValue(self, *args):
        """
        * return the composite MultiCurves as a MultiBSpCurve.

        :rtype: AppParCurves_MultiBSpCurve

        """
        return _Approx.Approx_MCurvesToBSpCurve_ChangeValue(self, *args)

    __swig_destroy__ = _Approx.delete_Approx_MCurvesToBSpCurve
Approx_MCurvesToBSpCurve.Reset = new_instancemethod(_Approx.Approx_MCurvesToBSpCurve_Reset,None,Approx_MCurvesToBSpCurve)
Approx_MCurvesToBSpCurve.Append = new_instancemethod(_Approx.Approx_MCurvesToBSpCurve_Append,None,Approx_MCurvesToBSpCurve)
Approx_MCurvesToBSpCurve.Perform = new_instancemethod(_Approx.Approx_MCurvesToBSpCurve_Perform,None,Approx_MCurvesToBSpCurve)
Approx_MCurvesToBSpCurve.Value = new_instancemethod(_Approx.Approx_MCurvesToBSpCurve_Value,None,Approx_MCurvesToBSpCurve)
Approx_MCurvesToBSpCurve.ChangeValue = new_instancemethod(_Approx.Approx_MCurvesToBSpCurve_ChangeValue,None,Approx_MCurvesToBSpCurve)
Approx_MCurvesToBSpCurve_swigregister = _Approx.Approx_MCurvesToBSpCurve_swigregister
Approx_MCurvesToBSpCurve_swigregister(Approx_MCurvesToBSpCurve)

class Approx_MyLeastSquareOfFitAndDivide(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param SSP:
        :type SSP: AppCont_Function &
        :param U0:
        :type U0: float
        :param U1:
        :type U1: float
        :param FirstCons:
        :type FirstCons: AppParCurves_Constraint
        :param LastCons:
        :type LastCons: AppParCurves_Constraint
        :param Deg:
        :type Deg: int
        :param NbPoints: default value is 24
        :type NbPoints: int
        :rtype: None

        """
        _Approx.Approx_MyLeastSquareOfFitAndDivide_swiginit(self,_Approx.new_Approx_MyLeastSquareOfFitAndDivide(*args))
    def IsDone(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_MyLeastSquareOfFitAndDivide_IsDone(self, *args)

    def Value(self, *args):
        """
        :rtype: AppParCurves_MultiCurve

        """
        return _Approx.Approx_MyLeastSquareOfFitAndDivide_Value(self, *args)

    def Error(self, *args):
        """
        :param F:
        :type F: float &
        :param MaxE3d:
        :type MaxE3d: float &
        :param MaxE2d:
        :type MaxE2d: float &
        :rtype: None

        """
        return _Approx.Approx_MyLeastSquareOfFitAndDivide_Error(self, *args)

    __swig_destroy__ = _Approx.delete_Approx_MyLeastSquareOfFitAndDivide
Approx_MyLeastSquareOfFitAndDivide.IsDone = new_instancemethod(_Approx.Approx_MyLeastSquareOfFitAndDivide_IsDone,None,Approx_MyLeastSquareOfFitAndDivide)
Approx_MyLeastSquareOfFitAndDivide.Value = new_instancemethod(_Approx.Approx_MyLeastSquareOfFitAndDivide_Value,None,Approx_MyLeastSquareOfFitAndDivide)
Approx_MyLeastSquareOfFitAndDivide.Error = new_instancemethod(_Approx.Approx_MyLeastSquareOfFitAndDivide_Error,None,Approx_MyLeastSquareOfFitAndDivide)
Approx_MyLeastSquareOfFitAndDivide_swigregister = _Approx.Approx_MyLeastSquareOfFitAndDivide_swigregister
Approx_MyLeastSquareOfFitAndDivide_swigregister(Approx_MyLeastSquareOfFitAndDivide)

class Approx_MyLeastSquareOfFitAndDivide2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param SSP:
        :type SSP: AppCont_Function2d &
        :param U0:
        :type U0: float
        :param U1:
        :type U1: float
        :param FirstCons:
        :type FirstCons: AppParCurves_Constraint
        :param LastCons:
        :type LastCons: AppParCurves_Constraint
        :param Deg:
        :type Deg: int
        :param NbPoints: default value is 24
        :type NbPoints: int
        :rtype: None

        """
        _Approx.Approx_MyLeastSquareOfFitAndDivide2d_swiginit(self,_Approx.new_Approx_MyLeastSquareOfFitAndDivide2d(*args))
    def IsDone(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_MyLeastSquareOfFitAndDivide2d_IsDone(self, *args)

    def Value(self, *args):
        """
        :rtype: AppParCurves_MultiCurve

        """
        return _Approx.Approx_MyLeastSquareOfFitAndDivide2d_Value(self, *args)

    def Error(self, *args):
        """
        :param F:
        :type F: float &
        :param MaxE3d:
        :type MaxE3d: float &
        :param MaxE2d:
        :type MaxE2d: float &
        :rtype: None

        """
        return _Approx.Approx_MyLeastSquareOfFitAndDivide2d_Error(self, *args)

    __swig_destroy__ = _Approx.delete_Approx_MyLeastSquareOfFitAndDivide2d
Approx_MyLeastSquareOfFitAndDivide2d.IsDone = new_instancemethod(_Approx.Approx_MyLeastSquareOfFitAndDivide2d_IsDone,None,Approx_MyLeastSquareOfFitAndDivide2d)
Approx_MyLeastSquareOfFitAndDivide2d.Value = new_instancemethod(_Approx.Approx_MyLeastSquareOfFitAndDivide2d_Value,None,Approx_MyLeastSquareOfFitAndDivide2d)
Approx_MyLeastSquareOfFitAndDivide2d.Error = new_instancemethod(_Approx.Approx_MyLeastSquareOfFitAndDivide2d_Error,None,Approx_MyLeastSquareOfFitAndDivide2d)
Approx_MyLeastSquareOfFitAndDivide2d_swigregister = _Approx.Approx_MyLeastSquareOfFitAndDivide2d_swigregister
Approx_MyLeastSquareOfFitAndDivide2d_swigregister(Approx_MyLeastSquareOfFitAndDivide2d)

class Approx_SameParameter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Warning: the C3D and C2D must have the same parametric domain.

        :param C3D:
        :type C3D: Handle_Geom_Curve &
        :param C2D:
        :type C2D: Handle_Geom2d_Curve &
        :param S:
        :type S: Handle_Geom_Surface &
        :param Tol:
        :type Tol: float
        :rtype: None

        :param C3D:
        :type C3D: Handle_Adaptor3d_HCurve &
        :param C2D:
        :type C2D: Handle_Geom2d_Curve &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param Tol:
        :type Tol: float
        :rtype: None

        * Warning: the C3D and C2D must have the same parametric domain.

        :param C3D:
        :type C3D: Handle_Adaptor3d_HCurve &
        :param C2D:
        :type C2D: Handle_Adaptor2d_HCurve2d &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param Tol:
        :type Tol: float
        :rtype: None

        """
        _Approx.Approx_SameParameter_swiginit(self,_Approx.new_Approx_SameParameter(*args))
    def IsDone(self, *args):
        """
        :rtype: bool

        """
        return _Approx.Approx_SameParameter_IsDone(self, *args)

    def TolReached(self, *args):
        """
        :rtype: float

        """
        return _Approx.Approx_SameParameter_TolReached(self, *args)

    def IsSameParameter(self, *args):
        """
        * Tells whether the original data had already the same parameter up to the tolerance : in that case nothing is done.

        :rtype: bool

        """
        return _Approx.Approx_SameParameter_IsSameParameter(self, *args)

    def Curve2d(self, *args):
        """
        * Returns the 2D curve that has the same parameter as the 3D curve once evaluated on the surface up to the specified tolerance

        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _Approx.Approx_SameParameter_Curve2d(self, *args)

    __swig_destroy__ = _Approx.delete_Approx_SameParameter
Approx_SameParameter.IsDone = new_instancemethod(_Approx.Approx_SameParameter_IsDone,None,Approx_SameParameter)
Approx_SameParameter.TolReached = new_instancemethod(_Approx.Approx_SameParameter_TolReached,None,Approx_SameParameter)
Approx_SameParameter.IsSameParameter = new_instancemethod(_Approx.Approx_SameParameter_IsSameParameter,None,Approx_SameParameter)
Approx_SameParameter.Curve2d = new_instancemethod(_Approx.Approx_SameParameter_Curve2d,None,Approx_SameParameter)
Approx_SameParameter_swigregister = _Approx.Approx_SameParameter_swigregister
Approx_SameParameter_swigregister(Approx_SameParameter)

class Approx_SequenceNodeOfSequenceOfHArray1OfReal(OCC.TCollection.TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param I:
        :type I: Handle_TColStd_HArray1OfReal &
        :param n:
        :type n: TCollection_SeqNodePtr &
        :param p:
        :type p: TCollection_SeqNodePtr &
        :rtype: None

        """
        _Approx.Approx_SequenceNodeOfSequenceOfHArray1OfReal_swiginit(self,_Approx.new_Approx_SequenceNodeOfSequenceOfHArray1OfReal(*args))
    def Value(self, *args):
        """
        :rtype: Handle_TColStd_HArray1OfReal

        """
        return _Approx.Approx_SequenceNodeOfSequenceOfHArray1OfReal_Value(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _Approx.delete_Approx_SequenceNodeOfSequenceOfHArray1OfReal
Approx_SequenceNodeOfSequenceOfHArray1OfReal.Value = new_instancemethod(_Approx.Approx_SequenceNodeOfSequenceOfHArray1OfReal_Value,None,Approx_SequenceNodeOfSequenceOfHArray1OfReal)
Approx_SequenceNodeOfSequenceOfHArray1OfReal_swigregister = _Approx.Approx_SequenceNodeOfSequenceOfHArray1OfReal_swigregister
Approx_SequenceNodeOfSequenceOfHArray1OfReal_swigregister(Approx_SequenceNodeOfSequenceOfHArray1OfReal)

class Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal(OCC.TCollection.Handle_TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _Approx.Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_swiginit(self,_Approx.new_Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Approx.Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_DownCast)
    __swig_destroy__ = _Approx.delete_Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal
Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal.Nullify = new_instancemethod(_Approx.Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_Nullify,None,Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal)
Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal.IsNull = new_instancemethod(_Approx.Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_IsNull,None,Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal)
Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal.GetObject = new_instancemethod(_Approx.Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_GetObject,None,Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal)
Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_swigregister = _Approx.Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_swigregister
Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_swigregister(Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal)

def Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_DownCast(*args):
  return _Approx.Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_DownCast(*args)
Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_DownCast = _Approx.Handle_Approx_SequenceNodeOfSequenceOfHArray1OfReal_DownCast

class Approx_SequenceOfHArray1OfReal(OCC.TCollection.TCollection_BaseSequence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        """
        _Approx.Approx_SequenceOfHArray1OfReal_swiginit(self,_Approx.new_Approx_SequenceOfHArray1OfReal(*args))
    def Clear(self, *args):
        """
        :rtype: None

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_Clear(self, *args)

    def Assign(self, *args):
        """
        :param Other:
        :type Other: Approx_SequenceOfHArray1OfReal &
        :rtype: Approx_SequenceOfHArray1OfReal

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_Assign(self, *args)

    def Set(self, *args):
        """
        :param Other:
        :type Other: Approx_SequenceOfHArray1OfReal &
        :rtype: Approx_SequenceOfHArray1OfReal

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_Set(self, *args)

    def Append(self, *args):
        """
        :param T:
        :type T: Handle_TColStd_HArray1OfReal &
        :rtype: None

        :param S:
        :type S: Approx_SequenceOfHArray1OfReal &
        :rtype: None

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_Append(self, *args)

    def Prepend(self, *args):
        """
        :param T:
        :type T: Handle_TColStd_HArray1OfReal &
        :rtype: None

        :param S:
        :type S: Approx_SequenceOfHArray1OfReal &
        :rtype: None

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_Prepend(self, *args)

    def InsertBefore(self, *args):
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_TColStd_HArray1OfReal &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: Approx_SequenceOfHArray1OfReal &
        :rtype: None

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_InsertBefore(self, *args)

    def InsertAfter(self, *args):
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_TColStd_HArray1OfReal &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: Approx_SequenceOfHArray1OfReal &
        :rtype: None

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_InsertAfter(self, *args)

    def First(self, *args):
        """
        :rtype: Handle_TColStd_HArray1OfReal

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_First(self, *args)

    def Last(self, *args):
        """
        :rtype: Handle_TColStd_HArray1OfReal

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_Last(self, *args)

    def Split(self, *args):
        """
        :param Index:
        :type Index: int
        :param Sub:
        :type Sub: Approx_SequenceOfHArray1OfReal &
        :rtype: None

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_Split(self, *args)

    def Value(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_TColStd_HArray1OfReal

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_Value(self, *args)

    def SetValue(self, *args):
        """
        :param Index:
        :type Index: int
        :param I:
        :type I: Handle_TColStd_HArray1OfReal &
        :rtype: None

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_SetValue(self, *args)

    def ChangeValue(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_TColStd_HArray1OfReal

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_ChangeValue(self, *args)

    def Remove(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: None

        :param FromIndex:
        :type FromIndex: int
        :param ToIndex:
        :type ToIndex: int
        :rtype: None

        """
        return _Approx.Approx_SequenceOfHArray1OfReal_Remove(self, *args)

    __swig_destroy__ = _Approx.delete_Approx_SequenceOfHArray1OfReal
Approx_SequenceOfHArray1OfReal.Clear = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Clear,None,Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Assign = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Assign,None,Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Set = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Set,None,Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Append = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Append,None,Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Prepend = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Prepend,None,Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.InsertBefore = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_InsertBefore,None,Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.InsertAfter = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_InsertAfter,None,Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.First = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_First,None,Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Last = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Last,None,Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Split = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Split,None,Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Value = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Value,None,Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.SetValue = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_SetValue,None,Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.ChangeValue = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_ChangeValue,None,Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal.Remove = new_instancemethod(_Approx.Approx_SequenceOfHArray1OfReal_Remove,None,Approx_SequenceOfHArray1OfReal)
Approx_SequenceOfHArray1OfReal_swigregister = _Approx.Approx_SequenceOfHArray1OfReal_swigregister
Approx_SequenceOfHArray1OfReal_swigregister(Approx_SequenceOfHArray1OfReal)

class Approx_SweepApproximation(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param Func:
        :type Func: Handle_Approx_SweepFunction &
        :rtype: None

        """
        _Approx.Approx_SweepApproximation_swiginit(self,_Approx.new_Approx_SweepApproximation(*args))
    def Perform(self, *args):
        """
        * Perform the Approximation [First, Last] : Approx_SweepApproximation.cdl Tol3d : Tolerance to surface approximation Tol2d : Tolerance used to perform curve approximation  Normaly the 2d curve are approximated with a  tolerance given by the resolution on support surfaces,  but if this tolerance is too large Tol2d is used. TolAngular : Tolerance (in radian) to control the angle  beetween tangents on the section law and  tangent of iso-v on approximed surface Continuity : The continuity in v waiting on the surface Degmax : The maximum degree in v requiered on the surface Segmax : The maximum number of span in v requiered on  the surface Warning : The continuity ci can be obtained only if Ft is Ci

        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param Tol3d:
        :type Tol3d: float
        :param BoundTol:
        :type BoundTol: float
        :param Tol2d:
        :type Tol2d: float
        :param TolAngular:
        :type TolAngular: float
        :param Continuity: default value is GeomAbs_C0
        :type Continuity: GeomAbs_Shape
        :param Degmax: default value is 11
        :type Degmax: int
        :param Segmax: default value is 50
        :type Segmax: int
        :rtype: None

        """
        return _Approx.Approx_SweepApproximation_Perform(self, *args)

    def Eval(self, *args):
        """
        * The EvaluatorFunction from AdvApprox;

        :param Parameter:
        :type Parameter: float
        :param DerivativeRequest:
        :type DerivativeRequest: int
        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param Result:
        :type Result: float &
        :rtype: int

        """
        return _Approx.Approx_SweepApproximation_Eval(self, *args)

    def IsDone(self, *args):
        """
        * returns if we have an result

        :rtype: bool

        """
        return _Approx.Approx_SweepApproximation_IsDone(self, *args)

    def SurfShape(self, *args):
        """
        :param UDegree:
        :type UDegree: int &
        :param VDegree:
        :type VDegree: int &
        :param NbUPoles:
        :type NbUPoles: int &
        :param NbVPoles:
        :type NbVPoles: int &
        :param NbUKnots:
        :type NbUKnots: int &
        :param NbVKnots:
        :type NbVKnots: int &
        :rtype: None

        """
        return _Approx.Approx_SweepApproximation_SurfShape(self, *args)

    def Surface(self, *args):
        """
        :param TPoles:
        :type TPoles: TColgp_Array2OfPnt
        :param TWeights:
        :type TWeights: TColStd_Array2OfReal &
        :param TUKnots:
        :type TUKnots: TColStd_Array1OfReal &
        :param TVKnots:
        :type TVKnots: TColStd_Array1OfReal &
        :param TUMults:
        :type TUMults: TColStd_Array1OfInteger &
        :param TVMults:
        :type TVMults: TColStd_Array1OfInteger &
        :rtype: None

        """
        return _Approx.Approx_SweepApproximation_Surface(self, *args)

    def UDegree(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_SweepApproximation_UDegree(self, *args)

    def VDegree(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_SweepApproximation_VDegree(self, *args)

    def SurfPoles(self, *args):
        """
        :rtype: TColgp_Array2OfPnt

        """
        return _Approx.Approx_SweepApproximation_SurfPoles(self, *args)

    def SurfWeights(self, *args):
        """
        :rtype: TColStd_Array2OfReal

        """
        return _Approx.Approx_SweepApproximation_SurfWeights(self, *args)

    def SurfUKnots(self, *args):
        """
        :rtype: TColStd_Array1OfReal

        """
        return _Approx.Approx_SweepApproximation_SurfUKnots(self, *args)

    def SurfVKnots(self, *args):
        """
        :rtype: TColStd_Array1OfReal

        """
        return _Approx.Approx_SweepApproximation_SurfVKnots(self, *args)

    def SurfUMults(self, *args):
        """
        :rtype: TColStd_Array1OfInteger

        """
        return _Approx.Approx_SweepApproximation_SurfUMults(self, *args)

    def SurfVMults(self, *args):
        """
        :rtype: TColStd_Array1OfInteger

        """
        return _Approx.Approx_SweepApproximation_SurfVMults(self, *args)

    def MaxErrorOnSurf(self, *args):
        """
        * returns the maximum error in the suface approximation.

        :rtype: float

        """
        return _Approx.Approx_SweepApproximation_MaxErrorOnSurf(self, *args)

    def AverageErrorOnSurf(self, *args):
        """
        * returns the average error in the suface approximation.

        :rtype: float

        """
        return _Approx.Approx_SweepApproximation_AverageErrorOnSurf(self, *args)

    def NbCurves2d(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_SweepApproximation_NbCurves2d(self, *args)

    def Curves2dShape(self, *args):
        """
        :param Degree:
        :type Degree: int &
        :param NbPoles:
        :type NbPoles: int &
        :param NbKnots:
        :type NbKnots: int &
        :rtype: None

        """
        return _Approx.Approx_SweepApproximation_Curves2dShape(self, *args)

    def Curve2d(self, *args):
        """
        :param Index:
        :type Index: int
        :param TPoles:
        :type TPoles: TColgp_Array1OfPnt2d
        :param TKnots:
        :type TKnots: TColStd_Array1OfReal &
        :param TMults:
        :type TMults: TColStd_Array1OfInteger &
        :rtype: None

        """
        return _Approx.Approx_SweepApproximation_Curve2d(self, *args)

    def Curves2dDegree(self, *args):
        """
        :rtype: int

        """
        return _Approx.Approx_SweepApproximation_Curves2dDegree(self, *args)

    def Curve2dPoles(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: TColgp_Array1OfPnt2d

        """
        return _Approx.Approx_SweepApproximation_Curve2dPoles(self, *args)

    def Curves2dKnots(self, *args):
        """
        :rtype: TColStd_Array1OfReal

        """
        return _Approx.Approx_SweepApproximation_Curves2dKnots(self, *args)

    def Curves2dMults(self, *args):
        """
        :rtype: TColStd_Array1OfInteger

        """
        return _Approx.Approx_SweepApproximation_Curves2dMults(self, *args)

    def Max2dError(self, *args):
        """
        * returns the maximum error of the <Index> 2d curve approximation.

        :param Index:
        :type Index: int
        :rtype: float

        """
        return _Approx.Approx_SweepApproximation_Max2dError(self, *args)

    def Average2dError(self, *args):
        """
        * returns the average error of the <Index> 2d curve approximation.

        :param Index:
        :type Index: int
        :rtype: float

        """
        return _Approx.Approx_SweepApproximation_Average2dError(self, *args)

    def TolCurveOnSurf(self, *args):
        """
        * returns the maximum 3d error of the <Index> 2d curve approximation on the Surface.

        :param Index:
        :type Index: int
        :rtype: float

        """
        return _Approx.Approx_SweepApproximation_TolCurveOnSurf(self, *args)

    def DumpToString(self):
        """DumpToString(Approx_SweepApproximation self) -> std::string"""
        return _Approx.Approx_SweepApproximation_DumpToString(self)

    __swig_destroy__ = _Approx.delete_Approx_SweepApproximation
Approx_SweepApproximation.Perform = new_instancemethod(_Approx.Approx_SweepApproximation_Perform,None,Approx_SweepApproximation)
Approx_SweepApproximation.Eval = new_instancemethod(_Approx.Approx_SweepApproximation_Eval,None,Approx_SweepApproximation)
Approx_SweepApproximation.IsDone = new_instancemethod(_Approx.Approx_SweepApproximation_IsDone,None,Approx_SweepApproximation)
Approx_SweepApproximation.SurfShape = new_instancemethod(_Approx.Approx_SweepApproximation_SurfShape,None,Approx_SweepApproximation)
Approx_SweepApproximation.Surface = new_instancemethod(_Approx.Approx_SweepApproximation_Surface,None,Approx_SweepApproximation)
Approx_SweepApproximation.UDegree = new_instancemethod(_Approx.Approx_SweepApproximation_UDegree,None,Approx_SweepApproximation)
Approx_SweepApproximation.VDegree = new_instancemethod(_Approx.Approx_SweepApproximation_VDegree,None,Approx_SweepApproximation)
Approx_SweepApproximation.SurfPoles = new_instancemethod(_Approx.Approx_SweepApproximation_SurfPoles,None,Approx_SweepApproximation)
Approx_SweepApproximation.SurfWeights = new_instancemethod(_Approx.Approx_SweepApproximation_SurfWeights,None,Approx_SweepApproximation)
Approx_SweepApproximation.SurfUKnots = new_instancemethod(_Approx.Approx_SweepApproximation_SurfUKnots,None,Approx_SweepApproximation)
Approx_SweepApproximation.SurfVKnots = new_instancemethod(_Approx.Approx_SweepApproximation_SurfVKnots,None,Approx_SweepApproximation)
Approx_SweepApproximation.SurfUMults = new_instancemethod(_Approx.Approx_SweepApproximation_SurfUMults,None,Approx_SweepApproximation)
Approx_SweepApproximation.SurfVMults = new_instancemethod(_Approx.Approx_SweepApproximation_SurfVMults,None,Approx_SweepApproximation)
Approx_SweepApproximation.MaxErrorOnSurf = new_instancemethod(_Approx.Approx_SweepApproximation_MaxErrorOnSurf,None,Approx_SweepApproximation)
Approx_SweepApproximation.AverageErrorOnSurf = new_instancemethod(_Approx.Approx_SweepApproximation_AverageErrorOnSurf,None,Approx_SweepApproximation)
Approx_SweepApproximation.NbCurves2d = new_instancemethod(_Approx.Approx_SweepApproximation_NbCurves2d,None,Approx_SweepApproximation)
Approx_SweepApproximation.Curves2dShape = new_instancemethod(_Approx.Approx_SweepApproximation_Curves2dShape,None,Approx_SweepApproximation)
Approx_SweepApproximation.Curve2d = new_instancemethod(_Approx.Approx_SweepApproximation_Curve2d,None,Approx_SweepApproximation)
Approx_SweepApproximation.Curves2dDegree = new_instancemethod(_Approx.Approx_SweepApproximation_Curves2dDegree,None,Approx_SweepApproximation)
Approx_SweepApproximation.Curve2dPoles = new_instancemethod(_Approx.Approx_SweepApproximation_Curve2dPoles,None,Approx_SweepApproximation)
Approx_SweepApproximation.Curves2dKnots = new_instancemethod(_Approx.Approx_SweepApproximation_Curves2dKnots,None,Approx_SweepApproximation)
Approx_SweepApproximation.Curves2dMults = new_instancemethod(_Approx.Approx_SweepApproximation_Curves2dMults,None,Approx_SweepApproximation)
Approx_SweepApproximation.Max2dError = new_instancemethod(_Approx.Approx_SweepApproximation_Max2dError,None,Approx_SweepApproximation)
Approx_SweepApproximation.Average2dError = new_instancemethod(_Approx.Approx_SweepApproximation_Average2dError,None,Approx_SweepApproximation)
Approx_SweepApproximation.TolCurveOnSurf = new_instancemethod(_Approx.Approx_SweepApproximation_TolCurveOnSurf,None,Approx_SweepApproximation)
Approx_SweepApproximation.DumpToString = new_instancemethod(_Approx.Approx_SweepApproximation_DumpToString,None,Approx_SweepApproximation)
Approx_SweepApproximation_swigregister = _Approx.Approx_SweepApproximation_swigregister
Approx_SweepApproximation_swigregister(Approx_SweepApproximation)

class Approx_SweepFunction(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def D0(self, *args):
        """
        * compute the section for v = param

        :param Param:
        :type Param: float
        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :rtype: bool

        """
        return _Approx.Approx_SweepFunction_D0(self, *args)

    def D1(self, *args):
        """
        * compute the first derivative in v direction of the section for v = param Warning : It used only for C1 or C2 aproximation

        :param Param:
        :type Param: float
        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :rtype: bool

        """
        return _Approx.Approx_SweepFunction_D1(self, *args)

    def D2(self, *args):
        """
        * compute the second derivative in v direction of the section for v = param Warning : It used only for C2 aproximation

        :param Param:
        :type Param: float
        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param D2Poles:
        :type D2Poles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param D2Poles2d:
        :type D2Poles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :param D2Weigths:
        :type D2Weigths: TColStd_Array1OfReal &
        :rtype: bool

        """
        return _Approx.Approx_SweepFunction_D2(self, *args)

    def Nb2dCurves(self, *args):
        """
        * get the number of 2d curves to approximate.

        :rtype: int

        """
        return _Approx.Approx_SweepFunction_Nb2dCurves(self, *args)

    def SectionShape(self, *args):
        """
        * get the format of an section

        :param NbPoles:
        :type NbPoles: int &
        :param NbKnots:
        :type NbKnots: int &
        :param Degree:
        :type Degree: int &
        :rtype: void

        """
        return _Approx.Approx_SweepFunction_SectionShape(self, *args)

    def Knots(self, *args):
        """
        * get the Knots of the section

        :param TKnots:
        :type TKnots: TColStd_Array1OfReal &
        :rtype: void

        """
        return _Approx.Approx_SweepFunction_Knots(self, *args)

    def Mults(self, *args):
        """
        * get the Multplicities of the section

        :param TMults:
        :type TMults: TColStd_Array1OfInteger &
        :rtype: void

        """
        return _Approx.Approx_SweepFunction_Mults(self, *args)

    def IsRational(self, *args):
        """
        * Returns if the sections are rationnal or not

        :rtype: bool

        """
        return _Approx.Approx_SweepFunction_IsRational(self, *args)

    def NbIntervals(self, *args):
        """
        * Returns the number of intervals for continuity <S>. May be one if Continuity(me) >= <S>

        :param S:
        :type S: GeomAbs_Shape
        :rtype: int

        """
        return _Approx.Approx_SweepFunction_NbIntervals(self, *args)

    def Intervals(self, *args):
        """
        * Stores in <T> the parameters bounding the intervals of continuity <S>.  The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals()

        :param T:
        :type T: TColStd_Array1OfReal &
        :param S:
        :type S: GeomAbs_Shape
        :rtype: void

        """
        return _Approx.Approx_SweepFunction_Intervals(self, *args)

    def SetInterval(self, *args):
        """
        * Sets the bounds of the parametric interval on the fonction This determines the derivatives in these values if the function is not Cn.

        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :rtype: void

        """
        return _Approx.Approx_SweepFunction_SetInterval(self, *args)

    def Resolution(self, *args):
        """
        * Returns the resolutions in the sub-space 2d <Index> This information is usfull to find an good tolerance in 2d approximation.

        :param Index:
        :type Index: int
        :param Tol:
        :type Tol: float
        :param TolU:
        :type TolU: float &
        :param TolV:
        :type TolV: float &
        :rtype: void

        """
        return _Approx.Approx_SweepFunction_Resolution(self, *args)

    def GetTolerance(self, *args):
        """
        * Returns the tolerance to reach in approximation to satisfy. BoundTol error at the Boundary AngleTol tangent error at the Boundary (in radian) SurfTol error inside the surface.

        :param BoundTol:
        :type BoundTol: float
        :param SurfTol:
        :type SurfTol: float
        :param AngleTol:
        :type AngleTol: float
        :param Tol3d:
        :type Tol3d: TColStd_Array1OfReal &
        :rtype: void

        """
        return _Approx.Approx_SweepFunction_GetTolerance(self, *args)

    def SetTolerance(self, *args):
        """
        * Is usefull, if (me) have to run numerical algorithm to perform D0, D1 or D2

        :param Tol3d:
        :type Tol3d: float
        :param Tol2d:
        :type Tol2d: float
        :rtype: void

        """
        return _Approx.Approx_SweepFunction_SetTolerance(self, *args)

    def BarycentreOfSurf(self, *args):
        """
        * Get the barycentre of Surface. An very poor estimation is sufficent. This information is usefull to perform well conditioned rational approximation. Warning: Used only if <self> IsRational

        :rtype: gp_Pnt

        """
        return _Approx.Approx_SweepFunction_BarycentreOfSurf(self, *args)

    def MaximalSection(self, *args):
        """
        * Returns the length of the greater section. This information is usefull to G1's control. Warning: With an little value, approximation can be slower.

        :rtype: float

        """
        return _Approx.Approx_SweepFunction_MaximalSection(self, *args)

    def GetMinimalWeight(self, *args):
        """
        * Compute the minimal value of weight for each poles in all sections. This information is usefull to control error in rational approximation. Warning: Used only if <self> IsRational

        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :rtype: void

        """
        return _Approx.Approx_SweepFunction_GetMinimalWeight(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Approx_SweepFunction(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _Approx.delete_Approx_SweepFunction
Approx_SweepFunction.D0 = new_instancemethod(_Approx.Approx_SweepFunction_D0,None,Approx_SweepFunction)
Approx_SweepFunction.D1 = new_instancemethod(_Approx.Approx_SweepFunction_D1,None,Approx_SweepFunction)
Approx_SweepFunction.D2 = new_instancemethod(_Approx.Approx_SweepFunction_D2,None,Approx_SweepFunction)
Approx_SweepFunction.Nb2dCurves = new_instancemethod(_Approx.Approx_SweepFunction_Nb2dCurves,None,Approx_SweepFunction)
Approx_SweepFunction.SectionShape = new_instancemethod(_Approx.Approx_SweepFunction_SectionShape,None,Approx_SweepFunction)
Approx_SweepFunction.Knots = new_instancemethod(_Approx.Approx_SweepFunction_Knots,None,Approx_SweepFunction)
Approx_SweepFunction.Mults = new_instancemethod(_Approx.Approx_SweepFunction_Mults,None,Approx_SweepFunction)
Approx_SweepFunction.IsRational = new_instancemethod(_Approx.Approx_SweepFunction_IsRational,None,Approx_SweepFunction)
Approx_SweepFunction.NbIntervals = new_instancemethod(_Approx.Approx_SweepFunction_NbIntervals,None,Approx_SweepFunction)
Approx_SweepFunction.Intervals = new_instancemethod(_Approx.Approx_SweepFunction_Intervals,None,Approx_SweepFunction)
Approx_SweepFunction.SetInterval = new_instancemethod(_Approx.Approx_SweepFunction_SetInterval,None,Approx_SweepFunction)
Approx_SweepFunction.Resolution = new_instancemethod(_Approx.Approx_SweepFunction_Resolution,None,Approx_SweepFunction)
Approx_SweepFunction.GetTolerance = new_instancemethod(_Approx.Approx_SweepFunction_GetTolerance,None,Approx_SweepFunction)
Approx_SweepFunction.SetTolerance = new_instancemethod(_Approx.Approx_SweepFunction_SetTolerance,None,Approx_SweepFunction)
Approx_SweepFunction.BarycentreOfSurf = new_instancemethod(_Approx.Approx_SweepFunction_BarycentreOfSurf,None,Approx_SweepFunction)
Approx_SweepFunction.MaximalSection = new_instancemethod(_Approx.Approx_SweepFunction_MaximalSection,None,Approx_SweepFunction)
Approx_SweepFunction.GetMinimalWeight = new_instancemethod(_Approx.Approx_SweepFunction_GetMinimalWeight,None,Approx_SweepFunction)
Approx_SweepFunction_swigregister = _Approx.Approx_SweepFunction_swigregister
Approx_SweepFunction_swigregister(Approx_SweepFunction)

class Handle_Approx_SweepFunction(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _Approx.Handle_Approx_SweepFunction_swiginit(self,_Approx.new_Handle_Approx_SweepFunction(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Approx.Handle_Approx_SweepFunction_DownCast)
    __swig_destroy__ = _Approx.delete_Handle_Approx_SweepFunction
Handle_Approx_SweepFunction.Nullify = new_instancemethod(_Approx.Handle_Approx_SweepFunction_Nullify,None,Handle_Approx_SweepFunction)
Handle_Approx_SweepFunction.IsNull = new_instancemethod(_Approx.Handle_Approx_SweepFunction_IsNull,None,Handle_Approx_SweepFunction)
Handle_Approx_SweepFunction.GetObject = new_instancemethod(_Approx.Handle_Approx_SweepFunction_GetObject,None,Handle_Approx_SweepFunction)
Handle_Approx_SweepFunction_swigregister = _Approx.Handle_Approx_SweepFunction_swigregister
Handle_Approx_SweepFunction_swigregister(Handle_Approx_SweepFunction)

def Handle_Approx_SweepFunction_DownCast(*args):
  return _Approx.Handle_Approx_SweepFunction_DownCast(*args)
Handle_Approx_SweepFunction_DownCast = _Approx.Handle_Approx_SweepFunction_DownCast



