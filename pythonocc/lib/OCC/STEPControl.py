# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _STEPControl.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_STEPControl', [dirname(__file__)])
        except ImportError:
            import _STEPControl
            return _STEPControl
        if fp is not None:
            try:
                _mod = imp.load_module('_STEPControl', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _STEPControl = swig_import_helper()
    del swig_import_helper
else:
    import _STEPControl
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _STEPControl.delete_SwigPyIterator
    def __iter__(self): return self
SwigPyIterator.value = new_instancemethod(_STEPControl.SwigPyIterator_value,None,SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_STEPControl.SwigPyIterator_incr,None,SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_STEPControl.SwigPyIterator_decr,None,SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_STEPControl.SwigPyIterator_distance,None,SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_STEPControl.SwigPyIterator_equal,None,SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_STEPControl.SwigPyIterator_copy,None,SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_STEPControl.SwigPyIterator_next,None,SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_STEPControl.SwigPyIterator___next__,None,SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_STEPControl.SwigPyIterator_previous,None,SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_STEPControl.SwigPyIterator_advance,None,SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_STEPControl.SwigPyIterator___eq__,None,SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_STEPControl.SwigPyIterator___ne__,None,SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_STEPControl.SwigPyIterator___iadd__,None,SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_STEPControl.SwigPyIterator___isub__,None,SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_STEPControl.SwigPyIterator___add__,None,SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_STEPControl.SwigPyIterator___sub__,None,SwigPyIterator)
SwigPyIterator_swigregister = _STEPControl.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import OCC.Standard
import OCC.StepRepr
import OCC.MMgt
import OCC.TCollection
import OCC.StepBasic
import OCC.TColStd
import OCC.Interface
import OCC.Message
import OCC.StepGeom
import OCC.gp
import OCC.StepShape
import OCC.TopTools
import OCC.TopoDS
import OCC.TopLoc
import OCC.TopAbs
import OCC.XSControl
import OCC.IFSelect
import OCC.Dico
def register_handle(handle, base_object):
    """
    Inserts the handle into the base object to
    prevent memory corruption in certain cases
    """
    try:
        if base_object.IsKind("Standard_Transient"):
            base_object.thisHandle = handle
            base_object.thisown = False
    except:
        pass

STEPControl_AsIs = _STEPControl.STEPControl_AsIs
STEPControl_ManifoldSolidBrep = _STEPControl.STEPControl_ManifoldSolidBrep
STEPControl_BrepWithVoids = _STEPControl.STEPControl_BrepWithVoids
STEPControl_FacetedBrep = _STEPControl.STEPControl_FacetedBrep
STEPControl_FacetedBrepAndBrepWithVoids = _STEPControl.STEPControl_FacetedBrepAndBrepWithVoids
STEPControl_ShellBasedSurfaceModel = _STEPControl.STEPControl_ShellBasedSurfaceModel
STEPControl_GeometricCurveSet = _STEPControl.STEPControl_GeometricCurveSet
STEPControl_Hybrid = _STEPControl.STEPControl_Hybrid
class STEPControl_ActorRead(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        """
        _STEPControl.STEPControl_ActorRead_swiginit(self,_STEPControl.new_STEPControl_ActorRead(*args))
    def Recognize(self, *args):
        """
        :param start:
        :type start: Handle_Standard_Transient &
        :rtype: bool

        """
        return _STEPControl.STEPControl_ActorRead_Recognize(self, *args)

    def Transfer(self, *args):
        """
        :param start:
        :type start: Handle_Standard_Transient &
        :param TP:
        :type TP: Handle_Transfer_TransientProcess &
        :rtype: Handle_Transfer_Binder

        """
        return _STEPControl.STEPControl_ActorRead_Transfer(self, *args)

    def TransferShape(self, *args):
        """
        :param start:
        :type start: Handle_Standard_Transient &
        :param TP:
        :type TP: Handle_Transfer_TransientProcess &
        :param isManifold: default value is Standard_True
        :type isManifold: bool
        :rtype: Handle_Transfer_Binder

        """
        return _STEPControl.STEPControl_ActorRead_TransferShape(self, *args)

    def PrepareUnits(self, *args):
        """
        * set units and tolerances context by given ShapeRepresentation

        :param rep:
        :type rep: Handle_StepRepr_Representation &
        :param TP:
        :type TP: Handle_Transfer_TransientProcess &
        :rtype: None

        """
        return _STEPControl.STEPControl_ActorRead_PrepareUnits(self, *args)

    def ResetUnits(self, *args):
        """
        * reset units and tolerances context to default  (mm, radians, read.precision.val, etc.)

        :rtype: None

        """
        return _STEPControl.STEPControl_ActorRead_ResetUnits(self, *args)

    def ComputeTransformation(self, *args):
        """
        * Computes transformation defined by two axis placements (in MAPPED_ITEM or ITEM_DEFINED_TRANSFORMATION) taking into account their representation contexts (i.e. units, which may be different) Returns True if transformation is computed and is not an identity.

        :param Origin:
        :type Origin: Handle_StepGeom_Axis2Placement3d &
        :param Target:
        :type Target: Handle_StepGeom_Axis2Placement3d &
        :param OrigContext:
        :type OrigContext: Handle_StepRepr_Representation &
        :param TargContext:
        :type TargContext: Handle_StepRepr_Representation &
        :param TP:
        :type TP: Handle_Transfer_TransientProcess &
        :param Trsf:
        :type Trsf: gp_Trsf
        :rtype: bool

        """
        return _STEPControl.STEPControl_ActorRead_ComputeTransformation(self, *args)

    def ComputeSRRWT(self, *args):
        """
        * Computes transformation defined by given REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION

        :param SRR:
        :type SRR: Handle_StepRepr_RepresentationRelationship &
        :param TP:
        :type TP: Handle_Transfer_TransientProcess &
        :param Trsf:
        :type Trsf: gp_Trsf
        :rtype: bool

        """
        return _STEPControl.STEPControl_ActorRead_ComputeSRRWT(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_STEPControl_ActorRead(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _STEPControl.delete_STEPControl_ActorRead
STEPControl_ActorRead.Recognize = new_instancemethod(_STEPControl.STEPControl_ActorRead_Recognize,None,STEPControl_ActorRead)
STEPControl_ActorRead.Transfer = new_instancemethod(_STEPControl.STEPControl_ActorRead_Transfer,None,STEPControl_ActorRead)
STEPControl_ActorRead.TransferShape = new_instancemethod(_STEPControl.STEPControl_ActorRead_TransferShape,None,STEPControl_ActorRead)
STEPControl_ActorRead.PrepareUnits = new_instancemethod(_STEPControl.STEPControl_ActorRead_PrepareUnits,None,STEPControl_ActorRead)
STEPControl_ActorRead.ResetUnits = new_instancemethod(_STEPControl.STEPControl_ActorRead_ResetUnits,None,STEPControl_ActorRead)
STEPControl_ActorRead.ComputeTransformation = new_instancemethod(_STEPControl.STEPControl_ActorRead_ComputeTransformation,None,STEPControl_ActorRead)
STEPControl_ActorRead.ComputeSRRWT = new_instancemethod(_STEPControl.STEPControl_ActorRead_ComputeSRRWT,None,STEPControl_ActorRead)
STEPControl_ActorRead_swigregister = _STEPControl.STEPControl_ActorRead_swigregister
STEPControl_ActorRead_swigregister(STEPControl_ActorRead)

class Handle_STEPControl_ActorRead(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _STEPControl.Handle_STEPControl_ActorRead_swiginit(self,_STEPControl.new_Handle_STEPControl_ActorRead(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_STEPControl.Handle_STEPControl_ActorRead_DownCast)
    __swig_destroy__ = _STEPControl.delete_Handle_STEPControl_ActorRead
Handle_STEPControl_ActorRead.Nullify = new_instancemethod(_STEPControl.Handle_STEPControl_ActorRead_Nullify,None,Handle_STEPControl_ActorRead)
Handle_STEPControl_ActorRead.IsNull = new_instancemethod(_STEPControl.Handle_STEPControl_ActorRead_IsNull,None,Handle_STEPControl_ActorRead)
Handle_STEPControl_ActorRead.GetObject = new_instancemethod(_STEPControl.Handle_STEPControl_ActorRead_GetObject,None,Handle_STEPControl_ActorRead)
Handle_STEPControl_ActorRead_swigregister = _STEPControl.Handle_STEPControl_ActorRead_swigregister
Handle_STEPControl_ActorRead_swigregister(Handle_STEPControl_ActorRead)

def Handle_STEPControl_ActorRead_DownCast(*args):
  return _STEPControl.Handle_STEPControl_ActorRead_DownCast(*args)
Handle_STEPControl_ActorRead_DownCast = _STEPControl.Handle_STEPControl_ActorRead_DownCast

class STEPControl_ActorWrite(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        """
        _STEPControl.STEPControl_ActorWrite_swiginit(self,_STEPControl.new_STEPControl_ActorWrite(*args))
    def Recognize(self, *args):
        """
        :param start:
        :type start: Handle_Transfer_Finder &
        :rtype: bool

        """
        return _STEPControl.STEPControl_ActorWrite_Recognize(self, *args)

    def Transfer(self, *args):
        """
        :param start:
        :type start: Handle_Transfer_Finder &
        :param FP:
        :type FP: Handle_Transfer_FinderProcess &
        :rtype: Handle_Transfer_Binder

        """
        return _STEPControl.STEPControl_ActorWrite_Transfer(self, *args)

    def TransferSubShape(self, *args):
        """
        :param start:
        :type start: Handle_Transfer_Finder &
        :param SDR:
        :type SDR: Handle_StepShape_ShapeDefinitionRepresentation &
        :param AX1:
        :type AX1: Handle_StepGeom_Axis2Placement3d &
        :param FP:
        :type FP: Handle_Transfer_FinderProcess &
        :param shapeGroup: default value is NULL
        :type shapeGroup: Handle_TopTools_HSequenceOfShape &
        :param isManifold: default value is Standard_True
        :type isManifold: bool
        :rtype: Handle_Transfer_Binder

        """
        return _STEPControl.STEPControl_ActorWrite_TransferSubShape(self, *args)

    def TransferShape(self, *args):
        """
        :param start:
        :type start: Handle_Transfer_Finder &
        :param SDR:
        :type SDR: Handle_StepShape_ShapeDefinitionRepresentation &
        :param FP:
        :type FP: Handle_Transfer_FinderProcess &
        :param shapeGroup: default value is NULL
        :type shapeGroup: Handle_TopTools_HSequenceOfShape &
        :param isManifold: default value is Standard_True
        :type isManifold: bool
        :rtype: Handle_Transfer_Binder

        """
        return _STEPControl.STEPControl_ActorWrite_TransferShape(self, *args)

    def TransferCompound(self, *args):
        """
        :param start:
        :type start: Handle_Transfer_Finder &
        :param SDR:
        :type SDR: Handle_StepShape_ShapeDefinitionRepresentation &
        :param FP:
        :type FP: Handle_Transfer_FinderProcess &
        :rtype: Handle_Transfer_Binder

        """
        return _STEPControl.STEPControl_ActorWrite_TransferCompound(self, *args)

    def SetMode(self, *args):
        """
        :param M:
        :type M: STEPControl_StepModelType
        :rtype: None

        """
        return _STEPControl.STEPControl_ActorWrite_SetMode(self, *args)

    def Mode(self, *args):
        """
        :rtype: STEPControl_StepModelType

        """
        return _STEPControl.STEPControl_ActorWrite_Mode(self, *args)

    def SetGroupMode(self, *args):
        """
        :param mode:
        :type mode: int
        :rtype: None

        """
        return _STEPControl.STEPControl_ActorWrite_SetGroupMode(self, *args)

    def GroupMode(self, *args):
        """
        :rtype: int

        """
        return _STEPControl.STEPControl_ActorWrite_GroupMode(self, *args)

    def SetTolerance(self, *args):
        """
        :param Tol:
        :type Tol: float
        :rtype: None

        """
        return _STEPControl.STEPControl_ActorWrite_SetTolerance(self, *args)

    def IsAssembly(self, *args):
        """
        * Customizable method to check whether shape S should be written as assembly or not Default implementation uses flag GroupMode and analyses the shape itself NOTE: this method can modify shape

        :param S:
        :type S: TopoDS_Shape &
        :rtype: bool

        """
        return _STEPControl.STEPControl_ActorWrite_IsAssembly(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_STEPControl_ActorWrite(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _STEPControl.delete_STEPControl_ActorWrite
STEPControl_ActorWrite.Recognize = new_instancemethod(_STEPControl.STEPControl_ActorWrite_Recognize,None,STEPControl_ActorWrite)
STEPControl_ActorWrite.Transfer = new_instancemethod(_STEPControl.STEPControl_ActorWrite_Transfer,None,STEPControl_ActorWrite)
STEPControl_ActorWrite.TransferSubShape = new_instancemethod(_STEPControl.STEPControl_ActorWrite_TransferSubShape,None,STEPControl_ActorWrite)
STEPControl_ActorWrite.TransferShape = new_instancemethod(_STEPControl.STEPControl_ActorWrite_TransferShape,None,STEPControl_ActorWrite)
STEPControl_ActorWrite.TransferCompound = new_instancemethod(_STEPControl.STEPControl_ActorWrite_TransferCompound,None,STEPControl_ActorWrite)
STEPControl_ActorWrite.SetMode = new_instancemethod(_STEPControl.STEPControl_ActorWrite_SetMode,None,STEPControl_ActorWrite)
STEPControl_ActorWrite.Mode = new_instancemethod(_STEPControl.STEPControl_ActorWrite_Mode,None,STEPControl_ActorWrite)
STEPControl_ActorWrite.SetGroupMode = new_instancemethod(_STEPControl.STEPControl_ActorWrite_SetGroupMode,None,STEPControl_ActorWrite)
STEPControl_ActorWrite.GroupMode = new_instancemethod(_STEPControl.STEPControl_ActorWrite_GroupMode,None,STEPControl_ActorWrite)
STEPControl_ActorWrite.SetTolerance = new_instancemethod(_STEPControl.STEPControl_ActorWrite_SetTolerance,None,STEPControl_ActorWrite)
STEPControl_ActorWrite.IsAssembly = new_instancemethod(_STEPControl.STEPControl_ActorWrite_IsAssembly,None,STEPControl_ActorWrite)
STEPControl_ActorWrite_swigregister = _STEPControl.STEPControl_ActorWrite_swigregister
STEPControl_ActorWrite_swigregister(STEPControl_ActorWrite)

class Handle_STEPControl_ActorWrite(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _STEPControl.Handle_STEPControl_ActorWrite_swiginit(self,_STEPControl.new_Handle_STEPControl_ActorWrite(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_STEPControl.Handle_STEPControl_ActorWrite_DownCast)
    __swig_destroy__ = _STEPControl.delete_Handle_STEPControl_ActorWrite
Handle_STEPControl_ActorWrite.Nullify = new_instancemethod(_STEPControl.Handle_STEPControl_ActorWrite_Nullify,None,Handle_STEPControl_ActorWrite)
Handle_STEPControl_ActorWrite.IsNull = new_instancemethod(_STEPControl.Handle_STEPControl_ActorWrite_IsNull,None,Handle_STEPControl_ActorWrite)
Handle_STEPControl_ActorWrite.GetObject = new_instancemethod(_STEPControl.Handle_STEPControl_ActorWrite_GetObject,None,Handle_STEPControl_ActorWrite)
Handle_STEPControl_ActorWrite_swigregister = _STEPControl.Handle_STEPControl_ActorWrite_swigregister
Handle_STEPControl_ActorWrite_swigregister(Handle_STEPControl_ActorWrite)

def Handle_STEPControl_ActorWrite_DownCast(*args):
  return _STEPControl.Handle_STEPControl_ActorWrite_DownCast(*args)
Handle_STEPControl_ActorWrite_DownCast = _STEPControl.Handle_STEPControl_ActorWrite_DownCast

class STEPControl_Controller(OCC.XSControl.XSControl_Controller):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Initializes the use of STEP Norm (the first time) and returns a Controller

        :rtype: None

        """
        _STEPControl.STEPControl_Controller_swiginit(self,_STEPControl.new_STEPControl_Controller(*args))
    def Init(*args):
        """
        * Standard Initialisation. It creates a Controller for STEP and records it to various names, available to select it later Returns True when done, False if could not be done

        :rtype: bool

        """
        return _STEPControl.STEPControl_Controller_Init(*args)

    Init = staticmethod(Init)
    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_STEPControl_Controller(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _STEPControl.delete_STEPControl_Controller
STEPControl_Controller_swigregister = _STEPControl.STEPControl_Controller_swigregister
STEPControl_Controller_swigregister(STEPControl_Controller)

def STEPControl_Controller_Init(*args):
  """
    * Standard Initialisation. It creates a Controller for STEP and records it to various names, available to select it later Returns True when done, False if could not be done

    :rtype: bool

    """
  return _STEPControl.STEPControl_Controller_Init(*args)

class Handle_STEPControl_Controller(OCC.XSControl.Handle_XSControl_Controller):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _STEPControl.Handle_STEPControl_Controller_swiginit(self,_STEPControl.new_Handle_STEPControl_Controller(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_STEPControl.Handle_STEPControl_Controller_DownCast)
    __swig_destroy__ = _STEPControl.delete_Handle_STEPControl_Controller
Handle_STEPControl_Controller.Nullify = new_instancemethod(_STEPControl.Handle_STEPControl_Controller_Nullify,None,Handle_STEPControl_Controller)
Handle_STEPControl_Controller.IsNull = new_instancemethod(_STEPControl.Handle_STEPControl_Controller_IsNull,None,Handle_STEPControl_Controller)
Handle_STEPControl_Controller.GetObject = new_instancemethod(_STEPControl.Handle_STEPControl_Controller_GetObject,None,Handle_STEPControl_Controller)
Handle_STEPControl_Controller_swigregister = _STEPControl.Handle_STEPControl_Controller_swigregister
Handle_STEPControl_Controller_swigregister(Handle_STEPControl_Controller)

def Handle_STEPControl_Controller_DownCast(*args):
  return _STEPControl.Handle_STEPControl_Controller_DownCast(*args)
Handle_STEPControl_Controller_DownCast = _STEPControl.Handle_STEPControl_Controller_DownCast

class STEPControl_Reader(OCC.XSControl.XSControl_Reader):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Creates a reader object with an empty STEP model.

        :rtype: None

        * Creates a Reader for STEP from an already existing Session Clears the session if it was not yet set for STEP

        :param WS:
        :type WS: Handle_XSControl_WorkSession &
        :param scratch: default value is Standard_True
        :type scratch: bool
        :rtype: None

        """
        _STEPControl.STEPControl_Reader_swiginit(self,_STEPControl.new_STEPControl_Reader(*args))
    def StepModel(self, *args):
        """
        * Returns the model as a StepModel. It can then be consulted (header, product)

        :rtype: Handle_StepData_StepModel

        """
        return _STEPControl.STEPControl_Reader_StepModel(self, *args)

    def TransferRoot(self, *args):
        """
        * Transfers a root given its rank in the list of candidate roots Default is the first one Returns True if a shape has resulted, false else Same as inherited TransferOneRoot, kept for compatibility

        :param num: default value is 1
        :type num: int
        :rtype: bool

        """
        return _STEPControl.STEPControl_Reader_TransferRoot(self, *args)

    def FileUnits(self, *args):
        """
        * Returns sequence of all unit names for shape representations found in file

        :param theUnitLengthNames:
        :type theUnitLengthNames: TColStd_SequenceOfAsciiString &
        :param theUnitAngleNames:
        :type theUnitAngleNames: TColStd_SequenceOfAsciiString &
        :param theUnitSolidAngleNames:
        :type theUnitSolidAngleNames: TColStd_SequenceOfAsciiString &
        :rtype: None

        """
        return _STEPControl.STEPControl_Reader_FileUnits(self, *args)

    __swig_destroy__ = _STEPControl.delete_STEPControl_Reader
STEPControl_Reader.StepModel = new_instancemethod(_STEPControl.STEPControl_Reader_StepModel,None,STEPControl_Reader)
STEPControl_Reader.TransferRoot = new_instancemethod(_STEPControl.STEPControl_Reader_TransferRoot,None,STEPControl_Reader)
STEPControl_Reader.FileUnits = new_instancemethod(_STEPControl.STEPControl_Reader_FileUnits,None,STEPControl_Reader)
STEPControl_Reader_swigregister = _STEPControl.STEPControl_Reader_swigregister
STEPControl_Reader_swigregister(STEPControl_Reader)

class STEPControl_Writer(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Creates a Writer from scratch

        :rtype: None

        * Creates a Writer from an already existing Session If <scratch> is True (D), clears already recorded data

        :param WS:
        :type WS: Handle_XSControl_WorkSession &
        :param scratch: default value is Standard_True
        :type scratch: bool
        :rtype: None

        """
        _STEPControl.STEPControl_Writer_swiginit(self,_STEPControl.new_STEPControl_Writer(*args))
    def SetTolerance(self, *args):
        """
        * Sets a length-measure value that will be written to uncertainty-measure-with-unit when the next shape is translated.

        :param Tol:
        :type Tol: float
        :rtype: None

        """
        return _STEPControl.STEPControl_Writer_SetTolerance(self, *args)

    def UnsetTolerance(self, *args):
        """
        * Unsets the tolerance formerly forced by SetTolerance

        :rtype: None

        """
        return _STEPControl.STEPControl_Writer_UnsetTolerance(self, *args)

    def SetWS(self, *args):
        """
        * Sets a specific session to <self>

        :param WS:
        :type WS: Handle_XSControl_WorkSession &
        :param scratch: default value is Standard_True
        :type scratch: bool
        :rtype: None

        """
        return _STEPControl.STEPControl_Writer_SetWS(self, *args)

    def WS(self, *args):
        """
        * Returns the session used in <self>

        :rtype: Handle_XSControl_WorkSession

        """
        return _STEPControl.STEPControl_Writer_WS(self, *args)

    def Model(self, *args):
        """
        * Returns the produced model. Produces a new one if not yet done or if <newone> is True This method allows for instance to edit product or header data before writing.

        :param newone: default value is Standard_False
        :type newone: bool
        :rtype: Handle_StepData_StepModel

        """
        return _STEPControl.STEPControl_Writer_Model(self, *args)

    def Transfer(self, *args):
        """
        * Translates shape sh to a STEP entity. mode defines the STEP entity type to be output: - STEPControlStd_AsIs translates a shape to its highest possible STEP representation. - STEPControlStd_ManifoldSolidBrep translates a shape to a STEP manifold_solid_brep or brep_with_voids entity. - STEPControlStd_FacetedBrep translates a shape into a STEP faceted_brep entity. - STEPControlStd_ShellBasedSurfaceModel translates a shape into a STEP shell_based_surface_model entity. - STEPControlStd_GeometricCurveSet translates a shape into a STEP geometric_curve_set entity.

        :param sh:
        :type sh: TopoDS_Shape &
        :param mode:
        :type mode: STEPControl_StepModelType
        :param compgraph: default value is Standard_True
        :type compgraph: bool
        :rtype: IFSelect_ReturnStatus

        """
        return _STEPControl.STEPControl_Writer_Transfer(self, *args)

    def Write(self, *args):
        """
        * Writes a STEP model in the file identified by filename.

        :param filename:
        :type filename: char *
        :rtype: IFSelect_ReturnStatus

        """
        return _STEPControl.STEPControl_Writer_Write(self, *args)

    def PrintStatsTransfer(self, *args):
        """
        * Displays the statistics for the last translation. what defines the kind of statistics that are displayed: - 0 gives general statistics (number of translated roots, number of warnings, number of fail messages), - 1 gives root results, - 2 gives statistics for all checked entities, - 3 gives the list of translated entities, - 4 gives warning and fail messages, - 5 gives fail messages only. mode is used according to the use of what. If what is 0, mode is ignored. If what is 1, 2 or 3, mode defines the following: - 0 lists the numbers of STEP entities in a STEP model, - 1 gives the number, identifier, type and result type for each STEP entity and/or its status (fail, warning, etc.), - 2 gives maximum information for each STEP entity (i.e. checks), - 3 gives the number of entities by the type of a STEP entity, - 4 gives the number of of STEP entities per result type and/or status, - 5 gives the number of pairs (STEP or result type and status), - 6 gives the number of pairs (STEP or result type and status) AND the list of entity numbers in the STEP model.

        :param what:
        :type what: int
        :param mode: default value is 0
        :type mode: int
        :rtype: None

        """
        return _STEPControl.STEPControl_Writer_PrintStatsTransfer(self, *args)

    __swig_destroy__ = _STEPControl.delete_STEPControl_Writer
STEPControl_Writer.SetTolerance = new_instancemethod(_STEPControl.STEPControl_Writer_SetTolerance,None,STEPControl_Writer)
STEPControl_Writer.UnsetTolerance = new_instancemethod(_STEPControl.STEPControl_Writer_UnsetTolerance,None,STEPControl_Writer)
STEPControl_Writer.SetWS = new_instancemethod(_STEPControl.STEPControl_Writer_SetWS,None,STEPControl_Writer)
STEPControl_Writer.WS = new_instancemethod(_STEPControl.STEPControl_Writer_WS,None,STEPControl_Writer)
STEPControl_Writer.Model = new_instancemethod(_STEPControl.STEPControl_Writer_Model,None,STEPControl_Writer)
STEPControl_Writer.Transfer = new_instancemethod(_STEPControl.STEPControl_Writer_Transfer,None,STEPControl_Writer)
STEPControl_Writer.Write = new_instancemethod(_STEPControl.STEPControl_Writer_Write,None,STEPControl_Writer)
STEPControl_Writer.PrintStatsTransfer = new_instancemethod(_STEPControl.STEPControl_Writer_PrintStatsTransfer,None,STEPControl_Writer)
STEPControl_Writer_swigregister = _STEPControl.STEPControl_Writer_swigregister
STEPControl_Writer_swigregister(STEPControl_Writer)



