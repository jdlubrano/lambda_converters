# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _BRepAlgo.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepAlgo', [dirname(__file__)])
        except ImportError:
            import _BRepAlgo
            return _BRepAlgo
        if fp is not None:
            try:
                _mod = imp.load_module('_BRepAlgo', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _BRepAlgo = swig_import_helper()
    del swig_import_helper
else:
    import _BRepAlgo
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepAlgo.delete_SwigPyIterator
    def __iter__(self): return self
SwigPyIterator.value = new_instancemethod(_BRepAlgo.SwigPyIterator_value,None,SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_BRepAlgo.SwigPyIterator_incr,None,SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_BRepAlgo.SwigPyIterator_decr,None,SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_BRepAlgo.SwigPyIterator_distance,None,SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_BRepAlgo.SwigPyIterator_equal,None,SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_BRepAlgo.SwigPyIterator_copy,None,SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_BRepAlgo.SwigPyIterator_next,None,SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_BRepAlgo.SwigPyIterator___next__,None,SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_BRepAlgo.SwigPyIterator_previous,None,SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_BRepAlgo.SwigPyIterator_advance,None,SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_BRepAlgo.SwigPyIterator___eq__,None,SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_BRepAlgo.SwigPyIterator___ne__,None,SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_BRepAlgo.SwigPyIterator___iadd__,None,SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_BRepAlgo.SwigPyIterator___isub__,None,SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_BRepAlgo.SwigPyIterator___add__,None,SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_BRepAlgo.SwigPyIterator___sub__,None,SwigPyIterator)
SwigPyIterator_swigregister = _BRepAlgo.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import OCC.TopoDS
import OCC.MMgt
import OCC.Standard
import OCC.TCollection
import OCC.TopLoc
import OCC.gp
import OCC.TopAbs
import OCC.GeomAbs
import OCC.TopTools
import OCC.TColStd
import OCC.Message
import OCC.BRepBuilderAPI
import OCC.Geom
import OCC.TColgp
import OCC.BRepTools
import OCC.Bnd
import OCC.BRep
import OCC.Poly
import OCC.NCollection
import OCC.TShort
import OCC.Geom2d
import OCC.TopOpeBRepBuild
import OCC.TopOpeBRepTool
import OCC.GeomAdaptor
import OCC.Adaptor3d
import OCC.Adaptor2d
import OCC.math
import OCC.BRepClass3d
import OCC.IntCurveSurface
import OCC.Intf
import OCC.IntSurf
import OCC.BRepAdaptor
import OCC.Geom2dAdaptor
import OCC.IntCurvesFace
import OCC.Extrema
import OCC.TopOpeBRepDS
def register_handle(handle, base_object):
    """
    Inserts the handle into the base object to
    prevent memory corruption in certain cases
    """
    try:
        if base_object.IsKind("Standard_Transient"):
            base_object.thisHandle = handle
            base_object.thisown = False
    except:
        pass

BRepAlgo_OK = _BRepAlgo.BRepAlgo_OK
BRepAlgo_NOK = _BRepAlgo.BRepAlgo_NOK
class brepalgo(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def ConcatenateWire(*args):
        """
        * this method makes a wire whose edges are C1 from a Wire whose edges could be G1. It removes a vertex between G1 edges. Option can be G1 or C1.

        :param Wire:
        :type Wire: TopoDS_Wire &
        :param Option:
        :type Option: GeomAbs_Shape
        :param AngularTolerance: default value is 1.0e-4
        :type AngularTolerance: float
        :rtype: TopoDS_Wire

        """
        return _BRepAlgo.brepalgo_ConcatenateWire(*args)

    ConcatenateWire = staticmethod(ConcatenateWire)
    def ConcatenateWireC0(*args):
        """
        * this method makes an edge from a wire. Junction points between edges of wire may be sharp, resulting curve of the resulting edge may be C0.

        :param Wire:
        :type Wire: TopoDS_Wire &
        :rtype: TopoDS_Edge

        """
        return _BRepAlgo.brepalgo_ConcatenateWireC0(*args)

    ConcatenateWireC0 = staticmethod(ConcatenateWireC0)
    def IsValid(*args):
        """
        * Checks if the shape is 'correct'. If not, returns <Standard_False>, else returns <Standard_True>.

        :param S:
        :type S: TopoDS_Shape &
        :rtype: bool

        * Checks if the Generated and Modified Faces from the shapes <arguments> in the shape <result> are 'correct'. The args may be empty, then all faces will be checked. If <Closed> is True, only closed shape are valid. If <GeomCtrl> is False the geometry of new  vertices and edges are not verified and the auto-intersection of new wires are not searched.

        :param theArgs:
        :type theArgs: TopTools_ListOfShape &
        :param theResult:
        :type theResult: TopoDS_Shape &
        :param closedSolid: default value is Standard_False
        :type closedSolid: bool
        :param GeomCtrl: default value is Standard_True
        :type GeomCtrl: bool
        :rtype: bool

        """
        return _BRepAlgo.brepalgo_IsValid(*args)

    IsValid = staticmethod(IsValid)
    def IsTopologicallyValid(*args):
        """
        * Checks if the shape is 'correct'. If not, returns <Standard_False>, else returns <Standard_True>. This method differs from the previous one in the fact that no geometric contols (intersection of wires, pcurve validity) are performed.

        :param S:
        :type S: TopoDS_Shape &
        :rtype: bool

        """
        return _BRepAlgo.brepalgo_IsTopologicallyValid(*args)

    IsTopologicallyValid = staticmethod(IsTopologicallyValid)
    def __init__(self): 
        _BRepAlgo.brepalgo_swiginit(self,_BRepAlgo.new_brepalgo())
    __swig_destroy__ = _BRepAlgo.delete_brepalgo
brepalgo_swigregister = _BRepAlgo.brepalgo_swigregister
brepalgo_swigregister(brepalgo)

def brepalgo_ConcatenateWire(*args):
  """
    * this method makes a wire whose edges are C1 from a Wire whose edges could be G1. It removes a vertex between G1 edges. Option can be G1 or C1.

    :param Wire:
    :type Wire: TopoDS_Wire &
    :param Option:
    :type Option: GeomAbs_Shape
    :param AngularTolerance: default value is 1.0e-4
    :type AngularTolerance: float
    :rtype: TopoDS_Wire

    """
  return _BRepAlgo.brepalgo_ConcatenateWire(*args)

def brepalgo_ConcatenateWireC0(*args):
  """
    * this method makes an edge from a wire. Junction points between edges of wire may be sharp, resulting curve of the resulting edge may be C0.

    :param Wire:
    :type Wire: TopoDS_Wire &
    :rtype: TopoDS_Edge

    """
  return _BRepAlgo.brepalgo_ConcatenateWireC0(*args)

def brepalgo_IsValid(*args):
  """
    * Checks if the shape is 'correct'. If not, returns <Standard_False>, else returns <Standard_True>.

    :param S:
    :type S: TopoDS_Shape &
    :rtype: bool

    * Checks if the Generated and Modified Faces from the shapes <arguments> in the shape <result> are 'correct'. The args may be empty, then all faces will be checked. If <Closed> is True, only closed shape are valid. If <GeomCtrl> is False the geometry of new  vertices and edges are not verified and the auto-intersection of new wires are not searched.

    :param theArgs:
    :type theArgs: TopTools_ListOfShape &
    :param theResult:
    :type theResult: TopoDS_Shape &
    :param closedSolid: default value is Standard_False
    :type closedSolid: bool
    :param GeomCtrl: default value is Standard_True
    :type GeomCtrl: bool
    :rtype: bool

    """
  return _BRepAlgo.brepalgo_IsValid(*args)

def brepalgo_IsTopologicallyValid(*args):
  """
    * Checks if the shape is 'correct'. If not, returns <Standard_False>, else returns <Standard_True>. This method differs from the previous one in the fact that no geometric contols (intersection of wires, pcurve validity) are performed.

    :param S:
    :type S: TopoDS_Shape &
    :rtype: bool

    """
  return _BRepAlgo.brepalgo_IsTopologicallyValid(*args)

class BRepAlgo_AsDes(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Creates an empty AsDes.

        :rtype: None

        """
        _BRepAlgo.BRepAlgo_AsDes_swiginit(self,_BRepAlgo.new_BRepAlgo_AsDes(*args))
    def Clear(self, *args):
        """
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_AsDes_Clear(self, *args)

    def Add(self, *args):
        """
        * Stores <SS> as a futur subshape of <S>.

        :param S:
        :type S: TopoDS_Shape &
        :param SS:
        :type SS: TopoDS_Shape &
        :rtype: None

        * Stores <SS> as futurs SubShapes of <S>.

        :param S:
        :type S: TopoDS_Shape &
        :param SS:
        :type SS: TopTools_ListOfShape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_AsDes_Add(self, *args)

    def HasAscendant(self, *args):
        """
        :param S:
        :type S: TopoDS_Shape &
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_AsDes_HasAscendant(self, *args)

    def HasDescendant(self, *args):
        """
        :param S:
        :type S: TopoDS_Shape &
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_AsDes_HasDescendant(self, *args)

    def Ascendant(self, *args):
        """
        * Returns the Shape containing <S>.

        :param S:
        :type S: TopoDS_Shape &
        :rtype: TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_AsDes_Ascendant(self, *args)

    def Descendant(self, *args):
        """
        * Returns futur subhapes of <S>.

        :param S:
        :type S: TopoDS_Shape &
        :rtype: TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_AsDes_Descendant(self, *args)

    def ChangeDescendant(self, *args):
        """
        * Returns futur subhapes of <S>.

        :param S:
        :type S: TopoDS_Shape &
        :rtype: TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_AsDes_ChangeDescendant(self, *args)

    def Replace(self, *args):
        """
        * Replace <OldS> by <NewS>. <OldS> disapear from <self>.

        :param OldS:
        :type OldS: TopoDS_Shape &
        :param NewS:
        :type NewS: TopoDS_Shape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_AsDes_Replace(self, *args)

    def Remove(self, *args):
        """
        * Remove <S> from me.

        :param S:
        :type S: TopoDS_Shape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_AsDes_Remove(self, *args)

    def HasCommonDescendant(self, *args):
        """
        * Returns True if (S1> and <S2> has common Descendants. Stores in <LC> the Commons Descendants.

        :param S1:
        :type S1: TopoDS_Shape &
        :param S2:
        :type S2: TopoDS_Shape &
        :param LC:
        :type LC: TopTools_ListOfShape &
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_AsDes_HasCommonDescendant(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_BRepAlgo_AsDes(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_AsDes
BRepAlgo_AsDes.Clear = new_instancemethod(_BRepAlgo.BRepAlgo_AsDes_Clear,None,BRepAlgo_AsDes)
BRepAlgo_AsDes.Add = new_instancemethod(_BRepAlgo.BRepAlgo_AsDes_Add,None,BRepAlgo_AsDes)
BRepAlgo_AsDes.HasAscendant = new_instancemethod(_BRepAlgo.BRepAlgo_AsDes_HasAscendant,None,BRepAlgo_AsDes)
BRepAlgo_AsDes.HasDescendant = new_instancemethod(_BRepAlgo.BRepAlgo_AsDes_HasDescendant,None,BRepAlgo_AsDes)
BRepAlgo_AsDes.Ascendant = new_instancemethod(_BRepAlgo.BRepAlgo_AsDes_Ascendant,None,BRepAlgo_AsDes)
BRepAlgo_AsDes.Descendant = new_instancemethod(_BRepAlgo.BRepAlgo_AsDes_Descendant,None,BRepAlgo_AsDes)
BRepAlgo_AsDes.ChangeDescendant = new_instancemethod(_BRepAlgo.BRepAlgo_AsDes_ChangeDescendant,None,BRepAlgo_AsDes)
BRepAlgo_AsDes.Replace = new_instancemethod(_BRepAlgo.BRepAlgo_AsDes_Replace,None,BRepAlgo_AsDes)
BRepAlgo_AsDes.Remove = new_instancemethod(_BRepAlgo.BRepAlgo_AsDes_Remove,None,BRepAlgo_AsDes)
BRepAlgo_AsDes.HasCommonDescendant = new_instancemethod(_BRepAlgo.BRepAlgo_AsDes_HasCommonDescendant,None,BRepAlgo_AsDes)
BRepAlgo_AsDes_swigregister = _BRepAlgo.BRepAlgo_AsDes_swigregister
BRepAlgo_AsDes_swigregister(BRepAlgo_AsDes)

class Handle_BRepAlgo_AsDes(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _BRepAlgo.Handle_BRepAlgo_AsDes_swiginit(self,_BRepAlgo.new_Handle_BRepAlgo_AsDes(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_BRepAlgo.Handle_BRepAlgo_AsDes_DownCast)
    __swig_destroy__ = _BRepAlgo.delete_Handle_BRepAlgo_AsDes
Handle_BRepAlgo_AsDes.Nullify = new_instancemethod(_BRepAlgo.Handle_BRepAlgo_AsDes_Nullify,None,Handle_BRepAlgo_AsDes)
Handle_BRepAlgo_AsDes.IsNull = new_instancemethod(_BRepAlgo.Handle_BRepAlgo_AsDes_IsNull,None,Handle_BRepAlgo_AsDes)
Handle_BRepAlgo_AsDes.GetObject = new_instancemethod(_BRepAlgo.Handle_BRepAlgo_AsDes_GetObject,None,Handle_BRepAlgo_AsDes)
Handle_BRepAlgo_AsDes_swigregister = _BRepAlgo.Handle_BRepAlgo_AsDes_swigregister
Handle_BRepAlgo_AsDes_swigregister(Handle_BRepAlgo_AsDes)

def Handle_BRepAlgo_AsDes_DownCast(*args):
  return _BRepAlgo.Handle_BRepAlgo_AsDes_DownCast(*args)
Handle_BRepAlgo_AsDes_DownCast = _BRepAlgo.Handle_BRepAlgo_AsDes_DownCast

class BRepAlgo_BooleanOperation(OCC.BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def PerformDS(self, *args):
        """
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_BooleanOperation_PerformDS(self, *args)

    def Perform(self, *args):
        """
        :param St1:
        :type St1: TopAbs_State
        :param St2:
        :type St2: TopAbs_State
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_BooleanOperation_Perform(self, *args)

    def Builder(self, *args):
        """
        :rtype: Handle_TopOpeBRepBuild_HBuilder

        """
        return _BRepAlgo.BRepAlgo_BooleanOperation_Builder(self, *args)

    def Shape1(self, *args):
        """
        * Returns the first shape involved in this Boolean operation.

        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_BooleanOperation_Shape1(self, *args)

    def Shape2(self, *args):
        """
        * Returns the second shape involved in this Boolean operation.

        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_BooleanOperation_Shape2(self, *args)

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_BooleanOperation
BRepAlgo_BooleanOperation.PerformDS = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperation_PerformDS,None,BRepAlgo_BooleanOperation)
BRepAlgo_BooleanOperation.Perform = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperation_Perform,None,BRepAlgo_BooleanOperation)
BRepAlgo_BooleanOperation.Builder = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperation_Builder,None,BRepAlgo_BooleanOperation)
BRepAlgo_BooleanOperation.Shape1 = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperation_Shape1,None,BRepAlgo_BooleanOperation)
BRepAlgo_BooleanOperation.Shape2 = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperation_Shape2,None,BRepAlgo_BooleanOperation)
BRepAlgo_BooleanOperation_swigregister = _BRepAlgo.BRepAlgo_BooleanOperation_swigregister
BRepAlgo_BooleanOperation_swigregister(BRepAlgo_BooleanOperation)

class BRepAlgo_BooleanOperations(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        """
        _BRepAlgo.BRepAlgo_BooleanOperations_swiginit(self,_BRepAlgo.new_BRepAlgo_BooleanOperations(*args))
    def Shapes2d(self, *args):
        """
        * S1 is a Shell with ALL faces supported by the SAME S2 is an Edge INCLUDED in that surface with pcurve. this avoids a time-consuming 3D operation, compared to Shapes.

        :param S1:
        :type S1: TopoDS_Shape &
        :param S2:
        :type S2: TopoDS_Shape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_Shapes2d(self, *args)

    def Shapes(self, *args):
        """
        * Defines the arguments.

        :param S1:
        :type S1: TopoDS_Shape &
        :param S2:
        :type S2: TopoDS_Shape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_Shapes(self, *args)

    def SetApproxParameters(self, *args):
        """
        * Sets different parameters for the curve approximations : NbPntMax : Maximum number of points to be approximated at  the same time in one curve. Tol3D, Tol2D : Tolerances to be reached by the approximation. RelativeTol : The given tolerances are relative.

        :param NbPntMax:
        :type NbPntMax: int
        :param Tol3D:
        :type Tol3D: float
        :param Tol2D:
        :type Tol2D: float
        :param RelativeTol:
        :type RelativeTol: bool
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_SetApproxParameters(self, *args)

    def Define(self, *args):
        """
        :param S1:
        :type S1: TopoDS_Shape &
        :param S2:
        :type S2: TopoDS_Shape &
        :param HDS:
        :type HDS: Handle_TopOpeBRepDS_HDataStructure &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_Define(self, *args)

    def Common(self, *args):
        """
        * returns the common part of the shapes.

        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_Common(self, *args)

    def Fus(self, *args):
        """
        * returns the fuse part of the shapes.

        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_Fus(self, *args)

    def Cut(self, *args):
        """
        * returns the cut part of the shapes.

        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_Cut(self, *args)

    def Section(self, *args):
        """
        * returns the intersection of the shapes.

        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_Section(self, *args)

    def Shape(self, *args):
        """
        * returns the result of the boolean operation.

        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_Shape(self, *args)

    def ShapeFrom(self, *args):
        """
        * Returns the shape(s) resulting of the boolean operation issued from the shape <S>.

        :param S:
        :type S: TopoDS_Shape &
        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_ShapeFrom(self, *args)

    def Modified(self, *args):
        """
        * Returns the list of the descendant shapes of the shape <S>.

        :param S:
        :type S: TopoDS_Shape &
        :rtype: TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_Modified(self, *args)

    def IsDeleted(self, *args):
        """
        * Returns the fact that the shape <S> has been deleted or not by the boolean operation.

        :param S:
        :type S: TopoDS_Shape &
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_IsDeleted(self, *args)

    def DataStructure(self, *args):
        """
        :rtype: Handle_TopOpeBRepDS_HDataStructure

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_DataStructure(self, *args)

    def ChangeDataStructure(self, *args):
        """
        :rtype: Handle_TopOpeBRepDS_HDataStructure

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_ChangeDataStructure(self, *args)

    def Builder(self, *args):
        """
        :rtype: Handle_TopOpeBRepBuild_HBuilder

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_Builder(self, *args)

    def ChangeBuilder(self, *args):
        """
        :rtype: Handle_TopOpeBRepBuild_HBuilder

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_ChangeBuilder(self, *args)

    def DataStructureAccess(self, *args):
        """
        * returns the member myDSA. It is useful to then access the method GetSectionEdgeSet (wich is a member of DSAccess)

        :rtype: BRepAlgo_DSAccess

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_DataStructureAccess(self, *args)

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_BooleanOperations
BRepAlgo_BooleanOperations.Shapes2d = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperations_Shapes2d,None,BRepAlgo_BooleanOperations)
BRepAlgo_BooleanOperations.Shapes = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperations_Shapes,None,BRepAlgo_BooleanOperations)
BRepAlgo_BooleanOperations.SetApproxParameters = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperations_SetApproxParameters,None,BRepAlgo_BooleanOperations)
BRepAlgo_BooleanOperations.Define = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperations_Define,None,BRepAlgo_BooleanOperations)
BRepAlgo_BooleanOperations.Common = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperations_Common,None,BRepAlgo_BooleanOperations)
BRepAlgo_BooleanOperations.Fus = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperations_Fus,None,BRepAlgo_BooleanOperations)
BRepAlgo_BooleanOperations.Cut = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperations_Cut,None,BRepAlgo_BooleanOperations)
BRepAlgo_BooleanOperations.Section = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperations_Section,None,BRepAlgo_BooleanOperations)
BRepAlgo_BooleanOperations.Shape = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperations_Shape,None,BRepAlgo_BooleanOperations)
BRepAlgo_BooleanOperations.ShapeFrom = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperations_ShapeFrom,None,BRepAlgo_BooleanOperations)
BRepAlgo_BooleanOperations.Modified = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperations_Modified,None,BRepAlgo_BooleanOperations)
BRepAlgo_BooleanOperations.IsDeleted = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperations_IsDeleted,None,BRepAlgo_BooleanOperations)
BRepAlgo_BooleanOperations.DataStructure = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperations_DataStructure,None,BRepAlgo_BooleanOperations)
BRepAlgo_BooleanOperations.ChangeDataStructure = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperations_ChangeDataStructure,None,BRepAlgo_BooleanOperations)
BRepAlgo_BooleanOperations.Builder = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperations_Builder,None,BRepAlgo_BooleanOperations)
BRepAlgo_BooleanOperations.ChangeBuilder = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperations_ChangeBuilder,None,BRepAlgo_BooleanOperations)
BRepAlgo_BooleanOperations.DataStructureAccess = new_instancemethod(_BRepAlgo.BRepAlgo_BooleanOperations_DataStructureAccess,None,BRepAlgo_BooleanOperations)
BRepAlgo_BooleanOperations_swigregister = _BRepAlgo.BRepAlgo_BooleanOperations_swigregister
BRepAlgo_BooleanOperations_swigregister(BRepAlgo_BooleanOperations)

class BRepAlgo_DSAccess(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        """
        _BRepAlgo.BRepAlgo_DSAccess_swiginit(self,_BRepAlgo.new_BRepAlgo_DSAccess(*args))
    def Init(self, *args):
        """
        * Clears the internal data structure, including the

        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_DSAccess_Init(self, *args)

    def Load(self, *args):
        """
        * Loads the shape in DS.

        :param S:
        :type S: TopoDS_Shape &
        :rtype: None

        * Loads two shapes in the DS without intersecting them.

        :param S1:
        :type S1: TopoDS_Shape &
        :param S2:
        :type S2: TopoDS_Shape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_DSAccess_Load(self, *args)

    def Intersect(self, *args):
        """
        * Intersects two shapes at input and loads the DS with their intersection. Clears the TopOpeBRepBuild_HBuilder if necessary

        :rtype: None

        * Intersects the faces contained in two given shapes and loads them in the DS. Clears the TopOpeBRepBuild_HBuilder if necessary

        :param S1:
        :type S1: TopoDS_Shape &
        :param S2:
        :type S2: TopoDS_Shape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_DSAccess_Intersect(self, *args)

    def SameDomain(self, *args):
        """
        * This method does the same thing as the previous, but faster. There is no intersection face/face 3D. The faces have the same support(surface). No test of tangency (that is why it is faster). Intersects in 2d the faces tangent F1 anf F2.

        :param S1:
        :type S1: TopoDS_Shape &
        :param S2:
        :type S2: TopoDS_Shape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_DSAccess_SameDomain(self, *args)

    def GetSectionEdgeSet(self, *args):
        """
        * returns compounds of Edge connected with section, which contains sections between faces contained in S1 and S2. returns an empty list of Shape if S1 or S2 do not contain face. calls GetSectionEdgeSet() if it has not already been done

        :param S1:
        :type S1: TopoDS_Shape &
        :param S2:
        :type S2: TopoDS_Shape &
        :rtype: TopTools_ListOfShape

        * returns all compounds of edges connected with section contained in the DS

        :rtype: TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_DSAccess_GetSectionEdgeSet(self, *args)

    def IsWire(self, *args):
        """
        * NYI

        :param Compound:
        :type Compound: TopoDS_Shape &
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_DSAccess_IsWire(self, *args)

    def Wire(self, *args):
        """
        * NYI

        :param Compound:
        :type Compound: TopoDS_Shape &
        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_DSAccess_Wire(self, *args)

    def SectionVertex(self, *args):
        """
        * NYI returns the vertex of section, which contains the section between face S1 and edge S2 (returns an empty Shape if S1 is not a face or if S2 is not an edge)

        :param S1:
        :type S1: TopoDS_Shape &
        :param S2:
        :type S2: TopoDS_Shape &
        :rtype: TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_DSAccess_SectionVertex(self, *args)

    def SuppressEdgeSet(self, *args):
        """
        * Invalidates a complete line of section. All Edges connected by Vertex or a Wire. Can be a group of connected Edges, which do not form a standard Wire.

        :param Compound:
        :type Compound: TopoDS_Shape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_DSAccess_SuppressEdgeSet(self, *args)

    def ChangeEdgeSet(self, *args):
        """
        * Modifies a line of section. <New> -- should be a Group of Edges connected by Vertex. -- Can be a Wire. Can be a group of connected Edges that do not form a standard Wire. <New> should be sub-groupn of <Old>

        :param Old:
        :type Old: TopoDS_Shape &
        :param New:
        :type New: TopoDS_Shape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_DSAccess_ChangeEdgeSet(self, *args)

    def SuppressSectionVertex(self, *args):
        """
        * NYI Make invalid a Vertex of section. The Vertex shoud be reconstructed from a point.

        :param V:
        :type V: TopoDS_Vertex &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_DSAccess_SuppressSectionVertex(self, *args)

    def Merge(self, *args):
        """
        :param state1:
        :type state1: TopAbs_State
        :param state2:
        :type state2: TopAbs_State
        :rtype: TopoDS_Shape

        :param state1:
        :type state1: TopAbs_State
        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_DSAccess_Merge(self, *args)

    def Propagate(self, *args):
        """
        * NYI Propagation of a state starting from the shape FromShape = edge or vertex of section, face or Coumpound de section. LoadShape is either S1, or S2 (see the method Load). Propagation from FromShape, on the states <what> of LoadShape. Return a Wire in 2d, a Shell in 3d. Specifications are incomplete, to be redefined for the typologies correpsonding to <FromShape> and the result : exemple : FromShape resultat  vertex  wire (or edge)  edge of section face (or shell)  compound of section shell ... ...

        :param what:
        :type what: TopAbs_State
        :param FromShape:
        :type FromShape: TopoDS_Shape &
        :param LoadShape:
        :type LoadShape: TopoDS_Shape &
        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_DSAccess_Propagate(self, *args)

    def PropagateFromSection(self, *args):
        """
        * SectionShape est soit un Vertex de section(NYI), soit une Edge de section. Propagation des shapes de section en partant de SectionShape. return un Compound de section.

        :param SectionShape:
        :type SectionShape: TopoDS_Shape &
        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_DSAccess_PropagateFromSection(self, *args)

    def Modified(self, *args):
        """
        * Returns the list of the descendant shapes of the shape <S>.

        :param S:
        :type S: TopoDS_Shape &
        :rtype: TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_DSAccess_Modified(self, *args)

    def Check(self, *args):
        """
        * NYI coherence of the internal Data Structure.

        :rtype: BRepAlgo_CheckStatus

        """
        return _BRepAlgo.BRepAlgo_DSAccess_Check(self, *args)

    def DS(self, *args):
        """
        :rtype: Handle_TopOpeBRepDS_HDataStructure

        """
        return _BRepAlgo.BRepAlgo_DSAccess_DS(self, *args)

    def ChangeDS(self, *args):
        """
        :rtype: Handle_TopOpeBRepDS_HDataStructure

        """
        return _BRepAlgo.BRepAlgo_DSAccess_ChangeDS(self, *args)

    def Builder(self, *args):
        """
        :rtype: Handle_TopOpeBRepBuild_HBuilder

        """
        return _BRepAlgo.BRepAlgo_DSAccess_Builder(self, *args)

    def ChangeBuilder(self, *args):
        """
        :rtype: Handle_TopOpeBRepBuild_HBuilder

        """
        return _BRepAlgo.BRepAlgo_DSAccess_ChangeBuilder(self, *args)

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_DSAccess
BRepAlgo_DSAccess.Init = new_instancemethod(_BRepAlgo.BRepAlgo_DSAccess_Init,None,BRepAlgo_DSAccess)
BRepAlgo_DSAccess.Load = new_instancemethod(_BRepAlgo.BRepAlgo_DSAccess_Load,None,BRepAlgo_DSAccess)
BRepAlgo_DSAccess.Intersect = new_instancemethod(_BRepAlgo.BRepAlgo_DSAccess_Intersect,None,BRepAlgo_DSAccess)
BRepAlgo_DSAccess.SameDomain = new_instancemethod(_BRepAlgo.BRepAlgo_DSAccess_SameDomain,None,BRepAlgo_DSAccess)
BRepAlgo_DSAccess.GetSectionEdgeSet = new_instancemethod(_BRepAlgo.BRepAlgo_DSAccess_GetSectionEdgeSet,None,BRepAlgo_DSAccess)
BRepAlgo_DSAccess.IsWire = new_instancemethod(_BRepAlgo.BRepAlgo_DSAccess_IsWire,None,BRepAlgo_DSAccess)
BRepAlgo_DSAccess.Wire = new_instancemethod(_BRepAlgo.BRepAlgo_DSAccess_Wire,None,BRepAlgo_DSAccess)
BRepAlgo_DSAccess.SectionVertex = new_instancemethod(_BRepAlgo.BRepAlgo_DSAccess_SectionVertex,None,BRepAlgo_DSAccess)
BRepAlgo_DSAccess.SuppressEdgeSet = new_instancemethod(_BRepAlgo.BRepAlgo_DSAccess_SuppressEdgeSet,None,BRepAlgo_DSAccess)
BRepAlgo_DSAccess.ChangeEdgeSet = new_instancemethod(_BRepAlgo.BRepAlgo_DSAccess_ChangeEdgeSet,None,BRepAlgo_DSAccess)
BRepAlgo_DSAccess.SuppressSectionVertex = new_instancemethod(_BRepAlgo.BRepAlgo_DSAccess_SuppressSectionVertex,None,BRepAlgo_DSAccess)
BRepAlgo_DSAccess.Merge = new_instancemethod(_BRepAlgo.BRepAlgo_DSAccess_Merge,None,BRepAlgo_DSAccess)
BRepAlgo_DSAccess.Propagate = new_instancemethod(_BRepAlgo.BRepAlgo_DSAccess_Propagate,None,BRepAlgo_DSAccess)
BRepAlgo_DSAccess.PropagateFromSection = new_instancemethod(_BRepAlgo.BRepAlgo_DSAccess_PropagateFromSection,None,BRepAlgo_DSAccess)
BRepAlgo_DSAccess.Modified = new_instancemethod(_BRepAlgo.BRepAlgo_DSAccess_Modified,None,BRepAlgo_DSAccess)
BRepAlgo_DSAccess.Check = new_instancemethod(_BRepAlgo.BRepAlgo_DSAccess_Check,None,BRepAlgo_DSAccess)
BRepAlgo_DSAccess.DS = new_instancemethod(_BRepAlgo.BRepAlgo_DSAccess_DS,None,BRepAlgo_DSAccess)
BRepAlgo_DSAccess.ChangeDS = new_instancemethod(_BRepAlgo.BRepAlgo_DSAccess_ChangeDS,None,BRepAlgo_DSAccess)
BRepAlgo_DSAccess.Builder = new_instancemethod(_BRepAlgo.BRepAlgo_DSAccess_Builder,None,BRepAlgo_DSAccess)
BRepAlgo_DSAccess.ChangeBuilder = new_instancemethod(_BRepAlgo.BRepAlgo_DSAccess_ChangeBuilder,None,BRepAlgo_DSAccess)
BRepAlgo_DSAccess_swigregister = _BRepAlgo.BRepAlgo_DSAccess_swigregister
BRepAlgo_DSAccess_swigregister(BRepAlgo_DSAccess)

class BRepAlgo_DataMapIteratorOfDataMapOfShapeBoolean(OCC.TCollection.TCollection_BasicMapIterator):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        :param aMap:
        :type aMap: BRepAlgo_DataMapOfShapeBoolean &
        :rtype: None

        """
        _BRepAlgo.BRepAlgo_DataMapIteratorOfDataMapOfShapeBoolean_swiginit(self,_BRepAlgo.new_BRepAlgo_DataMapIteratorOfDataMapOfShapeBoolean(*args))
    def Initialize(self, *args):
        """
        :param aMap:
        :type aMap: BRepAlgo_DataMapOfShapeBoolean &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_DataMapIteratorOfDataMapOfShapeBoolean_Initialize(self, *args)

    def Key(self, *args):
        """
        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_DataMapIteratorOfDataMapOfShapeBoolean_Key(self, *args)

    def Value(self, *args):
        """
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_DataMapIteratorOfDataMapOfShapeBoolean_Value(self, *args)

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_DataMapIteratorOfDataMapOfShapeBoolean
BRepAlgo_DataMapIteratorOfDataMapOfShapeBoolean.Initialize = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapIteratorOfDataMapOfShapeBoolean_Initialize,None,BRepAlgo_DataMapIteratorOfDataMapOfShapeBoolean)
BRepAlgo_DataMapIteratorOfDataMapOfShapeBoolean.Key = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapIteratorOfDataMapOfShapeBoolean_Key,None,BRepAlgo_DataMapIteratorOfDataMapOfShapeBoolean)
BRepAlgo_DataMapIteratorOfDataMapOfShapeBoolean.Value = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapIteratorOfDataMapOfShapeBoolean_Value,None,BRepAlgo_DataMapIteratorOfDataMapOfShapeBoolean)
BRepAlgo_DataMapIteratorOfDataMapOfShapeBoolean_swigregister = _BRepAlgo.BRepAlgo_DataMapIteratorOfDataMapOfShapeBoolean_swigregister
BRepAlgo_DataMapIteratorOfDataMapOfShapeBoolean_swigregister(BRepAlgo_DataMapIteratorOfDataMapOfShapeBoolean)

class BRepAlgo_DataMapIteratorOfDataMapOfShapeInterference(OCC.TCollection.TCollection_BasicMapIterator):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        :param aMap:
        :type aMap: BRepAlgo_DataMapOfShapeInterference &
        :rtype: None

        """
        _BRepAlgo.BRepAlgo_DataMapIteratorOfDataMapOfShapeInterference_swiginit(self,_BRepAlgo.new_BRepAlgo_DataMapIteratorOfDataMapOfShapeInterference(*args))
    def Initialize(self, *args):
        """
        :param aMap:
        :type aMap: BRepAlgo_DataMapOfShapeInterference &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_DataMapIteratorOfDataMapOfShapeInterference_Initialize(self, *args)

    def Key(self, *args):
        """
        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_DataMapIteratorOfDataMapOfShapeInterference_Key(self, *args)

    def Value(self, *args):
        """
        :rtype: Handle_TopOpeBRepDS_Interference

        """
        return _BRepAlgo.BRepAlgo_DataMapIteratorOfDataMapOfShapeInterference_Value(self, *args)

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_DataMapIteratorOfDataMapOfShapeInterference
BRepAlgo_DataMapIteratorOfDataMapOfShapeInterference.Initialize = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapIteratorOfDataMapOfShapeInterference_Initialize,None,BRepAlgo_DataMapIteratorOfDataMapOfShapeInterference)
BRepAlgo_DataMapIteratorOfDataMapOfShapeInterference.Key = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapIteratorOfDataMapOfShapeInterference_Key,None,BRepAlgo_DataMapIteratorOfDataMapOfShapeInterference)
BRepAlgo_DataMapIteratorOfDataMapOfShapeInterference.Value = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapIteratorOfDataMapOfShapeInterference_Value,None,BRepAlgo_DataMapIteratorOfDataMapOfShapeInterference)
BRepAlgo_DataMapIteratorOfDataMapOfShapeInterference_swigregister = _BRepAlgo.BRepAlgo_DataMapIteratorOfDataMapOfShapeInterference_swigregister
BRepAlgo_DataMapIteratorOfDataMapOfShapeInterference_swigregister(BRepAlgo_DataMapIteratorOfDataMapOfShapeInterference)

class BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean(OCC.TCollection.TCollection_MapNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param K:
        :type K: TopoDS_Shape &
        :param I:
        :type I: bool
        :param n:
        :type n: TCollection_MapNodePtr &
        :rtype: None

        """
        _BRepAlgo.BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_swiginit(self,_BRepAlgo.new_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean(*args))
    def Key(self, *args):
        """
        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_Key(self, *args)

    def GetValue(self):
        """GetValue(BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean self) -> Standard_Boolean"""
        return _BRepAlgo.BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_GetValue(self)

    def SetValue(self, *args):
        """SetValue(BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean self, Standard_Boolean value)"""
        return _BRepAlgo.BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_SetValue(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean
BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean.Key = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_Key,None,BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean)
BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean.GetValue = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_GetValue,None,BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean)
BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean.SetValue = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_SetValue,None,BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean)
BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_swigregister = _BRepAlgo.BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_swigregister
BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_swigregister(BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean)

class Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean(OCC.TCollection.Handle_TCollection_MapNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _BRepAlgo.Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_swiginit(self,_BRepAlgo.new_Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_BRepAlgo.Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_DownCast)
    __swig_destroy__ = _BRepAlgo.delete_Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean
Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean.Nullify = new_instancemethod(_BRepAlgo.Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_Nullify,None,Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean)
Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean.IsNull = new_instancemethod(_BRepAlgo.Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_IsNull,None,Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean)
Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean.GetObject = new_instancemethod(_BRepAlgo.Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_GetObject,None,Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean)
Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_swigregister = _BRepAlgo.Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_swigregister
Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_swigregister(Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean)

def Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_DownCast(*args):
  return _BRepAlgo.Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_DownCast(*args)
Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_DownCast = _BRepAlgo.Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeBoolean_DownCast

class BRepAlgo_DataMapNodeOfDataMapOfShapeInterference(OCC.TCollection.TCollection_MapNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param K:
        :type K: TopoDS_Shape &
        :param I:
        :type I: Handle_TopOpeBRepDS_Interference &
        :param n:
        :type n: TCollection_MapNodePtr &
        :rtype: None

        """
        _BRepAlgo.BRepAlgo_DataMapNodeOfDataMapOfShapeInterference_swiginit(self,_BRepAlgo.new_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference(*args))
    def Key(self, *args):
        """
        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_DataMapNodeOfDataMapOfShapeInterference_Key(self, *args)

    def Value(self, *args):
        """
        :rtype: Handle_TopOpeBRepDS_Interference

        """
        return _BRepAlgo.BRepAlgo_DataMapNodeOfDataMapOfShapeInterference_Value(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference
BRepAlgo_DataMapNodeOfDataMapOfShapeInterference.Key = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapNodeOfDataMapOfShapeInterference_Key,None,BRepAlgo_DataMapNodeOfDataMapOfShapeInterference)
BRepAlgo_DataMapNodeOfDataMapOfShapeInterference.Value = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapNodeOfDataMapOfShapeInterference_Value,None,BRepAlgo_DataMapNodeOfDataMapOfShapeInterference)
BRepAlgo_DataMapNodeOfDataMapOfShapeInterference_swigregister = _BRepAlgo.BRepAlgo_DataMapNodeOfDataMapOfShapeInterference_swigregister
BRepAlgo_DataMapNodeOfDataMapOfShapeInterference_swigregister(BRepAlgo_DataMapNodeOfDataMapOfShapeInterference)

class Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference(OCC.TCollection.Handle_TCollection_MapNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _BRepAlgo.Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference_swiginit(self,_BRepAlgo.new_Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_BRepAlgo.Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference_DownCast)
    __swig_destroy__ = _BRepAlgo.delete_Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference
Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference.Nullify = new_instancemethod(_BRepAlgo.Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference_Nullify,None,Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference)
Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference.IsNull = new_instancemethod(_BRepAlgo.Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference_IsNull,None,Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference)
Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference.GetObject = new_instancemethod(_BRepAlgo.Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference_GetObject,None,Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference)
Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference_swigregister = _BRepAlgo.Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference_swigregister
Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference_swigregister(Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference)

def Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference_DownCast(*args):
  return _BRepAlgo.Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference_DownCast(*args)
Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference_DownCast = _BRepAlgo.Handle_BRepAlgo_DataMapNodeOfDataMapOfShapeInterference_DownCast

class BRepAlgo_DataMapOfShapeBoolean(OCC.TCollection.TCollection_BasicMap):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param NbBuckets: default value is 1
        :type NbBuckets: int
        :rtype: None

        """
        _BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_swiginit(self,_BRepAlgo.new_BRepAlgo_DataMapOfShapeBoolean(*args))
    def Assign(self, *args):
        """
        :param Other:
        :type Other: BRepAlgo_DataMapOfShapeBoolean &
        :rtype: BRepAlgo_DataMapOfShapeBoolean

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_Assign(self, *args)

    def Set(self, *args):
        """
        :param Other:
        :type Other: BRepAlgo_DataMapOfShapeBoolean &
        :rtype: BRepAlgo_DataMapOfShapeBoolean

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_Set(self, *args)

    def ReSize(self, *args):
        """
        :param NbBuckets:
        :type NbBuckets: int
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_ReSize(self, *args)

    def Clear(self, *args):
        """
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_Clear(self, *args)

    def Bind(self, *args):
        """
        :param K:
        :type K: TopoDS_Shape &
        :param I:
        :type I: bool
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_Bind(self, *args)

    def IsBound(self, *args):
        """
        :param K:
        :type K: TopoDS_Shape &
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_IsBound(self, *args)

    def UnBind(self, *args):
        """
        :param K:
        :type K: TopoDS_Shape &
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_UnBind(self, *args)

    def Find(self, *args):
        """
        :param K:
        :type K: TopoDS_Shape &
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_Find(self, *args)

    def ChangeFind(self, *args):
        """
        :param K:
        :type K: TopoDS_Shape &
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_ChangeFind(self, *args)

    def Find1(self, *args):
        """
        :param K:
        :type K: TopoDS_Shape &
        :rtype: Standard_Address

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_Find1(self, *args)

    def ChangeFind1(self, *args):
        """
        :param K:
        :type K: TopoDS_Shape &
        :rtype: Standard_Address

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_ChangeFind1(self, *args)

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_DataMapOfShapeBoolean
BRepAlgo_DataMapOfShapeBoolean.Assign = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_Assign,None,BRepAlgo_DataMapOfShapeBoolean)
BRepAlgo_DataMapOfShapeBoolean.Set = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_Set,None,BRepAlgo_DataMapOfShapeBoolean)
BRepAlgo_DataMapOfShapeBoolean.ReSize = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_ReSize,None,BRepAlgo_DataMapOfShapeBoolean)
BRepAlgo_DataMapOfShapeBoolean.Clear = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_Clear,None,BRepAlgo_DataMapOfShapeBoolean)
BRepAlgo_DataMapOfShapeBoolean.Bind = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_Bind,None,BRepAlgo_DataMapOfShapeBoolean)
BRepAlgo_DataMapOfShapeBoolean.IsBound = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_IsBound,None,BRepAlgo_DataMapOfShapeBoolean)
BRepAlgo_DataMapOfShapeBoolean.UnBind = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_UnBind,None,BRepAlgo_DataMapOfShapeBoolean)
BRepAlgo_DataMapOfShapeBoolean.Find = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_Find,None,BRepAlgo_DataMapOfShapeBoolean)
BRepAlgo_DataMapOfShapeBoolean.ChangeFind = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_ChangeFind,None,BRepAlgo_DataMapOfShapeBoolean)
BRepAlgo_DataMapOfShapeBoolean.Find1 = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_Find1,None,BRepAlgo_DataMapOfShapeBoolean)
BRepAlgo_DataMapOfShapeBoolean.ChangeFind1 = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_ChangeFind1,None,BRepAlgo_DataMapOfShapeBoolean)
BRepAlgo_DataMapOfShapeBoolean_swigregister = _BRepAlgo.BRepAlgo_DataMapOfShapeBoolean_swigregister
BRepAlgo_DataMapOfShapeBoolean_swigregister(BRepAlgo_DataMapOfShapeBoolean)

class BRepAlgo_DataMapOfShapeInterference(OCC.TCollection.TCollection_BasicMap):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param NbBuckets: default value is 1
        :type NbBuckets: int
        :rtype: None

        """
        _BRepAlgo.BRepAlgo_DataMapOfShapeInterference_swiginit(self,_BRepAlgo.new_BRepAlgo_DataMapOfShapeInterference(*args))
    def Assign(self, *args):
        """
        :param Other:
        :type Other: BRepAlgo_DataMapOfShapeInterference &
        :rtype: BRepAlgo_DataMapOfShapeInterference

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeInterference_Assign(self, *args)

    def Set(self, *args):
        """
        :param Other:
        :type Other: BRepAlgo_DataMapOfShapeInterference &
        :rtype: BRepAlgo_DataMapOfShapeInterference

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeInterference_Set(self, *args)

    def ReSize(self, *args):
        """
        :param NbBuckets:
        :type NbBuckets: int
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeInterference_ReSize(self, *args)

    def Clear(self, *args):
        """
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeInterference_Clear(self, *args)

    def Bind(self, *args):
        """
        :param K:
        :type K: TopoDS_Shape &
        :param I:
        :type I: Handle_TopOpeBRepDS_Interference &
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeInterference_Bind(self, *args)

    def IsBound(self, *args):
        """
        :param K:
        :type K: TopoDS_Shape &
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeInterference_IsBound(self, *args)

    def UnBind(self, *args):
        """
        :param K:
        :type K: TopoDS_Shape &
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeInterference_UnBind(self, *args)

    def Find(self, *args):
        """
        :param K:
        :type K: TopoDS_Shape &
        :rtype: Handle_TopOpeBRepDS_Interference

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeInterference_Find(self, *args)

    def ChangeFind(self, *args):
        """
        :param K:
        :type K: TopoDS_Shape &
        :rtype: Handle_TopOpeBRepDS_Interference

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeInterference_ChangeFind(self, *args)

    def Find1(self, *args):
        """
        :param K:
        :type K: TopoDS_Shape &
        :rtype: Standard_Address

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeInterference_Find1(self, *args)

    def ChangeFind1(self, *args):
        """
        :param K:
        :type K: TopoDS_Shape &
        :rtype: Standard_Address

        """
        return _BRepAlgo.BRepAlgo_DataMapOfShapeInterference_ChangeFind1(self, *args)

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_DataMapOfShapeInterference
BRepAlgo_DataMapOfShapeInterference.Assign = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeInterference_Assign,None,BRepAlgo_DataMapOfShapeInterference)
BRepAlgo_DataMapOfShapeInterference.Set = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeInterference_Set,None,BRepAlgo_DataMapOfShapeInterference)
BRepAlgo_DataMapOfShapeInterference.ReSize = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeInterference_ReSize,None,BRepAlgo_DataMapOfShapeInterference)
BRepAlgo_DataMapOfShapeInterference.Clear = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeInterference_Clear,None,BRepAlgo_DataMapOfShapeInterference)
BRepAlgo_DataMapOfShapeInterference.Bind = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeInterference_Bind,None,BRepAlgo_DataMapOfShapeInterference)
BRepAlgo_DataMapOfShapeInterference.IsBound = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeInterference_IsBound,None,BRepAlgo_DataMapOfShapeInterference)
BRepAlgo_DataMapOfShapeInterference.UnBind = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeInterference_UnBind,None,BRepAlgo_DataMapOfShapeInterference)
BRepAlgo_DataMapOfShapeInterference.Find = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeInterference_Find,None,BRepAlgo_DataMapOfShapeInterference)
BRepAlgo_DataMapOfShapeInterference.ChangeFind = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeInterference_ChangeFind,None,BRepAlgo_DataMapOfShapeInterference)
BRepAlgo_DataMapOfShapeInterference.Find1 = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeInterference_Find1,None,BRepAlgo_DataMapOfShapeInterference)
BRepAlgo_DataMapOfShapeInterference.ChangeFind1 = new_instancemethod(_BRepAlgo.BRepAlgo_DataMapOfShapeInterference_ChangeFind1,None,BRepAlgo_DataMapOfShapeInterference)
BRepAlgo_DataMapOfShapeInterference_swigregister = _BRepAlgo.BRepAlgo_DataMapOfShapeInterference_swigregister
BRepAlgo_DataMapOfShapeInterference_swigregister(BRepAlgo_DataMapOfShapeInterference)

class BRepAlgo_EdgeConnector(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        """
        _BRepAlgo.BRepAlgo_EdgeConnector_swiginit(self,_BRepAlgo.new_BRepAlgo_EdgeConnector(*args))
    def Add(self, *args):
        """
        :param e:
        :type e: TopoDS_Edge &
        :rtype: None

        :param LOEdge:
        :type LOEdge: TopTools_ListOfShape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_EdgeConnector_Add(self, *args)

    def AddStart(self, *args):
        """
        :param e:
        :type e: TopoDS_Shape &
        :rtype: None

        :param LOEdge:
        :type LOEdge: TopTools_ListOfShape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_EdgeConnector_AddStart(self, *args)

    def ClearStartElement(self, *args):
        """
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_EdgeConnector_ClearStartElement(self, *args)

    def MakeBlock(self, *args):
        """
        * returns a list of wire non standard

        :rtype: TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_EdgeConnector_MakeBlock(self, *args)

    def Done(self, *args):
        """
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_EdgeConnector_Done(self, *args)

    def IsDone(self, *args):
        """
        * NYI returns true if proceeded to MakeBlock()

        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_EdgeConnector_IsDone(self, *args)

    def IsWire(self, *args):
        """
        * NYI returns true if W is a Wire standard. W must belong to the list returned by MakeBlock.

        :param W:
        :type W: TopoDS_Shape &
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_EdgeConnector_IsWire(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_BRepAlgo_EdgeConnector(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_EdgeConnector
BRepAlgo_EdgeConnector.Add = new_instancemethod(_BRepAlgo.BRepAlgo_EdgeConnector_Add,None,BRepAlgo_EdgeConnector)
BRepAlgo_EdgeConnector.AddStart = new_instancemethod(_BRepAlgo.BRepAlgo_EdgeConnector_AddStart,None,BRepAlgo_EdgeConnector)
BRepAlgo_EdgeConnector.ClearStartElement = new_instancemethod(_BRepAlgo.BRepAlgo_EdgeConnector_ClearStartElement,None,BRepAlgo_EdgeConnector)
BRepAlgo_EdgeConnector.MakeBlock = new_instancemethod(_BRepAlgo.BRepAlgo_EdgeConnector_MakeBlock,None,BRepAlgo_EdgeConnector)
BRepAlgo_EdgeConnector.Done = new_instancemethod(_BRepAlgo.BRepAlgo_EdgeConnector_Done,None,BRepAlgo_EdgeConnector)
BRepAlgo_EdgeConnector.IsDone = new_instancemethod(_BRepAlgo.BRepAlgo_EdgeConnector_IsDone,None,BRepAlgo_EdgeConnector)
BRepAlgo_EdgeConnector.IsWire = new_instancemethod(_BRepAlgo.BRepAlgo_EdgeConnector_IsWire,None,BRepAlgo_EdgeConnector)
BRepAlgo_EdgeConnector_swigregister = _BRepAlgo.BRepAlgo_EdgeConnector_swigregister
BRepAlgo_EdgeConnector_swigregister(BRepAlgo_EdgeConnector)

class Handle_BRepAlgo_EdgeConnector(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _BRepAlgo.Handle_BRepAlgo_EdgeConnector_swiginit(self,_BRepAlgo.new_Handle_BRepAlgo_EdgeConnector(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_BRepAlgo.Handle_BRepAlgo_EdgeConnector_DownCast)
    __swig_destroy__ = _BRepAlgo.delete_Handle_BRepAlgo_EdgeConnector
Handle_BRepAlgo_EdgeConnector.Nullify = new_instancemethod(_BRepAlgo.Handle_BRepAlgo_EdgeConnector_Nullify,None,Handle_BRepAlgo_EdgeConnector)
Handle_BRepAlgo_EdgeConnector.IsNull = new_instancemethod(_BRepAlgo.Handle_BRepAlgo_EdgeConnector_IsNull,None,Handle_BRepAlgo_EdgeConnector)
Handle_BRepAlgo_EdgeConnector.GetObject = new_instancemethod(_BRepAlgo.Handle_BRepAlgo_EdgeConnector_GetObject,None,Handle_BRepAlgo_EdgeConnector)
Handle_BRepAlgo_EdgeConnector_swigregister = _BRepAlgo.Handle_BRepAlgo_EdgeConnector_swigregister
Handle_BRepAlgo_EdgeConnector_swigregister(Handle_BRepAlgo_EdgeConnector)

def Handle_BRepAlgo_EdgeConnector_DownCast(*args):
  return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_DownCast(*args)
Handle_BRepAlgo_EdgeConnector_DownCast = _BRepAlgo.Handle_BRepAlgo_EdgeConnector_DownCast

class BRepAlgo_FaceRestrictor(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        """
        _BRepAlgo.BRepAlgo_FaceRestrictor_swiginit(self,_BRepAlgo.new_BRepAlgo_FaceRestrictor(*args))
    def Init(self, *args):
        """
        * the surface of <F> will be the the surface of each new faces built. <Proj> is used to update pcurves on edges if necessary. See Add().

        :param F:
        :type F: TopoDS_Face &
        :param Proj: default value is Standard_False
        :type Proj: bool
        :param ControlOrientation: default value is Standard_False
        :type ControlOrientation: bool
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_FaceRestrictor_Init(self, *args)

    def Add(self, *args):
        """
        * Add the wire <W> to the set of wires. Warning: The Wires must be closed.  The edges of <W> can be modified if they have not pcurves on the surface <S> of <F>. In this case if <Proj> is false the first pcurve of the edge is positionned on <S>. if <Proj> is True ,the Pcurve On <S> is the projection of the curve 3d on <F>.

        :param W:
        :type W: TopoDS_Wire &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_FaceRestrictor_Add(self, *args)

    def Clear(self, *args):
        """
        * Removes all the Wires

        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_FaceRestrictor_Clear(self, *args)

    def Perform(self, *args):
        """
        * Evaluate all the faces limited by the set of Wires.

        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_FaceRestrictor_Perform(self, *args)

    def IsDone(self, *args):
        """
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_FaceRestrictor_IsDone(self, *args)

    def More(self, *args):
        """
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_FaceRestrictor_More(self, *args)

    def Next(self, *args):
        """
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_FaceRestrictor_Next(self, *args)

    def Current(self, *args):
        """
        :rtype: TopoDS_Face

        """
        return _BRepAlgo.BRepAlgo_FaceRestrictor_Current(self, *args)

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_FaceRestrictor
BRepAlgo_FaceRestrictor.Init = new_instancemethod(_BRepAlgo.BRepAlgo_FaceRestrictor_Init,None,BRepAlgo_FaceRestrictor)
BRepAlgo_FaceRestrictor.Add = new_instancemethod(_BRepAlgo.BRepAlgo_FaceRestrictor_Add,None,BRepAlgo_FaceRestrictor)
BRepAlgo_FaceRestrictor.Clear = new_instancemethod(_BRepAlgo.BRepAlgo_FaceRestrictor_Clear,None,BRepAlgo_FaceRestrictor)
BRepAlgo_FaceRestrictor.Perform = new_instancemethod(_BRepAlgo.BRepAlgo_FaceRestrictor_Perform,None,BRepAlgo_FaceRestrictor)
BRepAlgo_FaceRestrictor.IsDone = new_instancemethod(_BRepAlgo.BRepAlgo_FaceRestrictor_IsDone,None,BRepAlgo_FaceRestrictor)
BRepAlgo_FaceRestrictor.More = new_instancemethod(_BRepAlgo.BRepAlgo_FaceRestrictor_More,None,BRepAlgo_FaceRestrictor)
BRepAlgo_FaceRestrictor.Next = new_instancemethod(_BRepAlgo.BRepAlgo_FaceRestrictor_Next,None,BRepAlgo_FaceRestrictor)
BRepAlgo_FaceRestrictor.Current = new_instancemethod(_BRepAlgo.BRepAlgo_FaceRestrictor_Current,None,BRepAlgo_FaceRestrictor)
BRepAlgo_FaceRestrictor_swigregister = _BRepAlgo.BRepAlgo_FaceRestrictor_swigregister
BRepAlgo_FaceRestrictor_swigregister(BRepAlgo_FaceRestrictor)

class BRepAlgo_Image(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        """
        _BRepAlgo.BRepAlgo_Image_swiginit(self,_BRepAlgo.new_BRepAlgo_Image(*args))
    def SetRoot(self, *args):
        """
        :param S:
        :type S: TopoDS_Shape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Image_SetRoot(self, *args)

    def Bind(self, *args):
        """
        * Links <NewS> as image of <OldS>.

        :param OldS:
        :type OldS: TopoDS_Shape &
        :param NewS:
        :type NewS: TopoDS_Shape &
        :rtype: None

        * Links <NewS> as image of <OldS>.

        :param OldS:
        :type OldS: TopoDS_Shape &
        :param NewS:
        :type NewS: TopTools_ListOfShape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Image_Bind(self, *args)

    def Add(self, *args):
        """
        * Add <NewS> to the image of <OldS>.

        :param OldS:
        :type OldS: TopoDS_Shape &
        :param NewS:
        :type NewS: TopoDS_Shape &
        :rtype: None

        * Add <NewS> to the image of <OldS>.

        :param OldS:
        :type OldS: TopoDS_Shape &
        :param NewS:
        :type NewS: TopTools_ListOfShape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Image_Add(self, *args)

    def Clear(self, *args):
        """
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Image_Clear(self, *args)

    def Remove(self, *args):
        """
        * Remove <S> to set of images.

        :param S:
        :type S: TopoDS_Shape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Image_Remove(self, *args)

    def Roots(self, *args):
        """
        :rtype: TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_Image_Roots(self, *args)

    def IsImage(self, *args):
        """
        :param S:
        :type S: TopoDS_Shape &
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_Image_IsImage(self, *args)

    def ImageFrom(self, *args):
        """
        * Returns the generator of <S>

        :param S:
        :type S: TopoDS_Shape &
        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_Image_ImageFrom(self, *args)

    def Root(self, *args):
        """
        * Returns the upper generator of <S>

        :param S:
        :type S: TopoDS_Shape &
        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_Image_Root(self, *args)

    def HasImage(self, *args):
        """
        :param S:
        :type S: TopoDS_Shape &
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_Image_HasImage(self, *args)

    def Image(self, *args):
        """
        * Returns the Image of <S>. Returns <S> in the list if HasImage(S) is false.

        :param S:
        :type S: TopoDS_Shape &
        :rtype: TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_Image_Image(self, *args)

    def LastImage(self, *args):
        """
        * Stores in <L> the images of images of...images of <S>. <L> contains only <S> if HasImage(S) is false.

        :param S:
        :type S: TopoDS_Shape &
        :param L:
        :type L: TopTools_ListOfShape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Image_LastImage(self, *args)

    def Compact(self, *args):
        """
        * Keeps only the link between roots and lastimage.

        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Image_Compact(self, *args)

    def Filter(self, *args):
        """
        * Deletes in the images the shape of type <ShapeType> which are not in <S>. Warning: Compact() must be call before.

        :param S:
        :type S: TopoDS_Shape &
        :param ShapeType:
        :type ShapeType: TopAbs_ShapeEnum
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Image_Filter(self, *args)

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_Image
BRepAlgo_Image.SetRoot = new_instancemethod(_BRepAlgo.BRepAlgo_Image_SetRoot,None,BRepAlgo_Image)
BRepAlgo_Image.Bind = new_instancemethod(_BRepAlgo.BRepAlgo_Image_Bind,None,BRepAlgo_Image)
BRepAlgo_Image.Add = new_instancemethod(_BRepAlgo.BRepAlgo_Image_Add,None,BRepAlgo_Image)
BRepAlgo_Image.Clear = new_instancemethod(_BRepAlgo.BRepAlgo_Image_Clear,None,BRepAlgo_Image)
BRepAlgo_Image.Remove = new_instancemethod(_BRepAlgo.BRepAlgo_Image_Remove,None,BRepAlgo_Image)
BRepAlgo_Image.Roots = new_instancemethod(_BRepAlgo.BRepAlgo_Image_Roots,None,BRepAlgo_Image)
BRepAlgo_Image.IsImage = new_instancemethod(_BRepAlgo.BRepAlgo_Image_IsImage,None,BRepAlgo_Image)
BRepAlgo_Image.ImageFrom = new_instancemethod(_BRepAlgo.BRepAlgo_Image_ImageFrom,None,BRepAlgo_Image)
BRepAlgo_Image.Root = new_instancemethod(_BRepAlgo.BRepAlgo_Image_Root,None,BRepAlgo_Image)
BRepAlgo_Image.HasImage = new_instancemethod(_BRepAlgo.BRepAlgo_Image_HasImage,None,BRepAlgo_Image)
BRepAlgo_Image.Image = new_instancemethod(_BRepAlgo.BRepAlgo_Image_Image,None,BRepAlgo_Image)
BRepAlgo_Image.LastImage = new_instancemethod(_BRepAlgo.BRepAlgo_Image_LastImage,None,BRepAlgo_Image)
BRepAlgo_Image.Compact = new_instancemethod(_BRepAlgo.BRepAlgo_Image_Compact,None,BRepAlgo_Image)
BRepAlgo_Image.Filter = new_instancemethod(_BRepAlgo.BRepAlgo_Image_Filter,None,BRepAlgo_Image)
BRepAlgo_Image_swigregister = _BRepAlgo.BRepAlgo_Image_swigregister
BRepAlgo_Image_swigregister(BRepAlgo_Image)

class BRepAlgo_Loop(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        """
        _BRepAlgo.BRepAlgo_Loop_swiginit(self,_BRepAlgo.new_BRepAlgo_Loop(*args))
    def Init(self, *args):
        """
        * Init with <F> the set of edges must have pcurves on <F>.

        :param F:
        :type F: TopoDS_Face &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Loop_Init(self, *args)

    def AddEdge(self, *args):
        """
        * Add E with <LV>. <E> will be copied and trim by vertices in <LV>.

        :param E:
        :type E: TopoDS_Edge &
        :param LV:
        :type LV: TopTools_ListOfShape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Loop_AddEdge(self, *args)

    def AddConstEdge(self, *args):
        """
        * Add <E> as const edge, E can be in the result.

        :param E:
        :type E: TopoDS_Edge &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Loop_AddConstEdge(self, *args)

    def AddConstEdges(self, *args):
        """
        * Add <LE> as a set of const edges.

        :param LE:
        :type LE: TopTools_ListOfShape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Loop_AddConstEdges(self, *args)

    def Perform(self, *args):
        """
        * Make loops.

        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Loop_Perform(self, *args)

    def CutEdge(self, *args):
        """
        * Cut the edge <E> in several edges <NE> on the vertices<VonE>.

        :param E:
        :type E: TopoDS_Edge &
        :param VonE:
        :type VonE: TopTools_ListOfShape &
        :param NE:
        :type NE: TopTools_ListOfShape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Loop_CutEdge(self, *args)

    def NewWires(self, *args):
        """
        * Returns the list of wires performed. can be an empty list.

        :rtype: TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_Loop_NewWires(self, *args)

    def WiresToFaces(self, *args):
        """
        * Build faces from the wires result.

        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Loop_WiresToFaces(self, *args)

    def NewFaces(self, *args):
        """
        * Returns the list of faces. Warning: The method <WiresToFaces> as to be called before. can be an empty list.

        :rtype: TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_Loop_NewFaces(self, *args)

    def NewEdges(self, *args):
        """
        * Returns the list of new edges built from an edge <E> it can be an empty list.

        :param E:
        :type E: TopoDS_Edge &
        :rtype: TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_Loop_NewEdges(self, *args)

    def GetVerticesForSubstitute(self, *args):
        """
        * Returns the datamap of vertices with their substitutes.

        :param VerVerMap:
        :type VerVerMap: TopTools_DataMapOfShapeShape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Loop_GetVerticesForSubstitute(self, *args)

    def VerticesForSubstitute(self, *args):
        """
        :param VerVerMap:
        :type VerVerMap: TopTools_DataMapOfShapeShape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Loop_VerticesForSubstitute(self, *args)

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_Loop
BRepAlgo_Loop.Init = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_Init,None,BRepAlgo_Loop)
BRepAlgo_Loop.AddEdge = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_AddEdge,None,BRepAlgo_Loop)
BRepAlgo_Loop.AddConstEdge = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_AddConstEdge,None,BRepAlgo_Loop)
BRepAlgo_Loop.AddConstEdges = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_AddConstEdges,None,BRepAlgo_Loop)
BRepAlgo_Loop.Perform = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_Perform,None,BRepAlgo_Loop)
BRepAlgo_Loop.CutEdge = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_CutEdge,None,BRepAlgo_Loop)
BRepAlgo_Loop.NewWires = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_NewWires,None,BRepAlgo_Loop)
BRepAlgo_Loop.WiresToFaces = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_WiresToFaces,None,BRepAlgo_Loop)
BRepAlgo_Loop.NewFaces = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_NewFaces,None,BRepAlgo_Loop)
BRepAlgo_Loop.NewEdges = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_NewEdges,None,BRepAlgo_Loop)
BRepAlgo_Loop.GetVerticesForSubstitute = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_GetVerticesForSubstitute,None,BRepAlgo_Loop)
BRepAlgo_Loop.VerticesForSubstitute = new_instancemethod(_BRepAlgo.BRepAlgo_Loop_VerticesForSubstitute,None,BRepAlgo_Loop)
BRepAlgo_Loop_swigregister = _BRepAlgo.BRepAlgo_Loop_swigregister
BRepAlgo_Loop_swigregister(BRepAlgo_Loop)

class BRepAlgo_NormalProjection(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        :param S:
        :type S: TopoDS_Shape &
        :rtype: None

        """
        _BRepAlgo.BRepAlgo_NormalProjection_swiginit(self,_BRepAlgo.new_BRepAlgo_NormalProjection(*args))
    def Init(self, *args):
        """
        :param S:
        :type S: TopoDS_Shape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_Init(self, *args)

    def Add(self, *args):
        """
        * Add an edge or a wire to the list of shape to project

        :param ToProj:
        :type ToProj: TopoDS_Shape &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_Add(self, *args)

    def SetParams(self, *args):
        """
        * Set the parameters used for computation Tol3d is the requiered tolerance between the 3d projected curve and its 2d representation InternalContinuity is the order of constraints used for approximation. MaxDeg and MaxSeg are the maximum degree and the maximum number of segment for BSpline resulting of an approximation.

        :param Tol3D:
        :type Tol3D: float
        :param Tol2D:
        :type Tol2D: float
        :param InternalContinuity:
        :type InternalContinuity: GeomAbs_Shape
        :param MaxDegree:
        :type MaxDegree: int
        :param MaxSeg:
        :type MaxSeg: int
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_SetParams(self, *args)

    def SetDefaultParams(self, *args):
        """
        * Set the parameters used for computation in their default values

        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_SetDefaultParams(self, *args)

    def SetMaxDistance(self, *args):
        """
        * Sets the maximum distance between target shape and shape to project. If this condition is not satisfied then corresponding part of solution is discarded. if MaxDist < 0 then this method does not affect the algorithm

        :param MaxDist:
        :type MaxDist: float
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_SetMaxDistance(self, *args)

    def Compute3d(self, *args):
        """
        * if With3d = Standard_False the 3dcurve is not computed the initial 3dcurve is kept to build the resulting edges.

        :param With3d: default value is Standard_True
        :type With3d: bool
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_Compute3d(self, *args)

    def SetLimit(self, *args):
        """
        * Manage limitation of projected edges.

        :param FaceBoundaries: default value is Standard_True
        :type FaceBoundaries: bool
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_SetLimit(self, *args)

    def Build(self, *args):
        """
        * Builds the result as a compound.

        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_Build(self, *args)

    def IsDone(self, *args):
        """
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_IsDone(self, *args)

    def Projection(self, *args):
        """
        * returns the result

        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_Projection(self, *args)

    def Ancestor(self, *args):
        """
        * For a resulting edge, returns the corresponding initial edge.

        :param E:
        :type E: TopoDS_Edge &
        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_Ancestor(self, *args)

    def Couple(self, *args):
        """
        * For a projected edge, returns the corresponding initial face.

        :param E:
        :type E: TopoDS_Edge &
        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_Couple(self, *args)

    def Generated(self, *args):
        """
        * Returns the list of shapes generated from the shape <S>.

        :param S:
        :type S: TopoDS_Shape &
        :rtype: TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_Generated(self, *args)

    def IsElementary(self, *args):
        """
        :param C:
        :type C: Adaptor3d_Curve &
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_IsElementary(self, *args)

    def BuildWire(self, *args):
        """
        * build the result as a list of wire if possible in -- a first returns a wire only if there is only a wire.

        :param Liste:
        :type Liste: TopTools_ListOfShape &
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_BuildWire(self, *args)

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_NormalProjection
BRepAlgo_NormalProjection.Init = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_Init,None,BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.Add = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_Add,None,BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.SetParams = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_SetParams,None,BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.SetDefaultParams = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_SetDefaultParams,None,BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.SetMaxDistance = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_SetMaxDistance,None,BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.Compute3d = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_Compute3d,None,BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.SetLimit = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_SetLimit,None,BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.Build = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_Build,None,BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.IsDone = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_IsDone,None,BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.Projection = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_Projection,None,BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.Ancestor = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_Ancestor,None,BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.Couple = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_Couple,None,BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.Generated = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_Generated,None,BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.IsElementary = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_IsElementary,None,BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection.BuildWire = new_instancemethod(_BRepAlgo.BRepAlgo_NormalProjection_BuildWire,None,BRepAlgo_NormalProjection)
BRepAlgo_NormalProjection_swigregister = _BRepAlgo.BRepAlgo_NormalProjection_swigregister
BRepAlgo_NormalProjection_swigregister(BRepAlgo_NormalProjection)

class BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger(OCC.TCollection.TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param I:
        :type I: TColStd_SequenceOfInteger &
        :param n:
        :type n: TCollection_SeqNodePtr &
        :param p:
        :type p: TCollection_SeqNodePtr &
        :rtype: None

        """
        _BRepAlgo.BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger_swiginit(self,_BRepAlgo.new_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger(*args))
    def Value(self, *args):
        """
        :rtype: TColStd_SequenceOfInteger

        """
        return _BRepAlgo.BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger_Value(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger
BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger.Value = new_instancemethod(_BRepAlgo.BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger_Value,None,BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger)
BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger_swigregister = _BRepAlgo.BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger_swigregister
BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger_swigregister(BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger)

class Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger(OCC.TCollection.Handle_TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _BRepAlgo.Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger_swiginit(self,_BRepAlgo.new_Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_BRepAlgo.Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger_DownCast)
    __swig_destroy__ = _BRepAlgo.delete_Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger
Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger.Nullify = new_instancemethod(_BRepAlgo.Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger_Nullify,None,Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger)
Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger.IsNull = new_instancemethod(_BRepAlgo.Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger_IsNull,None,Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger)
Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger.GetObject = new_instancemethod(_BRepAlgo.Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger_GetObject,None,Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger)
Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger_swigregister = _BRepAlgo.Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger_swigregister
Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger_swigregister(Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger)

def Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger_DownCast(*args):
  return _BRepAlgo.Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger_DownCast(*args)
Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger_DownCast = _BRepAlgo.Handle_BRepAlgo_SequenceNodeOfSequenceOfSequenceOfInteger_DownCast

class BRepAlgo_SequenceOfSequenceOfInteger(OCC.TCollection.TCollection_BaseSequence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        """
        _BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_swiginit(self,_BRepAlgo.new_BRepAlgo_SequenceOfSequenceOfInteger(*args))
    def Clear(self, *args):
        """
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_Clear(self, *args)

    def Assign(self, *args):
        """
        :param Other:
        :type Other: BRepAlgo_SequenceOfSequenceOfInteger &
        :rtype: BRepAlgo_SequenceOfSequenceOfInteger

        """
        return _BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_Assign(self, *args)

    def Set(self, *args):
        """
        :param Other:
        :type Other: BRepAlgo_SequenceOfSequenceOfInteger &
        :rtype: BRepAlgo_SequenceOfSequenceOfInteger

        """
        return _BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_Set(self, *args)

    def Append(self, *args):
        """
        :param T:
        :type T: TColStd_SequenceOfInteger &
        :rtype: None

        :param S:
        :type S: BRepAlgo_SequenceOfSequenceOfInteger &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_Append(self, *args)

    def Prepend(self, *args):
        """
        :param T:
        :type T: TColStd_SequenceOfInteger &
        :rtype: None

        :param S:
        :type S: BRepAlgo_SequenceOfSequenceOfInteger &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_Prepend(self, *args)

    def InsertBefore(self, *args):
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: TColStd_SequenceOfInteger &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: BRepAlgo_SequenceOfSequenceOfInteger &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_InsertBefore(self, *args)

    def InsertAfter(self, *args):
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: TColStd_SequenceOfInteger &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: BRepAlgo_SequenceOfSequenceOfInteger &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_InsertAfter(self, *args)

    def First(self, *args):
        """
        :rtype: TColStd_SequenceOfInteger

        """
        return _BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_First(self, *args)

    def Last(self, *args):
        """
        :rtype: TColStd_SequenceOfInteger

        """
        return _BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_Last(self, *args)

    def Split(self, *args):
        """
        :param Index:
        :type Index: int
        :param Sub:
        :type Sub: BRepAlgo_SequenceOfSequenceOfInteger &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_Split(self, *args)

    def Value(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: TColStd_SequenceOfInteger

        """
        return _BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_Value(self, *args)

    def SetValue(self, *args):
        """
        :param Index:
        :type Index: int
        :param I:
        :type I: TColStd_SequenceOfInteger &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_SetValue(self, *args)

    def ChangeValue(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: TColStd_SequenceOfInteger

        """
        return _BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_ChangeValue(self, *args)

    def Remove(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: None

        :param FromIndex:
        :type FromIndex: int
        :param ToIndex:
        :type ToIndex: int
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_Remove(self, *args)

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_SequenceOfSequenceOfInteger
BRepAlgo_SequenceOfSequenceOfInteger.Clear = new_instancemethod(_BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_Clear,None,BRepAlgo_SequenceOfSequenceOfInteger)
BRepAlgo_SequenceOfSequenceOfInteger.Assign = new_instancemethod(_BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_Assign,None,BRepAlgo_SequenceOfSequenceOfInteger)
BRepAlgo_SequenceOfSequenceOfInteger.Set = new_instancemethod(_BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_Set,None,BRepAlgo_SequenceOfSequenceOfInteger)
BRepAlgo_SequenceOfSequenceOfInteger.Append = new_instancemethod(_BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_Append,None,BRepAlgo_SequenceOfSequenceOfInteger)
BRepAlgo_SequenceOfSequenceOfInteger.Prepend = new_instancemethod(_BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_Prepend,None,BRepAlgo_SequenceOfSequenceOfInteger)
BRepAlgo_SequenceOfSequenceOfInteger.InsertBefore = new_instancemethod(_BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_InsertBefore,None,BRepAlgo_SequenceOfSequenceOfInteger)
BRepAlgo_SequenceOfSequenceOfInteger.InsertAfter = new_instancemethod(_BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_InsertAfter,None,BRepAlgo_SequenceOfSequenceOfInteger)
BRepAlgo_SequenceOfSequenceOfInteger.First = new_instancemethod(_BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_First,None,BRepAlgo_SequenceOfSequenceOfInteger)
BRepAlgo_SequenceOfSequenceOfInteger.Last = new_instancemethod(_BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_Last,None,BRepAlgo_SequenceOfSequenceOfInteger)
BRepAlgo_SequenceOfSequenceOfInteger.Split = new_instancemethod(_BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_Split,None,BRepAlgo_SequenceOfSequenceOfInteger)
BRepAlgo_SequenceOfSequenceOfInteger.Value = new_instancemethod(_BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_Value,None,BRepAlgo_SequenceOfSequenceOfInteger)
BRepAlgo_SequenceOfSequenceOfInteger.SetValue = new_instancemethod(_BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_SetValue,None,BRepAlgo_SequenceOfSequenceOfInteger)
BRepAlgo_SequenceOfSequenceOfInteger.ChangeValue = new_instancemethod(_BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_ChangeValue,None,BRepAlgo_SequenceOfSequenceOfInteger)
BRepAlgo_SequenceOfSequenceOfInteger.Remove = new_instancemethod(_BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_Remove,None,BRepAlgo_SequenceOfSequenceOfInteger)
BRepAlgo_SequenceOfSequenceOfInteger_swigregister = _BRepAlgo.BRepAlgo_SequenceOfSequenceOfInteger_swigregister
BRepAlgo_SequenceOfSequenceOfInteger_swigregister(BRepAlgo_SequenceOfSequenceOfInteger)

class BRepAlgo_Tool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Deboucle3D(*args):
        """
        * Remove the non valid part of an offsetshape 1 - Remove all the free boundary and the faces connex to such edges. 2 - Remove all the shapes not valid in the result (according to the side of offseting) in this verion only the first point is implemented.

        :param S:
        :type S: TopoDS_Shape &
        :param Boundary:
        :type Boundary: TopTools_MapOfShape &
        :rtype: TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_Tool_Deboucle3D(*args)

    Deboucle3D = staticmethod(Deboucle3D)
    def __init__(self): 
        _BRepAlgo.BRepAlgo_Tool_swiginit(self,_BRepAlgo.new_BRepAlgo_Tool())
    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_Tool
BRepAlgo_Tool_swigregister = _BRepAlgo.BRepAlgo_Tool_swigregister
BRepAlgo_Tool_swigregister(BRepAlgo_Tool)

def BRepAlgo_Tool_Deboucle3D(*args):
  """
    * Remove the non valid part of an offsetshape 1 - Remove all the free boundary and the faces connex to such edges. 2 - Remove all the shapes not valid in the result (according to the side of offseting) in this verion only the first point is implemented.

    :param S:
    :type S: TopoDS_Shape &
    :param Boundary:
    :type Boundary: TopTools_MapOfShape &
    :rtype: TopoDS_Shape

    """
  return _BRepAlgo.BRepAlgo_Tool_Deboucle3D(*args)

class BRepAlgo_Common(BRepAlgo_BooleanOperation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Constructs the common part of shapes S1 and S2.

        :param S1:
        :type S1: TopoDS_Shape &
        :param S2:
        :type S2: TopoDS_Shape &
        :rtype: None

        """
        _BRepAlgo.BRepAlgo_Common_swiginit(self,_BRepAlgo.new_BRepAlgo_Common(*args))
    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_Common
BRepAlgo_Common_swigregister = _BRepAlgo.BRepAlgo_Common_swigregister
BRepAlgo_Common_swigregister(BRepAlgo_Common)

class BRepAlgo_Cut(BRepAlgo_BooleanOperation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Cuts the shape S2 from the shape S1.

        :param S1:
        :type S1: TopoDS_Shape &
        :param S2:
        :type S2: TopoDS_Shape &
        :rtype: None

        """
        _BRepAlgo.BRepAlgo_Cut_swiginit(self,_BRepAlgo.new_BRepAlgo_Cut(*args))
    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_Cut
BRepAlgo_Cut_swigregister = _BRepAlgo.BRepAlgo_Cut_swigregister
BRepAlgo_Cut_swigregister(BRepAlgo_Cut)

class BRepAlgo_Fuse(BRepAlgo_BooleanOperation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Fuse S1 and S2.

        :param S1:
        :type S1: TopoDS_Shape &
        :param S2:
        :type S2: TopoDS_Shape &
        :rtype: None

        """
        _BRepAlgo.BRepAlgo_Fuse_swiginit(self,_BRepAlgo.new_BRepAlgo_Fuse(*args))
    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_Fuse
BRepAlgo_Fuse_swigregister = _BRepAlgo.BRepAlgo_Fuse_swigregister
BRepAlgo_Fuse_swigregister(BRepAlgo_Fuse)

class BRepAlgo_Section(BRepAlgo_BooleanOperation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param Sh1:
        :type Sh1: TopoDS_Shape &
        :param Sh2:
        :type Sh2: TopoDS_Shape &
        :param PerformNow: default value is Standard_True
        :type PerformNow: bool
        :rtype: None

        :param Sh:
        :type Sh: TopoDS_Shape &
        :param Pl:
        :type Pl: gp_Pln
        :param PerformNow: default value is Standard_True
        :type PerformNow: bool
        :rtype: None

        :param Sh:
        :type Sh: TopoDS_Shape &
        :param Sf:
        :type Sf: Handle_Geom_Surface &
        :param PerformNow: default value is Standard_True
        :type PerformNow: bool
        :rtype: None

        :param Sf:
        :type Sf: Handle_Geom_Surface &
        :param Sh:
        :type Sh: TopoDS_Shape &
        :param PerformNow: default value is Standard_True
        :type PerformNow: bool
        :rtype: None

        * This and the above algorithms construct a framework for computing the section lines of - the two shapes Sh1 and Sh2, or - the shape Sh and the plane Pl, or - the shape Sh and the surface Sf, or - the surface Sf and the shape Sh, or - the two surfaces Sf1 and Sf2, and builds the result if PerformNow equals true, its default value. If PerformNow equals false, the intersection will be computed later by the function Build. The constructed shape will be returned by the function Shape. This is a compound object composed of edges. These intersection edges may be built: - on new intersection lines, or - on coincident portions of edges in the two intersected shapes. These intersection edges are independent: they are not chained or grouped in wires. If no intersection edge exists, the result is an empty compound object. Note that other objects than TopoDS_Shape shapes involved in these syntaxes are converted into faces or shells before performing the computation of the intersection. A shape resulting from this conversion can be retrieved with the function Shape1 or Shape2. Parametric 2D curves on intersection edges No parametric 2D curve (pcurve) is defined for each elementary edge of the result. To attach such parametric curves to the constructed edges you may use a constructor with the PerformNow flag equal to false; then you use: - the function ComputePCurveOn1 to ask for the additional computation of a pcurve in the parametric space of the first shape, - the function ComputePCurveOn2 to ask for the additional computation of a pcurve in the parametric space of the second shape, - in the end, the function Build to construct the result. Note that as a result, pcurves will only be added on edges built on new intersection lines. Approximation of intersection edges The underlying 3D geometry attached to each elementary edge of the result is: - analytic where possible, provided the corresponding geometry corresponds to a type of analytic curve defined in the Geom package; for example, the intersection of a cylindrical shape with a plane gives an ellipse or a circle; - or elsewhere, given as a succession of points grouped together in a BSpline curve of degree 1. If you prefer to have an attached 3D geometry which is a BSpline approximation of the computed set of points on computed elementary intersection edges whose underlying geometry is not analytic, you may use a constructor with the PerformNow flag equal to false. Then you use: - the function Approximation to ask for this computation option, and - the function Build to construct the result. Note that as a result, approximations will only be computed on edges built on new intersection lines. Example You may also combine these computation options. In the following example: - each elementary edge of the computed intersection, built on a new intersection line, which does not correspond to an analytic Geom curve, will be approximated by a BSpline curve whose degree is not greater than 8. - each elementary edge built on a new intersection line, will have: - a pcurve in the parametric space of the shape S1, - no pcurve in the parametric space of the shape S2. // TopoDS_Shape S1 = ... , S2 = ... ; Standard_Boolean PerformNow = Standard_False; BRepAlgo_Section S ( S1, S2, PerformNow ); S.ComputePCurveOn1 (Standard_True); S.Approximation (Standard_True); S.Build(); TopoDS_Shape R = S.Shape();

        :param Sf1:
        :type Sf1: Handle_Geom_Surface &
        :param Sf2:
        :type Sf2: Handle_Geom_Surface &
        :param PerformNow: default value is Standard_True
        :type PerformNow: bool
        :rtype: None

        """
        _BRepAlgo.BRepAlgo_Section_swiginit(self,_BRepAlgo.new_BRepAlgo_Section(*args))
    def Init1(self, *args):
        """
        * Initializes the first part

        :param S1:
        :type S1: TopoDS_Shape &
        :rtype: None

        * Initializes the first part

        :param Pl:
        :type Pl: gp_Pln
        :rtype: None

        * Initializes the first part

        :param Sf:
        :type Sf: Handle_Geom_Surface &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Section_Init1(self, *args)

    def Init2(self, *args):
        """
        * initialize second part

        :param S2:
        :type S2: TopoDS_Shape &
        :rtype: None

        * Initializes the second part

        :param Pl:
        :type Pl: gp_Pln
        :rtype: None

        * This and the above algorithms reinitialize the first and the second parts on which this algorithm is going to perform the intersection computation. This is done with either: the surface Sf, the plane Pl or the shape Sh. You use the function Build to construct the result.

        :param Sf:
        :type Sf: Handle_Geom_Surface &
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Section_Init2(self, *args)

    def Approximation(self, *args):
        """
        * Defines an option for computation of further intersections. This computation will be performed by the function Build in this framework. By default, the underlying 3D geometry attached to each elementary edge of the result of a computed intersection is: - analytic where possible, provided the corresponding geometry corresponds to a type of analytic curve defined in the Geom package; for example the intersection of a cylindrical shape with a plane gives an ellipse or a circle; - or elsewhere, given as a succession of points grouped together in a BSpline curve of degree 1. If Approx equals true, when further computations are performed in this framework with the function Build, these edges will have an attached 3D geometry which is a BSpline approximation of the computed set of points. Note that as a result, approximations will be computed on edges built only on new intersection lines.

        :param B:
        :type B: bool
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Section_Approximation(self, *args)

    def ComputePCurveOn1(self, *args):
        """
        * Indicates if the Pcurve must be (or not) performed on first part.

        :param B:
        :type B: bool
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Section_ComputePCurveOn1(self, *args)

    def ComputePCurveOn2(self, *args):
        """
        * Define options for the computation of further intersections which will be performed by the function Build in this framework. By default, no parametric 2D curve (pcurve) is defined for the elementary edges of the result. If ComputePCurve1 equals true, further computations performed in this framework with the function Build will attach an additional pcurve in the parametric space of the first shape to the constructed edges. If ComputePCurve2 equals true, the additional pcurve will be attached to the constructed edges in the parametric space of the second shape. These two functions may be used together. Note that as a result, pcurves will only be added onto edges built on new intersection lines.

        :param B:
        :type B: bool
        :rtype: None

        """
        return _BRepAlgo.BRepAlgo_Section_ComputePCurveOn2(self, *args)

    def HasAncestorFaceOn1(self, *args):
        """
        * //!Identifies the ancestor faces of the new intersection edge E resulting from the last computation performed in this framework, that is, the faces of the two original shapes on which the edge E lies: - HasAncestorFaceOn1 gives the ancestor face in the first shape, and These functions return: - true if an ancestor face F is found, or - false if not. An ancestor face is identifiable for the edge E if the three following conditions are satisfied: - the first part on which this algorithm performed its last computation is a shape, that is, it was not given as a surface or a plane at the time of construction of this algorithm or at a later time by the Init1 function, - E is one of the elementary edges built by the last computation of this section algorithm, - the edge E is built on an intersection curve. In other words, E is a new edge built on the intersection curve, not on edges belonging to the intersecting shapes. To use these functions properly, you have to test the returned Boolean value before using the ancestor face: F is significant only if the returned Boolean value equals true.

        :param E:
        :type E: TopoDS_Shape &
        :param F:
        :type F: TopoDS_Shape &
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_Section_HasAncestorFaceOn1(self, *args)

    def HasAncestorFaceOn2(self, *args):
        """
        * Identifies the ancestor faces of the new intersection edge E resulting from the last computation performed in this framework, that is, the faces of the two original shapes on which the edge E lies: - HasAncestorFaceOn2 gives the ancestor face in the second shape. These functions return: - true if an ancestor face F is found, or - false if not. An ancestor face is identifiable for the edge E if the three following conditions are satisfied: - the first part on which this algorithm performed its last computation is a shape, that is, it was not given as a surface or a plane at the time of construction of this algorithm or at a later time by the Init1 function, - E is one of the elementary edges built by the last computation of this section algorithm, - the edge E is built on an intersection curve. In other words, E is a new edge built on the intersection curve, not on edges belonging to the intersecting shapes. To use these functions properly, you have to test the returned Boolean value before using the ancestor face: F is significant only if the returned Boolean value equals true.

        :param E:
        :type E: TopoDS_Shape &
        :param F:
        :type F: TopoDS_Shape &
        :rtype: bool

        """
        return _BRepAlgo.BRepAlgo_Section_HasAncestorFaceOn2(self, *args)

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_Section
BRepAlgo_Section.Init1 = new_instancemethod(_BRepAlgo.BRepAlgo_Section_Init1,None,BRepAlgo_Section)
BRepAlgo_Section.Init2 = new_instancemethod(_BRepAlgo.BRepAlgo_Section_Init2,None,BRepAlgo_Section)
BRepAlgo_Section.Approximation = new_instancemethod(_BRepAlgo.BRepAlgo_Section_Approximation,None,BRepAlgo_Section)
BRepAlgo_Section.ComputePCurveOn1 = new_instancemethod(_BRepAlgo.BRepAlgo_Section_ComputePCurveOn1,None,BRepAlgo_Section)
BRepAlgo_Section.ComputePCurveOn2 = new_instancemethod(_BRepAlgo.BRepAlgo_Section_ComputePCurveOn2,None,BRepAlgo_Section)
BRepAlgo_Section.HasAncestorFaceOn1 = new_instancemethod(_BRepAlgo.BRepAlgo_Section_HasAncestorFaceOn1,None,BRepAlgo_Section)
BRepAlgo_Section.HasAncestorFaceOn2 = new_instancemethod(_BRepAlgo.BRepAlgo_Section_HasAncestorFaceOn2,None,BRepAlgo_Section)
BRepAlgo_Section_swigregister = _BRepAlgo.BRepAlgo_Section_swigregister
BRepAlgo_Section_swigregister(BRepAlgo_Section)



