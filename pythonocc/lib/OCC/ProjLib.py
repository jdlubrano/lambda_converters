# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _ProjLib.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ProjLib', [dirname(__file__)])
        except ImportError:
            import _ProjLib
            return _ProjLib
        if fp is not None:
            try:
                _mod = imp.load_module('_ProjLib', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ProjLib = swig_import_helper()
    del swig_import_helper
else:
    import _ProjLib
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ProjLib.delete_SwigPyIterator
    def __iter__(self): return self
SwigPyIterator.value = new_instancemethod(_ProjLib.SwigPyIterator_value,None,SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_ProjLib.SwigPyIterator_incr,None,SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_ProjLib.SwigPyIterator_decr,None,SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_ProjLib.SwigPyIterator_distance,None,SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_ProjLib.SwigPyIterator_equal,None,SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_ProjLib.SwigPyIterator_copy,None,SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_ProjLib.SwigPyIterator_next,None,SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_ProjLib.SwigPyIterator___next__,None,SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_ProjLib.SwigPyIterator_previous,None,SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_ProjLib.SwigPyIterator_advance,None,SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_ProjLib.SwigPyIterator___eq__,None,SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_ProjLib.SwigPyIterator___ne__,None,SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_ProjLib.SwigPyIterator___iadd__,None,SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_ProjLib.SwigPyIterator___isub__,None,SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_ProjLib.SwigPyIterator___add__,None,SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_ProjLib.SwigPyIterator___sub__,None,SwigPyIterator)
SwigPyIterator_swigregister = _ProjLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import OCC.gp
import OCC.Standard
import OCC.Adaptor2d
import OCC.GeomAbs
import OCC.TColStd
import OCC.TCollection
import OCC.MMgt
import OCC.Geom2d
import OCC.TColgp
import OCC.Adaptor3d
import OCC.Geom
import OCC.TopAbs
import OCC.math
def register_handle(handle, base_object):
    """
    Inserts the handle into the base object to
    prevent memory corruption in certain cases
    """
    try:
        if base_object.IsKind("Standard_Transient"):
            base_object.thisHandle = handle
            base_object.thisown = False
    except:
        pass

class projlib(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Project(*args):
        """
        * Projection on a torus.

        :param Pl:
        :type Pl: gp_Pln
        :param P:
        :type P: gp_Pnt
        :rtype: gp_Pnt2d

        :param Pl:
        :type Pl: gp_Pln
        :param L:
        :type L: gp_Lin
        :rtype: gp_Lin2d

        :param Pl:
        :type Pl: gp_Pln
        :param C:
        :type C: gp_Circ
        :rtype: gp_Circ2d

        :param Pl:
        :type Pl: gp_Pln
        :param E:
        :type E: gp_Elips
        :rtype: gp_Elips2d

        :param Pl:
        :type Pl: gp_Pln
        :param P:
        :type P: gp_Parab
        :rtype: gp_Parab2d

        :param Pl:
        :type Pl: gp_Pln
        :param H:
        :type H: gp_Hypr
        :rtype: gp_Hypr2d

        :param Cy:
        :type Cy: gp_Cylinder
        :param P:
        :type P: gp_Pnt
        :rtype: gp_Pnt2d

        :param Cy:
        :type Cy: gp_Cylinder
        :param L:
        :type L: gp_Lin
        :rtype: gp_Lin2d

        :param Cy:
        :type Cy: gp_Cylinder
        :param Ci:
        :type Ci: gp_Circ
        :rtype: gp_Lin2d

        :param Co:
        :type Co: gp_Cone
        :param P:
        :type P: gp_Pnt
        :rtype: gp_Pnt2d

        :param Co:
        :type Co: gp_Cone
        :param L:
        :type L: gp_Lin
        :rtype: gp_Lin2d

        :param Co:
        :type Co: gp_Cone
        :param Ci:
        :type Ci: gp_Circ
        :rtype: gp_Lin2d

        :param Sp:
        :type Sp: gp_Sphere
        :param P:
        :type P: gp_Pnt
        :rtype: gp_Pnt2d

        :param Sp:
        :type Sp: gp_Sphere
        :param Ci:
        :type Ci: gp_Circ
        :rtype: gp_Lin2d

        :param To:
        :type To: gp_Torus
        :param P:
        :type P: gp_Pnt
        :rtype: gp_Pnt2d

        :param To:
        :type To: gp_Torus
        :param Ci:
        :type Ci: gp_Circ
        :rtype: gp_Lin2d

        """
        return _ProjLib.projlib_Project(*args)

    Project = staticmethod(Project)
    def __init__(self): 
        _ProjLib.projlib_swiginit(self,_ProjLib.new_projlib())
    __swig_destroy__ = _ProjLib.delete_projlib
projlib_swigregister = _ProjLib.projlib_swigregister
projlib_swigregister(projlib)

def projlib_Project(*args):
  """
    * Projection on a torus.

    :param Pl:
    :type Pl: gp_Pln
    :param P:
    :type P: gp_Pnt
    :rtype: gp_Pnt2d

    :param Pl:
    :type Pl: gp_Pln
    :param L:
    :type L: gp_Lin
    :rtype: gp_Lin2d

    :param Pl:
    :type Pl: gp_Pln
    :param C:
    :type C: gp_Circ
    :rtype: gp_Circ2d

    :param Pl:
    :type Pl: gp_Pln
    :param E:
    :type E: gp_Elips
    :rtype: gp_Elips2d

    :param Pl:
    :type Pl: gp_Pln
    :param P:
    :type P: gp_Parab
    :rtype: gp_Parab2d

    :param Pl:
    :type Pl: gp_Pln
    :param H:
    :type H: gp_Hypr
    :rtype: gp_Hypr2d

    :param Cy:
    :type Cy: gp_Cylinder
    :param P:
    :type P: gp_Pnt
    :rtype: gp_Pnt2d

    :param Cy:
    :type Cy: gp_Cylinder
    :param L:
    :type L: gp_Lin
    :rtype: gp_Lin2d

    :param Cy:
    :type Cy: gp_Cylinder
    :param Ci:
    :type Ci: gp_Circ
    :rtype: gp_Lin2d

    :param Co:
    :type Co: gp_Cone
    :param P:
    :type P: gp_Pnt
    :rtype: gp_Pnt2d

    :param Co:
    :type Co: gp_Cone
    :param L:
    :type L: gp_Lin
    :rtype: gp_Lin2d

    :param Co:
    :type Co: gp_Cone
    :param Ci:
    :type Ci: gp_Circ
    :rtype: gp_Lin2d

    :param Sp:
    :type Sp: gp_Sphere
    :param P:
    :type P: gp_Pnt
    :rtype: gp_Pnt2d

    :param Sp:
    :type Sp: gp_Sphere
    :param Ci:
    :type Ci: gp_Circ
    :rtype: gp_Lin2d

    :param To:
    :type To: gp_Torus
    :param P:
    :type P: gp_Pnt
    :rtype: gp_Pnt2d

    :param To:
    :type To: gp_Torus
    :param Ci:
    :type Ci: gp_Circ
    :rtype: gp_Lin2d

    """
  return _ProjLib.projlib_Project(*args)

class ProjLib_CompProjectedCurve(OCC.Adaptor2d.Adaptor2d_Curve2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        * try to find all solutions

        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :param TolU:
        :type TolU: float
        :param TolV:
        :type TolV: float
        :rtype: None

        * this constructor tries to optimize the search using the assamption that maximum distance between surface and curve less or equal then MaxDist. if MaxDist < 0 then algorithm works as above.

        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :param TolU:
        :type TolU: float
        :param TolV:
        :type TolV: float
        :param MaxDist:
        :type MaxDist: float
        :rtype: None

        """
        _ProjLib.ProjLib_CompProjectedCurve_swiginit(self,_ProjLib.new_ProjLib_CompProjectedCurve(*args))
    def Init(self, *args):
        """
        * computes a set of projected point and determine the continuous parts of the projected curves. The points corresponding to a projection on the bounds of the surface are included in this set of points.

        :rtype: None

        """
        return _ProjLib.ProjLib_CompProjectedCurve_Init(self, *args)

    def Load(self, *args):
        """
        * Changes the surface.

        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :rtype: None

        * Changes the curve.

        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :rtype: None

        """
        return _ProjLib.ProjLib_CompProjectedCurve_Load(self, *args)

    def GetSurface(self, *args):
        """
        :rtype: Handle_Adaptor3d_HSurface

        """
        return _ProjLib.ProjLib_CompProjectedCurve_GetSurface(self, *args)

    def GetCurve(self, *args):
        """
        :rtype: Handle_Adaptor3d_HCurve

        """
        return _ProjLib.ProjLib_CompProjectedCurve_GetCurve(self, *args)

    def GetTolerance(self, *args):
        """
        :param TolU:
        :type TolU: float &
        :param TolV:
        :type TolV: float &
        :rtype: None

        """
        return _ProjLib.ProjLib_CompProjectedCurve_GetTolerance(self, *args)

    def NbCurves(self, *args):
        """
        * returns the number of continuous part of the projected curve

        :rtype: int

        """
        return _ProjLib.ProjLib_CompProjectedCurve_NbCurves(self, *args)

    def Bounds(self, *args):
        """
        * returns the bounds of the continuous part corresponding to Index

        :param Index:
        :type Index: int
        :param Udeb:
        :type Udeb: float &
        :param Ufin:
        :type Ufin: float &
        :rtype: None

        """
        return _ProjLib.ProjLib_CompProjectedCurve_Bounds(self, *args)

    def IsSinglePnt(self, *args):
        """
        * returns True if part of projection with number Index is a single point and writes its coordinats in P

        :param Index:
        :type Index: int
        :param P:
        :type P: gp_Pnt2d
        :rtype: bool

        """
        return _ProjLib.ProjLib_CompProjectedCurve_IsSinglePnt(self, *args)

    def IsUIso(self, *args):
        """
        * returns True if part of projection with number Index is an u-isoparametric curve of input surface

        :param Index:
        :type Index: int
        :param U:
        :type U: float &
        :rtype: bool

        """
        return _ProjLib.ProjLib_CompProjectedCurve_IsUIso(self, *args)

    def IsVIso(self, *args):
        """
        * returns True if part of projection with number Index is an v-isoparametric curve of input surface

        :param Index:
        :type Index: int
        :param V:
        :type V: float &
        :rtype: bool

        """
        return _ProjLib.ProjLib_CompProjectedCurve_IsVIso(self, *args)

    def MaxDistance(self, *args):
        """
        * returns the maximum distance between curve to project and surface

        :param Index:
        :type Index: int
        :rtype: float

        """
        return _ProjLib.ProjLib_CompProjectedCurve_MaxDistance(self, *args)

    def GetSequence(self, *args):
        """
        :rtype: Handle_ProjLib_HSequenceOfHSequenceOfPnt

        """
        return _ProjLib.ProjLib_CompProjectedCurve_GetSequence(self, *args)

    __swig_destroy__ = _ProjLib.delete_ProjLib_CompProjectedCurve
ProjLib_CompProjectedCurve.Init = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_Init,None,ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.Load = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_Load,None,ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.GetSurface = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_GetSurface,None,ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.GetCurve = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_GetCurve,None,ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.GetTolerance = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_GetTolerance,None,ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.NbCurves = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_NbCurves,None,ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.Bounds = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_Bounds,None,ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.IsSinglePnt = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_IsSinglePnt,None,ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.IsUIso = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_IsUIso,None,ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.IsVIso = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_IsVIso,None,ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.MaxDistance = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_MaxDistance,None,ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve.GetSequence = new_instancemethod(_ProjLib.ProjLib_CompProjectedCurve_GetSequence,None,ProjLib_CompProjectedCurve)
ProjLib_CompProjectedCurve_swigregister = _ProjLib.ProjLib_CompProjectedCurve_swigregister
ProjLib_CompProjectedCurve_swigregister(ProjLib_CompProjectedCurve)

class ProjLib_ComputeApprox(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * <Tol> is the tolerance with which the approximation is performed.

        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param Tol:
        :type Tol: float
        :rtype: None

        """
        _ProjLib.ProjLib_ComputeApprox_swiginit(self,_ProjLib.new_ProjLib_ComputeApprox(*args))
    def BSpline(self, *args):
        """
        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _ProjLib.ProjLib_ComputeApprox_BSpline(self, *args)

    def Bezier(self, *args):
        """
        :rtype: Handle_Geom2d_BezierCurve

        """
        return _ProjLib.ProjLib_ComputeApprox_Bezier(self, *args)

    def Tolerance(self, *args):
        """
        * returns the reached Tolerance.

        :rtype: float

        """
        return _ProjLib.ProjLib_ComputeApprox_Tolerance(self, *args)

    __swig_destroy__ = _ProjLib.delete_ProjLib_ComputeApprox
ProjLib_ComputeApprox.BSpline = new_instancemethod(_ProjLib.ProjLib_ComputeApprox_BSpline,None,ProjLib_ComputeApprox)
ProjLib_ComputeApprox.Bezier = new_instancemethod(_ProjLib.ProjLib_ComputeApprox_Bezier,None,ProjLib_ComputeApprox)
ProjLib_ComputeApprox.Tolerance = new_instancemethod(_ProjLib.ProjLib_ComputeApprox_Tolerance,None,ProjLib_ComputeApprox)
ProjLib_ComputeApprox_swigregister = _ProjLib.ProjLib_ComputeApprox_swigregister
ProjLib_ComputeApprox_swigregister(ProjLib_ComputeApprox)

class ProjLib_ComputeApproxOnPolarSurface(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param Tol: default value is 1.0e-4
        :type Tol: float
        :rtype: None

        :param InitCurve2d:
        :type InitCurve2d: Handle_Adaptor2d_HCurve2d &
        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param Tol:
        :type Tol: float
        :rtype: None

        :param InitCurve2d:
        :type InitCurve2d: Handle_Adaptor2d_HCurve2d &
        :param InitCurve2dBis:
        :type InitCurve2dBis: Handle_Adaptor2d_HCurve2d &
        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param Tol:
        :type Tol: float
        :rtype: None

        """
        _ProjLib.ProjLib_ComputeApproxOnPolarSurface_swiginit(self,_ProjLib.new_ProjLib_ComputeApproxOnPolarSurface(*args))
    def Perform(self, *args):
        """
        :param InitCurve2d:
        :type InitCurve2d: Handle_Adaptor2d_HCurve2d &
        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_Perform(self, *args)

    def BuildInitialCurve2d(self, *args):
        """
        :param Curve:
        :type Curve: Handle_Adaptor3d_HCurve &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :rtype: Handle_Adaptor2d_HCurve2d

        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_BuildInitialCurve2d(self, *args)

    def ProjectUsingInitialCurve2d(self, *args):
        """
        :param Curve:
        :type Curve: Handle_Adaptor3d_HCurve &
        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param InitCurve2d:
        :type InitCurve2d: Handle_Adaptor2d_HCurve2d &
        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_ProjectUsingInitialCurve2d(self, *args)

    def BSpline(self, *args):
        """
        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_BSpline(self, *args)

    def Curve2d(self, *args):
        """
        :rtype: Handle_Geom2d_Curve

        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_Curve2d(self, *args)

    def IsDone(self, *args):
        """
        :rtype: bool

        """
        return _ProjLib.ProjLib_ComputeApproxOnPolarSurface_IsDone(self, *args)

    __swig_destroy__ = _ProjLib.delete_ProjLib_ComputeApproxOnPolarSurface
ProjLib_ComputeApproxOnPolarSurface.Perform = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_Perform,None,ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface.BuildInitialCurve2d = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_BuildInitialCurve2d,None,ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface.ProjectUsingInitialCurve2d = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_ProjectUsingInitialCurve2d,None,ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface.BSpline = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_BSpline,None,ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface.Curve2d = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_Curve2d,None,ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface.IsDone = new_instancemethod(_ProjLib.ProjLib_ComputeApproxOnPolarSurface_IsDone,None,ProjLib_ComputeApproxOnPolarSurface)
ProjLib_ComputeApproxOnPolarSurface_swigregister = _ProjLib.ProjLib_ComputeApproxOnPolarSurface_swigregister
ProjLib_ComputeApproxOnPolarSurface_swigregister(ProjLib_ComputeApproxOnPolarSurface)

class ProjLib_HCompProjectedCurve(OCC.Adaptor2d.Adaptor2d_HCurve2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        :param C:
        :type C: ProjLib_CompProjectedCurve &
        :rtype: None

        """
        _ProjLib.ProjLib_HCompProjectedCurve_swiginit(self,_ProjLib.new_ProjLib_HCompProjectedCurve(*args))
    def Set(self, *args):
        """
        :param C:
        :type C: ProjLib_CompProjectedCurve &
        :rtype: None

        """
        return _ProjLib.ProjLib_HCompProjectedCurve_Set(self, *args)

    def ChangeCurve2d(self, *args):
        """
        :rtype: ProjLib_CompProjectedCurve

        """
        return _ProjLib.ProjLib_HCompProjectedCurve_ChangeCurve2d(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_ProjLib_HCompProjectedCurve(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _ProjLib.delete_ProjLib_HCompProjectedCurve
ProjLib_HCompProjectedCurve.Set = new_instancemethod(_ProjLib.ProjLib_HCompProjectedCurve_Set,None,ProjLib_HCompProjectedCurve)
ProjLib_HCompProjectedCurve.ChangeCurve2d = new_instancemethod(_ProjLib.ProjLib_HCompProjectedCurve_ChangeCurve2d,None,ProjLib_HCompProjectedCurve)
ProjLib_HCompProjectedCurve_swigregister = _ProjLib.ProjLib_HCompProjectedCurve_swigregister
ProjLib_HCompProjectedCurve_swigregister(ProjLib_HCompProjectedCurve)

class Handle_ProjLib_HCompProjectedCurve(OCC.Adaptor2d.Handle_Adaptor2d_HCurve2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _ProjLib.Handle_ProjLib_HCompProjectedCurve_swiginit(self,_ProjLib.new_Handle_ProjLib_HCompProjectedCurve(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_ProjLib.Handle_ProjLib_HCompProjectedCurve_DownCast)
    __swig_destroy__ = _ProjLib.delete_Handle_ProjLib_HCompProjectedCurve
Handle_ProjLib_HCompProjectedCurve.Nullify = new_instancemethod(_ProjLib.Handle_ProjLib_HCompProjectedCurve_Nullify,None,Handle_ProjLib_HCompProjectedCurve)
Handle_ProjLib_HCompProjectedCurve.IsNull = new_instancemethod(_ProjLib.Handle_ProjLib_HCompProjectedCurve_IsNull,None,Handle_ProjLib_HCompProjectedCurve)
Handle_ProjLib_HCompProjectedCurve.GetObject = new_instancemethod(_ProjLib.Handle_ProjLib_HCompProjectedCurve_GetObject,None,Handle_ProjLib_HCompProjectedCurve)
Handle_ProjLib_HCompProjectedCurve_swigregister = _ProjLib.Handle_ProjLib_HCompProjectedCurve_swigregister
Handle_ProjLib_HCompProjectedCurve_swigregister(Handle_ProjLib_HCompProjectedCurve)

def Handle_ProjLib_HCompProjectedCurve_DownCast(*args):
  return _ProjLib.Handle_ProjLib_HCompProjectedCurve_DownCast(*args)
Handle_ProjLib_HCompProjectedCurve_DownCast = _ProjLib.Handle_ProjLib_HCompProjectedCurve_DownCast

class ProjLib_HProjectedCurve(OCC.Adaptor2d.Adaptor2d_HCurve2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        :param C:
        :type C: ProjLib_ProjectedCurve &
        :rtype: None

        """
        _ProjLib.ProjLib_HProjectedCurve_swiginit(self,_ProjLib.new_ProjLib_HProjectedCurve(*args))
    def Set(self, *args):
        """
        :param C:
        :type C: ProjLib_ProjectedCurve &
        :rtype: None

        """
        return _ProjLib.ProjLib_HProjectedCurve_Set(self, *args)

    def ChangeCurve2d(self, *args):
        """
        :rtype: ProjLib_ProjectedCurve

        """
        return _ProjLib.ProjLib_HProjectedCurve_ChangeCurve2d(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_ProjLib_HProjectedCurve(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _ProjLib.delete_ProjLib_HProjectedCurve
ProjLib_HProjectedCurve.Set = new_instancemethod(_ProjLib.ProjLib_HProjectedCurve_Set,None,ProjLib_HProjectedCurve)
ProjLib_HProjectedCurve.ChangeCurve2d = new_instancemethod(_ProjLib.ProjLib_HProjectedCurve_ChangeCurve2d,None,ProjLib_HProjectedCurve)
ProjLib_HProjectedCurve_swigregister = _ProjLib.ProjLib_HProjectedCurve_swigregister
ProjLib_HProjectedCurve_swigregister(ProjLib_HProjectedCurve)

class Handle_ProjLib_HProjectedCurve(OCC.Adaptor2d.Handle_Adaptor2d_HCurve2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _ProjLib.Handle_ProjLib_HProjectedCurve_swiginit(self,_ProjLib.new_Handle_ProjLib_HProjectedCurve(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_ProjLib.Handle_ProjLib_HProjectedCurve_DownCast)
    __swig_destroy__ = _ProjLib.delete_Handle_ProjLib_HProjectedCurve
Handle_ProjLib_HProjectedCurve.Nullify = new_instancemethod(_ProjLib.Handle_ProjLib_HProjectedCurve_Nullify,None,Handle_ProjLib_HProjectedCurve)
Handle_ProjLib_HProjectedCurve.IsNull = new_instancemethod(_ProjLib.Handle_ProjLib_HProjectedCurve_IsNull,None,Handle_ProjLib_HProjectedCurve)
Handle_ProjLib_HProjectedCurve.GetObject = new_instancemethod(_ProjLib.Handle_ProjLib_HProjectedCurve_GetObject,None,Handle_ProjLib_HProjectedCurve)
Handle_ProjLib_HProjectedCurve_swigregister = _ProjLib.Handle_ProjLib_HProjectedCurve_swigregister
Handle_ProjLib_HProjectedCurve_swigregister(Handle_ProjLib_HProjectedCurve)

def Handle_ProjLib_HProjectedCurve_DownCast(*args):
  return _ProjLib.Handle_ProjLib_HProjectedCurve_DownCast(*args)
Handle_ProjLib_HProjectedCurve_DownCast = _ProjLib.Handle_ProjLib_HProjectedCurve_DownCast

class ProjLib_HSequenceOfHSequenceOfPnt(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        """
        _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_swiginit(self,_ProjLib.new_ProjLib_HSequenceOfHSequenceOfPnt(*args))
    def IsEmpty(self, *args):
        """
        :rtype: bool

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_IsEmpty(self, *args)

    def Length(self, *args):
        """
        :rtype: int

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Length(self, *args)

    def Clear(self, *args):
        """
        :rtype: None

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Clear(self, *args)

    def Append(self, *args):
        """
        :param anItem:
        :type anItem: Handle_TColgp_HSequenceOfPnt
        :rtype: None

        :param aSequence:
        :type aSequence: Handle_ProjLib_HSequenceOfHSequenceOfPnt &
        :rtype: None

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Append(self, *args)

    def Prepend(self, *args):
        """
        :param anItem:
        :type anItem: Handle_TColgp_HSequenceOfPnt
        :rtype: None

        :param aSequence:
        :type aSequence: Handle_ProjLib_HSequenceOfHSequenceOfPnt &
        :rtype: None

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Prepend(self, *args)

    def Reverse(self, *args):
        """
        :rtype: None

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Reverse(self, *args)

    def InsertBefore(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :param anItem:
        :type anItem: Handle_TColgp_HSequenceOfPnt
        :rtype: None

        :param anIndex:
        :type anIndex: int
        :param aSequence:
        :type aSequence: Handle_ProjLib_HSequenceOfHSequenceOfPnt &
        :rtype: None

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_InsertBefore(self, *args)

    def InsertAfter(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :param anItem:
        :type anItem: Handle_TColgp_HSequenceOfPnt
        :rtype: None

        :param anIndex:
        :type anIndex: int
        :param aSequence:
        :type aSequence: Handle_ProjLib_HSequenceOfHSequenceOfPnt &
        :rtype: None

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_InsertAfter(self, *args)

    def Exchange(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :param anOtherIndex:
        :type anOtherIndex: int
        :rtype: None

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Exchange(self, *args)

    def Split(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :rtype: Handle_ProjLib_HSequenceOfHSequenceOfPnt

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Split(self, *args)

    def SetValue(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :param anItem:
        :type anItem: Handle_TColgp_HSequenceOfPnt
        :rtype: None

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_SetValue(self, *args)

    def Value(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :rtype: Handle_TColgp_HSequenceOfPnt

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Value(self, *args)

    def ChangeValue(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :rtype: Handle_TColgp_HSequenceOfPnt

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_ChangeValue(self, *args)

    def Remove(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :rtype: None

        :param fromIndex:
        :type fromIndex: int
        :param toIndex:
        :type toIndex: int
        :rtype: None

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Remove(self, *args)

    def Sequence(self, *args):
        """
        :rtype: ProjLib_SequenceOfHSequenceOfPnt

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Sequence(self, *args)

    def ChangeSequence(self, *args):
        """
        :rtype: ProjLib_SequenceOfHSequenceOfPnt

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_ChangeSequence(self, *args)

    def ShallowCopy(self, *args):
        """
        :rtype: Handle_ProjLib_HSequenceOfHSequenceOfPnt

        """
        return _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_ShallowCopy(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_ProjLib_HSequenceOfHSequenceOfPnt(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _ProjLib.delete_ProjLib_HSequenceOfHSequenceOfPnt
ProjLib_HSequenceOfHSequenceOfPnt.IsEmpty = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_IsEmpty,None,ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.Length = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Length,None,ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.Clear = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Clear,None,ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.Append = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Append,None,ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.Prepend = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Prepend,None,ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.Reverse = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Reverse,None,ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.InsertBefore = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_InsertBefore,None,ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.InsertAfter = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_InsertAfter,None,ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.Exchange = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Exchange,None,ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.Split = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Split,None,ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.SetValue = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_SetValue,None,ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.Value = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Value,None,ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.ChangeValue = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_ChangeValue,None,ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.Remove = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Remove,None,ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.Sequence = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_Sequence,None,ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.ChangeSequence = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_ChangeSequence,None,ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt.ShallowCopy = new_instancemethod(_ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_ShallowCopy,None,ProjLib_HSequenceOfHSequenceOfPnt)
ProjLib_HSequenceOfHSequenceOfPnt_swigregister = _ProjLib.ProjLib_HSequenceOfHSequenceOfPnt_swigregister
ProjLib_HSequenceOfHSequenceOfPnt_swigregister(ProjLib_HSequenceOfHSequenceOfPnt)

class Handle_ProjLib_HSequenceOfHSequenceOfPnt(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_swiginit(self,_ProjLib.new_Handle_ProjLib_HSequenceOfHSequenceOfPnt(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_DownCast)
    __swig_destroy__ = _ProjLib.delete_Handle_ProjLib_HSequenceOfHSequenceOfPnt
Handle_ProjLib_HSequenceOfHSequenceOfPnt.Nullify = new_instancemethod(_ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_Nullify,None,Handle_ProjLib_HSequenceOfHSequenceOfPnt)
Handle_ProjLib_HSequenceOfHSequenceOfPnt.IsNull = new_instancemethod(_ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_IsNull,None,Handle_ProjLib_HSequenceOfHSequenceOfPnt)
Handle_ProjLib_HSequenceOfHSequenceOfPnt.GetObject = new_instancemethod(_ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_GetObject,None,Handle_ProjLib_HSequenceOfHSequenceOfPnt)
Handle_ProjLib_HSequenceOfHSequenceOfPnt_swigregister = _ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_swigregister
Handle_ProjLib_HSequenceOfHSequenceOfPnt_swigregister(Handle_ProjLib_HSequenceOfHSequenceOfPnt)

def Handle_ProjLib_HSequenceOfHSequenceOfPnt_DownCast(*args):
  return _ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_DownCast(*args)
Handle_ProjLib_HSequenceOfHSequenceOfPnt_DownCast = _ProjLib.Handle_ProjLib_HSequenceOfHSequenceOfPnt_DownCast

class ProjLib_PrjFunc(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param C:
        :type C: Adaptor3d_CurvePtr &
        :param FixVal:
        :type FixVal: float
        :param S:
        :type S: Adaptor3d_SurfacePtr &
        :param Fix:
        :type Fix: int
        :rtype: None

        """
        _ProjLib.ProjLib_PrjFunc_swiginit(self,_ProjLib.new_ProjLib_PrjFunc(*args))
    def NbVariables(self, *args):
        """
        * returns the number of variables of the function.

        :rtype: int

        """
        return _ProjLib.ProjLib_PrjFunc_NbVariables(self, *args)

    def NbEquations(self, *args):
        """
        * returns the number of equations of the function.

        :rtype: int

        """
        return _ProjLib.ProjLib_PrjFunc_NbEquations(self, *args)

    def Value(self, *args):
        """
        * computes the values <F> of the Functions for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :rtype: bool

        """
        return _ProjLib.ProjLib_PrjFunc_Value(self, *args)

    def Derivatives(self, *args):
        """
        * returns the values <D> of the derivatives for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _ProjLib.ProjLib_PrjFunc_Derivatives(self, *args)

    def Values(self, *args):
        """
        * returns the values <F> of the functions and the derivatives <D> for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _ProjLib.ProjLib_PrjFunc_Values(self, *args)

    def Solution(self, *args):
        """
        * returns point on surface

        :rtype: gp_Pnt2d

        """
        return _ProjLib.ProjLib_PrjFunc_Solution(self, *args)

    __swig_destroy__ = _ProjLib.delete_ProjLib_PrjFunc
ProjLib_PrjFunc.NbVariables = new_instancemethod(_ProjLib.ProjLib_PrjFunc_NbVariables,None,ProjLib_PrjFunc)
ProjLib_PrjFunc.NbEquations = new_instancemethod(_ProjLib.ProjLib_PrjFunc_NbEquations,None,ProjLib_PrjFunc)
ProjLib_PrjFunc.Value = new_instancemethod(_ProjLib.ProjLib_PrjFunc_Value,None,ProjLib_PrjFunc)
ProjLib_PrjFunc.Derivatives = new_instancemethod(_ProjLib.ProjLib_PrjFunc_Derivatives,None,ProjLib_PrjFunc)
ProjLib_PrjFunc.Values = new_instancemethod(_ProjLib.ProjLib_PrjFunc_Values,None,ProjLib_PrjFunc)
ProjLib_PrjFunc.Solution = new_instancemethod(_ProjLib.ProjLib_PrjFunc_Solution,None,ProjLib_PrjFunc)
ProjLib_PrjFunc_swigregister = _ProjLib.ProjLib_PrjFunc_swigregister
ProjLib_PrjFunc_swigregister(ProjLib_PrjFunc)

class ProjLib_PrjResolve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param C:
        :type C: Adaptor3d_Curve &
        :param S:
        :type S: Adaptor3d_Surface &
        :param Fix:
        :type Fix: int
        :rtype: None

        """
        _ProjLib.ProjLib_PrjResolve_swiginit(self,_ProjLib.new_ProjLib_PrjResolve(*args))
    def Perform(self, *args):
        """
        * Calculates the ort from C(t) to S with a close point. The close point is defined by the parameter values U0 and V0. The function F(u,v)=distance(S(u,v),C(t)) has an extremum when gradient(F)=0. The algorithm searchs a zero near the close point.

        :param t:
        :type t: float
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param Tol:
        :type Tol: gp_Pnt2d
        :param Inf:
        :type Inf: gp_Pnt2d
        :param Sup:
        :type Sup: gp_Pnt2d
        :param FTol: default value is -1
        :type FTol: float
        :param StrictInside: default value is Standard_False
        :type StrictInside: bool
        :rtype: None

        """
        return _ProjLib.ProjLib_PrjResolve_Perform(self, *args)

    def IsDone(self, *args):
        """
        * Returns True if the distance is found.

        :rtype: bool

        """
        return _ProjLib.ProjLib_PrjResolve_IsDone(self, *args)

    def Solution(self, *args):
        """
        * Returns the point of the extremum distance.

        :rtype: gp_Pnt2d

        """
        return _ProjLib.ProjLib_PrjResolve_Solution(self, *args)

    __swig_destroy__ = _ProjLib.delete_ProjLib_PrjResolve
ProjLib_PrjResolve.Perform = new_instancemethod(_ProjLib.ProjLib_PrjResolve_Perform,None,ProjLib_PrjResolve)
ProjLib_PrjResolve.IsDone = new_instancemethod(_ProjLib.ProjLib_PrjResolve_IsDone,None,ProjLib_PrjResolve)
ProjLib_PrjResolve.Solution = new_instancemethod(_ProjLib.ProjLib_PrjResolve_Solution,None,ProjLib_PrjResolve)
ProjLib_PrjResolve_swigregister = _ProjLib.ProjLib_PrjResolve_swigregister
ProjLib_PrjResolve_swigregister(ProjLib_PrjResolve)

class ProjLib_ProjectOnPlane(OCC.Adaptor3d.Adaptor3d_Curve):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Empty constructor.

        :rtype: None

        * The projection will be normal to the Plane defined by the Ax3 <Pl>.

        :param Pl:
        :type Pl: gp_Ax3
        :rtype: None

        * The projection will be along the direction <D> on the plane defined by the Ax3 <Pl>. raises if the direction <D> is parallel to the plane <Pl>.

        :param Pl:
        :type Pl: gp_Ax3
        :param D:
        :type D: gp_Dir
        :rtype: None

        """
        _ProjLib.ProjLib_ProjectOnPlane_swiginit(self,_ProjLib.new_ProjLib_ProjectOnPlane(*args))
    def Load(self, *args):
        """
        * Sets the Curve and perform the projection. if <KeepParametrization> is true, the parametrization of the Projected Curve <PC> will be the same as the parametrization of the initial curve <C>. It meens: proj(C(u)) = PC(u) for each u. Otherwize, the parametrization may change.

        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :param Tolerance:
        :type Tolerance: float
        :param KeepParametrization: default value is Standard_True
        :type KeepParametrization: bool
        :rtype: None

        """
        return _ProjLib.ProjLib_ProjectOnPlane_Load(self, *args)

    def GetPlane(self, *args):
        """
        :rtype: gp_Ax3

        """
        return _ProjLib.ProjLib_ProjectOnPlane_GetPlane(self, *args)

    def GetDirection(self, *args):
        """
        :rtype: gp_Dir

        """
        return _ProjLib.ProjLib_ProjectOnPlane_GetDirection(self, *args)

    def GetCurve(self, *args):
        """
        :rtype: Handle_Adaptor3d_HCurve

        """
        return _ProjLib.ProjLib_ProjectOnPlane_GetCurve(self, *args)

    __swig_destroy__ = _ProjLib.delete_ProjLib_ProjectOnPlane
ProjLib_ProjectOnPlane.Load = new_instancemethod(_ProjLib.ProjLib_ProjectOnPlane_Load,None,ProjLib_ProjectOnPlane)
ProjLib_ProjectOnPlane.GetPlane = new_instancemethod(_ProjLib.ProjLib_ProjectOnPlane_GetPlane,None,ProjLib_ProjectOnPlane)
ProjLib_ProjectOnPlane.GetDirection = new_instancemethod(_ProjLib.ProjLib_ProjectOnPlane_GetDirection,None,ProjLib_ProjectOnPlane)
ProjLib_ProjectOnPlane.GetCurve = new_instancemethod(_ProjLib.ProjLib_ProjectOnPlane_GetCurve,None,ProjLib_ProjectOnPlane)
ProjLib_ProjectOnPlane_swigregister = _ProjLib.ProjLib_ProjectOnPlane_swigregister
ProjLib_ProjectOnPlane_swigregister(ProjLib_ProjectOnPlane)

class ProjLib_ProjectOnSurface(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Create an empty projector.

        :rtype: None

        * Create a projector normaly to the surface <S>.

        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :rtype: None

        """
        _ProjLib.ProjLib_ProjectOnSurface_swiginit(self,_ProjLib.new_ProjLib_ProjectOnSurface(*args))
    def Delete(self, *args):
        """
        :rtype: void

        """
        return _ProjLib.ProjLib_ProjectOnSurface_Delete(self, *args)

    def IsDone(self, *args):
        """
        :rtype: bool

        """
        return _ProjLib.ProjLib_ProjectOnSurface_IsDone(self, *args)

    def BSpline(self, *args):
        """
        :rtype: Handle_Geom_BSplineCurve

        """
        return _ProjLib.ProjLib_ProjectOnSurface_BSpline(self, *args)

    __swig_destroy__ = _ProjLib.delete_ProjLib_ProjectOnSurface
ProjLib_ProjectOnSurface.Delete = new_instancemethod(_ProjLib.ProjLib_ProjectOnSurface_Delete,None,ProjLib_ProjectOnSurface)
ProjLib_ProjectOnSurface.IsDone = new_instancemethod(_ProjLib.ProjLib_ProjectOnSurface_IsDone,None,ProjLib_ProjectOnSurface)
ProjLib_ProjectOnSurface.BSpline = new_instancemethod(_ProjLib.ProjLib_ProjectOnSurface_BSpline,None,ProjLib_ProjectOnSurface)
ProjLib_ProjectOnSurface_swigregister = _ProjLib.ProjLib_ProjectOnSurface_swigregister
ProjLib_ProjectOnSurface_swigregister(ProjLib_ProjectOnSurface)

class ProjLib_ProjectedCurve(OCC.Adaptor2d.Adaptor2d_Curve2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :rtype: None

        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :rtype: None

        :param S:
        :type S: Handle_Adaptor3d_HSurface &
        :param C:
        :type C: Handle_Adaptor3d_HCurve &
        :param Tol:
        :type Tol: float
        :rtype: None

        """
        _ProjLib.ProjLib_ProjectedCurve_swiginit(self,_ProjLib.new_ProjLib_ProjectedCurve(*args))
    def GetSurface(self, *args):
        """
        :rtype: Handle_Adaptor3d_HSurface

        """
        return _ProjLib.ProjLib_ProjectedCurve_GetSurface(self, *args)

    def GetCurve(self, *args):
        """
        :rtype: Handle_Adaptor3d_HCurve

        """
        return _ProjLib.ProjLib_ProjectedCurve_GetCurve(self, *args)

    def GetTolerance(self, *args):
        """
        * returns the tolerance reached if an approximation is Done.

        :rtype: float

        """
        return _ProjLib.ProjLib_ProjectedCurve_GetTolerance(self, *args)

    __swig_destroy__ = _ProjLib.delete_ProjLib_ProjectedCurve
ProjLib_ProjectedCurve.GetSurface = new_instancemethod(_ProjLib.ProjLib_ProjectedCurve_GetSurface,None,ProjLib_ProjectedCurve)
ProjLib_ProjectedCurve.GetCurve = new_instancemethod(_ProjLib.ProjLib_ProjectedCurve_GetCurve,None,ProjLib_ProjectedCurve)
ProjLib_ProjectedCurve.GetTolerance = new_instancemethod(_ProjLib.ProjLib_ProjectedCurve_GetTolerance,None,ProjLib_ProjectedCurve)
ProjLib_ProjectedCurve_swigregister = _ProjLib.ProjLib_ProjectedCurve_swigregister
ProjLib_ProjectedCurve_swigregister(ProjLib_ProjectedCurve)

class ProjLib_Projector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Sets the type to OtherCurve

        :rtype: None

        """
        _ProjLib.ProjLib_Projector_swiginit(self,_ProjLib.new_ProjLib_Projector(*args))
    def Delete(self, *args):
        """
        :rtype: void

        """
        return _ProjLib.ProjLib_Projector_Delete(self, *args)

    def IsDone(self, *args):
        """
        :rtype: bool

        """
        return _ProjLib.ProjLib_Projector_IsDone(self, *args)

    def Done(self, *args):
        """
        * Set isDone = Standard_True;

        :rtype: None

        """
        return _ProjLib.ProjLib_Projector_Done(self, *args)

    def GetType(self, *args):
        """
        :rtype: GeomAbs_CurveType

        """
        return _ProjLib.ProjLib_Projector_GetType(self, *args)

    def SetBSpline(self, *args):
        """
        :param C:
        :type C: Handle_Geom2d_BSplineCurve &
        :rtype: None

        """
        return _ProjLib.ProjLib_Projector_SetBSpline(self, *args)

    def SetBezier(self, *args):
        """
        :param C:
        :type C: Handle_Geom2d_BezierCurve &
        :rtype: None

        """
        return _ProjLib.ProjLib_Projector_SetBezier(self, *args)

    def SetType(self, *args):
        """
        :param Type:
        :type Type: GeomAbs_CurveType
        :rtype: None

        """
        return _ProjLib.ProjLib_Projector_SetType(self, *args)

    def IsPeriodic(self, *args):
        """
        :rtype: bool

        """
        return _ProjLib.ProjLib_Projector_IsPeriodic(self, *args)

    def SetPeriodic(self, *args):
        """
        :rtype: None

        """
        return _ProjLib.ProjLib_Projector_SetPeriodic(self, *args)

    def Line(self, *args):
        """
        :rtype: gp_Lin2d

        """
        return _ProjLib.ProjLib_Projector_Line(self, *args)

    def Circle(self, *args):
        """
        :rtype: gp_Circ2d

        """
        return _ProjLib.ProjLib_Projector_Circle(self, *args)

    def Ellipse(self, *args):
        """
        :rtype: gp_Elips2d

        """
        return _ProjLib.ProjLib_Projector_Ellipse(self, *args)

    def Hyperbola(self, *args):
        """
        :rtype: gp_Hypr2d

        """
        return _ProjLib.ProjLib_Projector_Hyperbola(self, *args)

    def Parabola(self, *args):
        """
        :rtype: gp_Parab2d

        """
        return _ProjLib.ProjLib_Projector_Parabola(self, *args)

    def Bezier(self, *args):
        """
        :rtype: Handle_Geom2d_BezierCurve

        """
        return _ProjLib.ProjLib_Projector_Bezier(self, *args)

    def BSpline(self, *args):
        """
        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _ProjLib.ProjLib_Projector_BSpline(self, *args)

    def Project(self, *args):
        """
        :param L:
        :type L: gp_Lin
        :rtype: void

        :param C:
        :type C: gp_Circ
        :rtype: void

        :param E:
        :type E: gp_Elips
        :rtype: void

        :param P:
        :type P: gp_Parab
        :rtype: void

        :param H:
        :type H: gp_Hypr
        :rtype: void

        """
        return _ProjLib.ProjLib_Projector_Project(self, *args)

    def UFrame(self, *args):
        """
        * Translates the 2d curve to set the part of the curve [CFirst, CLast] in the range [ UFirst, UFirst + Period [

        :param CFirst:
        :type CFirst: float
        :param CLast:
        :type CLast: float
        :param UFirst:
        :type UFirst: float
        :param Period:
        :type Period: float
        :rtype: None

        """
        return _ProjLib.ProjLib_Projector_UFrame(self, *args)

    def VFrame(self, *args):
        """
        * Translates the 2d curve to set the part of the curve [CFirst, CLast] in the range [ VFirst, VFirst + Period [

        :param CFirst:
        :type CFirst: float
        :param CLast:
        :type CLast: float
        :param VFirst:
        :type VFirst: float
        :param Period:
        :type Period: float
        :rtype: None

        """
        return _ProjLib.ProjLib_Projector_VFrame(self, *args)

    __swig_destroy__ = _ProjLib.delete_ProjLib_Projector
ProjLib_Projector.Delete = new_instancemethod(_ProjLib.ProjLib_Projector_Delete,None,ProjLib_Projector)
ProjLib_Projector.IsDone = new_instancemethod(_ProjLib.ProjLib_Projector_IsDone,None,ProjLib_Projector)
ProjLib_Projector.Done = new_instancemethod(_ProjLib.ProjLib_Projector_Done,None,ProjLib_Projector)
ProjLib_Projector.GetType = new_instancemethod(_ProjLib.ProjLib_Projector_GetType,None,ProjLib_Projector)
ProjLib_Projector.SetBSpline = new_instancemethod(_ProjLib.ProjLib_Projector_SetBSpline,None,ProjLib_Projector)
ProjLib_Projector.SetBezier = new_instancemethod(_ProjLib.ProjLib_Projector_SetBezier,None,ProjLib_Projector)
ProjLib_Projector.SetType = new_instancemethod(_ProjLib.ProjLib_Projector_SetType,None,ProjLib_Projector)
ProjLib_Projector.IsPeriodic = new_instancemethod(_ProjLib.ProjLib_Projector_IsPeriodic,None,ProjLib_Projector)
ProjLib_Projector.SetPeriodic = new_instancemethod(_ProjLib.ProjLib_Projector_SetPeriodic,None,ProjLib_Projector)
ProjLib_Projector.Line = new_instancemethod(_ProjLib.ProjLib_Projector_Line,None,ProjLib_Projector)
ProjLib_Projector.Circle = new_instancemethod(_ProjLib.ProjLib_Projector_Circle,None,ProjLib_Projector)
ProjLib_Projector.Ellipse = new_instancemethod(_ProjLib.ProjLib_Projector_Ellipse,None,ProjLib_Projector)
ProjLib_Projector.Hyperbola = new_instancemethod(_ProjLib.ProjLib_Projector_Hyperbola,None,ProjLib_Projector)
ProjLib_Projector.Parabola = new_instancemethod(_ProjLib.ProjLib_Projector_Parabola,None,ProjLib_Projector)
ProjLib_Projector.Bezier = new_instancemethod(_ProjLib.ProjLib_Projector_Bezier,None,ProjLib_Projector)
ProjLib_Projector.BSpline = new_instancemethod(_ProjLib.ProjLib_Projector_BSpline,None,ProjLib_Projector)
ProjLib_Projector.Project = new_instancemethod(_ProjLib.ProjLib_Projector_Project,None,ProjLib_Projector)
ProjLib_Projector.UFrame = new_instancemethod(_ProjLib.ProjLib_Projector_UFrame,None,ProjLib_Projector)
ProjLib_Projector.VFrame = new_instancemethod(_ProjLib.ProjLib_Projector_VFrame,None,ProjLib_Projector)
ProjLib_Projector_swigregister = _ProjLib.ProjLib_Projector_swigregister
ProjLib_Projector_swigregister(ProjLib_Projector)

class ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt(OCC.TCollection.TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param I:
        :type I: Handle_TColgp_HSequenceOfPnt
        :param n:
        :type n: TCollection_SeqNodePtr &
        :param p:
        :type p: TCollection_SeqNodePtr &
        :rtype: None

        """
        _ProjLib.ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_swiginit(self,_ProjLib.new_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt(*args))
    def Value(self, *args):
        """
        :rtype: Handle_TColgp_HSequenceOfPnt

        """
        return _ProjLib.ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_Value(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _ProjLib.delete_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt
ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt.Value = new_instancemethod(_ProjLib.ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_Value,None,ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt)
ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_swigregister = _ProjLib.ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_swigregister
ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_swigregister(ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt)

class Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt(OCC.TCollection.Handle_TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _ProjLib.Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_swiginit(self,_ProjLib.new_Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_ProjLib.Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_DownCast)
    __swig_destroy__ = _ProjLib.delete_Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt
Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt.Nullify = new_instancemethod(_ProjLib.Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_Nullify,None,Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt)
Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt.IsNull = new_instancemethod(_ProjLib.Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_IsNull,None,Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt)
Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt.GetObject = new_instancemethod(_ProjLib.Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_GetObject,None,Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt)
Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_swigregister = _ProjLib.Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_swigregister
Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_swigregister(Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt)

def Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_DownCast(*args):
  return _ProjLib.Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_DownCast(*args)
Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_DownCast = _ProjLib.Handle_ProjLib_SequenceNodeOfSequenceOfHSequenceOfPnt_DownCast

class ProjLib_SequenceOfHSequenceOfPnt(OCC.TCollection.TCollection_BaseSequence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        """
        _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_swiginit(self,_ProjLib.new_ProjLib_SequenceOfHSequenceOfPnt(*args))
    def Clear(self, *args):
        """
        :rtype: None

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Clear(self, *args)

    def Assign(self, *args):
        """
        :param Other:
        :type Other: ProjLib_SequenceOfHSequenceOfPnt &
        :rtype: ProjLib_SequenceOfHSequenceOfPnt

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Assign(self, *args)

    def Set(self, *args):
        """
        :param Other:
        :type Other: ProjLib_SequenceOfHSequenceOfPnt &
        :rtype: ProjLib_SequenceOfHSequenceOfPnt

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Set(self, *args)

    def Append(self, *args):
        """
        :param T:
        :type T: Handle_TColgp_HSequenceOfPnt
        :rtype: None

        :param S:
        :type S: ProjLib_SequenceOfHSequenceOfPnt &
        :rtype: None

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Append(self, *args)

    def Prepend(self, *args):
        """
        :param T:
        :type T: Handle_TColgp_HSequenceOfPnt
        :rtype: None

        :param S:
        :type S: ProjLib_SequenceOfHSequenceOfPnt &
        :rtype: None

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Prepend(self, *args)

    def InsertBefore(self, *args):
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_TColgp_HSequenceOfPnt
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: ProjLib_SequenceOfHSequenceOfPnt &
        :rtype: None

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_InsertBefore(self, *args)

    def InsertAfter(self, *args):
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_TColgp_HSequenceOfPnt
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: ProjLib_SequenceOfHSequenceOfPnt &
        :rtype: None

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_InsertAfter(self, *args)

    def First(self, *args):
        """
        :rtype: Handle_TColgp_HSequenceOfPnt

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_First(self, *args)

    def Last(self, *args):
        """
        :rtype: Handle_TColgp_HSequenceOfPnt

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Last(self, *args)

    def Split(self, *args):
        """
        :param Index:
        :type Index: int
        :param Sub:
        :type Sub: ProjLib_SequenceOfHSequenceOfPnt &
        :rtype: None

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Split(self, *args)

    def Value(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_TColgp_HSequenceOfPnt

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Value(self, *args)

    def SetValue(self, *args):
        """
        :param Index:
        :type Index: int
        :param I:
        :type I: Handle_TColgp_HSequenceOfPnt
        :rtype: None

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_SetValue(self, *args)

    def ChangeValue(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_TColgp_HSequenceOfPnt

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_ChangeValue(self, *args)

    def Remove(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: None

        :param FromIndex:
        :type FromIndex: int
        :param ToIndex:
        :type ToIndex: int
        :rtype: None

        """
        return _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Remove(self, *args)

    __swig_destroy__ = _ProjLib.delete_ProjLib_SequenceOfHSequenceOfPnt
ProjLib_SequenceOfHSequenceOfPnt.Clear = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Clear,None,ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Assign = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Assign,None,ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Set = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Set,None,ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Append = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Append,None,ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Prepend = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Prepend,None,ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.InsertBefore = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_InsertBefore,None,ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.InsertAfter = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_InsertAfter,None,ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.First = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_First,None,ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Last = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Last,None,ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Split = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Split,None,ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Value = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Value,None,ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.SetValue = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_SetValue,None,ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.ChangeValue = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_ChangeValue,None,ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt.Remove = new_instancemethod(_ProjLib.ProjLib_SequenceOfHSequenceOfPnt_Remove,None,ProjLib_SequenceOfHSequenceOfPnt)
ProjLib_SequenceOfHSequenceOfPnt_swigregister = _ProjLib.ProjLib_SequenceOfHSequenceOfPnt_swigregister
ProjLib_SequenceOfHSequenceOfPnt_swigregister(ProjLib_SequenceOfHSequenceOfPnt)

class ProjLib_Cone(ProjLib_Projector):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Undefined projection.

        :rtype: None

        * Projection on the cone <Co>.

        :param Co:
        :type Co: gp_Cone
        :rtype: None

        * Projection of the line <L> on the cone <Co>.

        :param Co:
        :type Co: gp_Cone
        :param L:
        :type L: gp_Lin
        :rtype: None

        * Projection of the circle <C> on the cone <Co>.

        :param Co:
        :type Co: gp_Cone
        :param C:
        :type C: gp_Circ
        :rtype: None

        """
        _ProjLib.ProjLib_Cone_swiginit(self,_ProjLib.new_ProjLib_Cone(*args))
    def Init(self, *args):
        """
        :param Co:
        :type Co: gp_Cone
        :rtype: None

        """
        return _ProjLib.ProjLib_Cone_Init(self, *args)

    def Project(self, *args):
        """
        :param L:
        :type L: gp_Lin
        :rtype: void

        :param C:
        :type C: gp_Circ
        :rtype: void

        :param E:
        :type E: gp_Elips
        :rtype: void

        :param P:
        :type P: gp_Parab
        :rtype: void

        :param H:
        :type H: gp_Hypr
        :rtype: void

        """
        return _ProjLib.ProjLib_Cone_Project(self, *args)

    __swig_destroy__ = _ProjLib.delete_ProjLib_Cone
ProjLib_Cone.Init = new_instancemethod(_ProjLib.ProjLib_Cone_Init,None,ProjLib_Cone)
ProjLib_Cone.Project = new_instancemethod(_ProjLib.ProjLib_Cone_Project,None,ProjLib_Cone)
ProjLib_Cone_swigregister = _ProjLib.ProjLib_Cone_swigregister
ProjLib_Cone_swigregister(ProjLib_Cone)

class ProjLib_Cylinder(ProjLib_Projector):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Undefined projection.

        :rtype: None

        * Projection on the cylinder <Cyl>.

        :param Cyl:
        :type Cyl: gp_Cylinder
        :rtype: None

        * Projection of the line <L> on the cylinder <Cyl>.

        :param Cyl:
        :type Cyl: gp_Cylinder
        :param L:
        :type L: gp_Lin
        :rtype: None

        * Projection of the circle <C> on the cylinder <Cyl>.

        :param Cyl:
        :type Cyl: gp_Cylinder
        :param C:
        :type C: gp_Circ
        :rtype: None

        * Projection of the ellipse <E> on the cylinder <Cyl>.

        :param Cyl:
        :type Cyl: gp_Cylinder
        :param E:
        :type E: gp_Elips
        :rtype: None

        """
        _ProjLib.ProjLib_Cylinder_swiginit(self,_ProjLib.new_ProjLib_Cylinder(*args))
    def Init(self, *args):
        """
        :param Cyl:
        :type Cyl: gp_Cylinder
        :rtype: None

        """
        return _ProjLib.ProjLib_Cylinder_Init(self, *args)

    def Project(self, *args):
        """
        :param L:
        :type L: gp_Lin
        :rtype: void

        :param C:
        :type C: gp_Circ
        :rtype: void

        :param E:
        :type E: gp_Elips
        :rtype: void

        :param P:
        :type P: gp_Parab
        :rtype: void

        :param H:
        :type H: gp_Hypr
        :rtype: void

        """
        return _ProjLib.ProjLib_Cylinder_Project(self, *args)

    __swig_destroy__ = _ProjLib.delete_ProjLib_Cylinder
ProjLib_Cylinder.Init = new_instancemethod(_ProjLib.ProjLib_Cylinder_Init,None,ProjLib_Cylinder)
ProjLib_Cylinder.Project = new_instancemethod(_ProjLib.ProjLib_Cylinder_Project,None,ProjLib_Cylinder)
ProjLib_Cylinder_swigregister = _ProjLib.ProjLib_Cylinder_swigregister
ProjLib_Cylinder_swigregister(ProjLib_Cylinder)

class ProjLib_Plane(ProjLib_Projector):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Undefined projection.

        :rtype: None

        * Projection on the plane <Pl>.

        :param Pl:
        :type Pl: gp_Pln
        :rtype: None

        * Projection of the line <L> on the plane <Pl>.

        :param Pl:
        :type Pl: gp_Pln
        :param L:
        :type L: gp_Lin
        :rtype: None

        * Projection of the circle <C> on the plane <Pl>.

        :param Pl:
        :type Pl: gp_Pln
        :param C:
        :type C: gp_Circ
        :rtype: None

        * Projection of the ellipse <E> on the plane <Pl>.

        :param Pl:
        :type Pl: gp_Pln
        :param E:
        :type E: gp_Elips
        :rtype: None

        * Projection of the parabola <P> on the plane <Pl>.

        :param Pl:
        :type Pl: gp_Pln
        :param P:
        :type P: gp_Parab
        :rtype: None

        * Projection of the hyperbola <H> on the plane <Pl>.

        :param Pl:
        :type Pl: gp_Pln
        :param H:
        :type H: gp_Hypr
        :rtype: None

        """
        _ProjLib.ProjLib_Plane_swiginit(self,_ProjLib.new_ProjLib_Plane(*args))
    def Init(self, *args):
        """
        :param Pl:
        :type Pl: gp_Pln
        :rtype: None

        """
        return _ProjLib.ProjLib_Plane_Init(self, *args)

    def Project(self, *args):
        """
        :param L:
        :type L: gp_Lin
        :rtype: void

        :param C:
        :type C: gp_Circ
        :rtype: void

        :param E:
        :type E: gp_Elips
        :rtype: void

        :param P:
        :type P: gp_Parab
        :rtype: void

        :param H:
        :type H: gp_Hypr
        :rtype: void

        """
        return _ProjLib.ProjLib_Plane_Project(self, *args)

    __swig_destroy__ = _ProjLib.delete_ProjLib_Plane
ProjLib_Plane.Init = new_instancemethod(_ProjLib.ProjLib_Plane_Init,None,ProjLib_Plane)
ProjLib_Plane.Project = new_instancemethod(_ProjLib.ProjLib_Plane_Project,None,ProjLib_Plane)
ProjLib_Plane_swigregister = _ProjLib.ProjLib_Plane_swigregister
ProjLib_Plane_swigregister(ProjLib_Plane)

class ProjLib_Sphere(ProjLib_Projector):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Undefined projection.

        :rtype: None

        * Projection on the sphere <Sp>.

        :param Sp:
        :type Sp: gp_Sphere
        :rtype: None

        * Projection of the circle <C> on the sphere <Sp>.

        :param Sp:
        :type Sp: gp_Sphere
        :param C:
        :type C: gp_Circ
        :rtype: None

        """
        _ProjLib.ProjLib_Sphere_swiginit(self,_ProjLib.new_ProjLib_Sphere(*args))
    def Init(self, *args):
        """
        :param Sp:
        :type Sp: gp_Sphere
        :rtype: None

        """
        return _ProjLib.ProjLib_Sphere_Init(self, *args)

    def Project(self, *args):
        """
        :param L:
        :type L: gp_Lin
        :rtype: void

        :param C:
        :type C: gp_Circ
        :rtype: void

        :param E:
        :type E: gp_Elips
        :rtype: void

        :param P:
        :type P: gp_Parab
        :rtype: void

        :param H:
        :type H: gp_Hypr
        :rtype: void

        """
        return _ProjLib.ProjLib_Sphere_Project(self, *args)

    def SetInBounds(self, *args):
        """
        * Set the point of parameter U on C in the natural restrictions of the sphere.

        :param U:
        :type U: float
        :rtype: None

        """
        return _ProjLib.ProjLib_Sphere_SetInBounds(self, *args)

    __swig_destroy__ = _ProjLib.delete_ProjLib_Sphere
ProjLib_Sphere.Init = new_instancemethod(_ProjLib.ProjLib_Sphere_Init,None,ProjLib_Sphere)
ProjLib_Sphere.Project = new_instancemethod(_ProjLib.ProjLib_Sphere_Project,None,ProjLib_Sphere)
ProjLib_Sphere.SetInBounds = new_instancemethod(_ProjLib.ProjLib_Sphere_SetInBounds,None,ProjLib_Sphere)
ProjLib_Sphere_swigregister = _ProjLib.ProjLib_Sphere_swigregister
ProjLib_Sphere_swigregister(ProjLib_Sphere)

class ProjLib_Torus(ProjLib_Projector):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Undefined projection.

        :rtype: None

        * Projection on the torus <To>.

        :param To:
        :type To: gp_Torus
        :rtype: None

        * Projection of the circle <C> on the torus <To>.

        :param To:
        :type To: gp_Torus
        :param C:
        :type C: gp_Circ
        :rtype: None

        """
        _ProjLib.ProjLib_Torus_swiginit(self,_ProjLib.new_ProjLib_Torus(*args))
    def Init(self, *args):
        """
        :param To:
        :type To: gp_Torus
        :rtype: None

        """
        return _ProjLib.ProjLib_Torus_Init(self, *args)

    def Project(self, *args):
        """
        :param L:
        :type L: gp_Lin
        :rtype: void

        :param C:
        :type C: gp_Circ
        :rtype: void

        :param E:
        :type E: gp_Elips
        :rtype: void

        :param P:
        :type P: gp_Parab
        :rtype: void

        :param H:
        :type H: gp_Hypr
        :rtype: void

        """
        return _ProjLib.ProjLib_Torus_Project(self, *args)

    __swig_destroy__ = _ProjLib.delete_ProjLib_Torus
ProjLib_Torus.Init = new_instancemethod(_ProjLib.ProjLib_Torus_Init,None,ProjLib_Torus)
ProjLib_Torus.Project = new_instancemethod(_ProjLib.ProjLib_Torus_Project,None,ProjLib_Torus)
ProjLib_Torus_swigregister = _ProjLib.ProjLib_Torus_swigregister
ProjLib_Torus_swigregister(ProjLib_Torus)



