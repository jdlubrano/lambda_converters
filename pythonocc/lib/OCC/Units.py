# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _Units.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Units', [dirname(__file__)])
        except ImportError:
            import _Units
            return _Units
        if fp is not None:
            try:
                _mod = imp.load_module('_Units', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _Units = swig_import_helper()
    del swig_import_helper
else:
    import _Units
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Units.delete_SwigPyIterator
    def __iter__(self): return self
SwigPyIterator.value = new_instancemethod(_Units.SwigPyIterator_value,None,SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_Units.SwigPyIterator_incr,None,SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_Units.SwigPyIterator_decr,None,SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_Units.SwigPyIterator_distance,None,SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_Units.SwigPyIterator_equal,None,SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_Units.SwigPyIterator_copy,None,SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_Units.SwigPyIterator_next,None,SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_Units.SwigPyIterator___next__,None,SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_Units.SwigPyIterator_previous,None,SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_Units.SwigPyIterator_advance,None,SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_Units.SwigPyIterator___eq__,None,SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_Units.SwigPyIterator___ne__,None,SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_Units.SwigPyIterator___iadd__,None,SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_Units.SwigPyIterator___isub__,None,SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_Units.SwigPyIterator___add__,None,SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_Units.SwigPyIterator___sub__,None,SwigPyIterator)
SwigPyIterator_swigregister = _Units.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import OCC.Standard
import OCC.TCollection
import OCC.MMgt
import OCC.TColStd
def register_handle(handle, base_object):
    """
    Inserts the handle into the base object to
    prevent memory corruption in certain cases
    """
    try:
        if base_object.IsKind("Standard_Transient"):
            base_object.thisHandle = handle
            base_object.thisown = False
    except:
        pass

class units(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def UnitsFile(*args):
        """
        * Defines the location of the file containing all the information useful in creating the dictionary of all the units known to the system.

        :param afile:
        :type afile: char *
        :rtype: void

        """
        return _Units.units_UnitsFile(*args)

    UnitsFile = staticmethod(UnitsFile)
    def LexiconFile(*args):
        """
        * Defines the location of the file containing the lexicon useful in manipulating composite units.

        :param afile:
        :type afile: char *
        :rtype: void

        """
        return _Units.units_LexiconFile(*args)

    LexiconFile = staticmethod(LexiconFile)
    def DictionaryOfUnits(*args):
        """
        * Returns a unique instance of the dictionary of units. If <amode> is True, then it forces the recomputation of the dictionary of units.

        :param amode: default value is Standard_False
        :type amode: bool
        :rtype: Handle_Units_UnitsDictionary

        """
        return _Units.units_DictionaryOfUnits(*args)

    DictionaryOfUnits = staticmethod(DictionaryOfUnits)
    def Quantity(*args):
        """
        * Returns a unique quantity instance corresponding to <aquantity>.

        :param aquantity:
        :type aquantity: char *
        :rtype: Handle_Units_Quantity

        """
        return _Units.units_Quantity(*args)

    Quantity = staticmethod(Quantity)
    def FirstQuantity(*args):
        """
        * Returns the first quantity string founded from the unit <aUnit>.

        :param aunit:
        :type aunit: char *
        :rtype: char *

        """
        return _Units.units_FirstQuantity(*args)

    FirstQuantity = staticmethod(FirstQuantity)
    def LexiconUnits(*args):
        """
        * Returns a unique instance of the Units_Lexicon. If <amode> is True, it forces the recomputation of the dictionary of units, and by consequence the completion of the Units_Lexicon.

        :param amode: default value is Standard_True
        :type amode: bool
        :rtype: Handle_Units_Lexicon

        """
        return _Units.units_LexiconUnits(*args)

    LexiconUnits = staticmethod(LexiconUnits)
    def LexiconFormula(*args):
        """
        * Return a unique instance of LexiconFormula.

        :rtype: Handle_Units_Lexicon

        """
        return _Units.units_LexiconFormula(*args)

    LexiconFormula = staticmethod(LexiconFormula)
    def NullDimensions(*args):
        """
        * Returns always the same instance of Dimensions.

        :rtype: Handle_Units_Dimensions

        """
        return _Units.units_NullDimensions(*args)

    NullDimensions = staticmethod(NullDimensions)
    def Convert(*args):
        """
        * Converts <avalue> expressed in <afirstunit> into the <asecondunit>.

        :param avalue:
        :type avalue: float
        :param afirstunit:
        :type afirstunit: char *
        :param asecondunit:
        :type asecondunit: char *
        :rtype: float

        """
        return _Units.units_Convert(*args)

    Convert = staticmethod(Convert)
    def ToSI(*args):
        """
        :param aData:
        :type aData: float
        :param aUnit:
        :type aUnit: char *
        :rtype: float

        :param aData:
        :type aData: float
        :param aUnit:
        :type aUnit: char *
        :param aDim:
        :type aDim: Handle_Units_Dimensions &
        :rtype: float

        """
        return _Units.units_ToSI(*args)

    ToSI = staticmethod(ToSI)
    def FromSI(*args):
        """
        :param aData:
        :type aData: float
        :param aUnit:
        :type aUnit: char *
        :rtype: float

        :param aData:
        :type aData: float
        :param aUnit:
        :type aUnit: char *
        :param aDim:
        :type aDim: Handle_Units_Dimensions &
        :rtype: float

        """
        return _Units.units_FromSI(*args)

    FromSI = staticmethod(FromSI)
    def Dimensions(*args):
        """
        * return the dimension associated to the Type

        :param aType:
        :type aType: char *
        :rtype: Handle_Units_Dimensions

        """
        return _Units.units_Dimensions(*args)

    Dimensions = staticmethod(Dimensions)
    def __init__(self): 
        _Units.units_swiginit(self,_Units.new_units())
    __swig_destroy__ = _Units.delete_units
units_swigregister = _Units.units_swigregister
units_swigregister(units)

def units_UnitsFile(*args):
  """
    * Defines the location of the file containing all the information useful in creating the dictionary of all the units known to the system.

    :param afile:
    :type afile: char *
    :rtype: void

    """
  return _Units.units_UnitsFile(*args)

def units_LexiconFile(*args):
  """
    * Defines the location of the file containing the lexicon useful in manipulating composite units.

    :param afile:
    :type afile: char *
    :rtype: void

    """
  return _Units.units_LexiconFile(*args)

def units_DictionaryOfUnits(*args):
  """
    * Returns a unique instance of the dictionary of units. If <amode> is True, then it forces the recomputation of the dictionary of units.

    :param amode: default value is Standard_False
    :type amode: bool
    :rtype: Handle_Units_UnitsDictionary

    """
  return _Units.units_DictionaryOfUnits(*args)

def units_Quantity(*args):
  """
    * Returns a unique quantity instance corresponding to <aquantity>.

    :param aquantity:
    :type aquantity: char *
    :rtype: Handle_Units_Quantity

    """
  return _Units.units_Quantity(*args)

def units_FirstQuantity(*args):
  """
    * Returns the first quantity string founded from the unit <aUnit>.

    :param aunit:
    :type aunit: char *
    :rtype: char *

    """
  return _Units.units_FirstQuantity(*args)

def units_LexiconUnits(*args):
  """
    * Returns a unique instance of the Units_Lexicon. If <amode> is True, it forces the recomputation of the dictionary of units, and by consequence the completion of the Units_Lexicon.

    :param amode: default value is Standard_True
    :type amode: bool
    :rtype: Handle_Units_Lexicon

    """
  return _Units.units_LexiconUnits(*args)

def units_LexiconFormula(*args):
  """
    * Return a unique instance of LexiconFormula.

    :rtype: Handle_Units_Lexicon

    """
  return _Units.units_LexiconFormula(*args)

def units_NullDimensions(*args):
  """
    * Returns always the same instance of Dimensions.

    :rtype: Handle_Units_Dimensions

    """
  return _Units.units_NullDimensions(*args)

def units_Convert(*args):
  """
    * Converts <avalue> expressed in <afirstunit> into the <asecondunit>.

    :param avalue:
    :type avalue: float
    :param afirstunit:
    :type afirstunit: char *
    :param asecondunit:
    :type asecondunit: char *
    :rtype: float

    """
  return _Units.units_Convert(*args)

def units_ToSI(*args):
  """
    :param aData:
    :type aData: float
    :param aUnit:
    :type aUnit: char *
    :rtype: float

    :param aData:
    :type aData: float
    :param aUnit:
    :type aUnit: char *
    :param aDim:
    :type aDim: Handle_Units_Dimensions &
    :rtype: float

    """
  return _Units.units_ToSI(*args)

def units_FromSI(*args):
  """
    :param aData:
    :type aData: float
    :param aUnit:
    :type aUnit: char *
    :rtype: float

    :param aData:
    :type aData: float
    :param aUnit:
    :type aUnit: char *
    :param aDim:
    :type aDim: Handle_Units_Dimensions &
    :rtype: float

    """
  return _Units.units_FromSI(*args)

def units_Dimensions(*args):
  """
    * return the dimension associated to the Type

    :param aType:
    :type aType: char *
    :rtype: Handle_Units_Dimensions

    """
  return _Units.units_Dimensions(*args)

class Units_Explorer(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Empty contructor of the class.

        :rtype: None

        * Creates a new instance of the class, initialized with the UnitsSystem <aunitssystem>.

        :param aunitssystem:
        :type aunitssystem: Handle_Units_UnitsSystem &
        :rtype: None

        * Creates a new instance of the class, initialized with the UnitsDictionary <aunitsdictionary>.

        :param aunitsdictionary:
        :type aunitsdictionary: Handle_Units_UnitsDictionary &
        :rtype: None

        * Creates a new instance of the class, initialized with the UnitsSystem <aunitssystem> and positioned at the quantity <aquantity>.

        :param aunitssystem:
        :type aunitssystem: Handle_Units_UnitsSystem &
        :param aquantity:
        :type aquantity: char *
        :rtype: None

        * Creates a new instance of the class, initialized with the UnitsDictionary <aunitsdictionary> and positioned at the quantity <aquantity>.

        :param aunitsdictionary:
        :type aunitsdictionary: Handle_Units_UnitsDictionary &
        :param aquantity:
        :type aquantity: char *
        :rtype: None

        """
        _Units.Units_Explorer_swiginit(self,_Units.new_Units_Explorer(*args))
    def Init(self, *args):
        """
        * Initializes the instance of the class with the UnitsSystem <aunitssystem>.

        :param aunitssystem:
        :type aunitssystem: Handle_Units_UnitsSystem &
        :rtype: None

        * Initializes the instance of the class with the UnitsDictionary <aunitsdictionary>.

        :param aunitsdictionary:
        :type aunitsdictionary: Handle_Units_UnitsDictionary &
        :rtype: None

        * Initializes the instance of the class with the UnitsSystem <aunitssystem> and positioned at the quantity <aquantity>.

        :param aunitssystem:
        :type aunitssystem: Handle_Units_UnitsSystem &
        :param aquantity:
        :type aquantity: char *
        :rtype: None

        * Initializes the instance of the class with the UnitsDictionary <aunitsdictionary> and positioned at the quantity <aquantity>.

        :param aunitsdictionary:
        :type aunitsdictionary: Handle_Units_UnitsDictionary &
        :param aquantity:
        :type aquantity: char *
        :rtype: None

        """
        return _Units.Units_Explorer_Init(self, *args)

    def MoreQuantity(self, *args):
        """
        * Returns True if there is another Quantity to explore, False otherwise.

        :rtype: bool

        """
        return _Units.Units_Explorer_MoreQuantity(self, *args)

    def NextQuantity(self, *args):
        """
        * Sets the next Quantity current.

        :rtype: None

        """
        return _Units.Units_Explorer_NextQuantity(self, *args)

    def Quantity(self, *args):
        """
        * Returns the name of the current Quantity.

        :rtype: TCollection_AsciiString

        """
        return _Units.Units_Explorer_Quantity(self, *args)

    def MoreUnit(self, *args):
        """
        * Returns True if there is another Unit to explore, False otherwise.

        :rtype: bool

        """
        return _Units.Units_Explorer_MoreUnit(self, *args)

    def NextUnit(self, *args):
        """
        * Sets the next Unit current.

        :rtype: None

        """
        return _Units.Units_Explorer_NextUnit(self, *args)

    def Unit(self, *args):
        """
        * Returns the name of the current unit.

        :rtype: TCollection_AsciiString

        """
        return _Units.Units_Explorer_Unit(self, *args)

    def IsActive(self, *args):
        """
        * If the units system to explore is a user system, returns True if the current unit is active, False otherwise.  If the units system to explore is the units dictionary, returns True if the current unit is the S.I. unit.

        :rtype: bool

        """
        return _Units.Units_Explorer_IsActive(self, *args)

    __swig_destroy__ = _Units.delete_Units_Explorer
Units_Explorer.Init = new_instancemethod(_Units.Units_Explorer_Init,None,Units_Explorer)
Units_Explorer.MoreQuantity = new_instancemethod(_Units.Units_Explorer_MoreQuantity,None,Units_Explorer)
Units_Explorer.NextQuantity = new_instancemethod(_Units.Units_Explorer_NextQuantity,None,Units_Explorer)
Units_Explorer.Quantity = new_instancemethod(_Units.Units_Explorer_Quantity,None,Units_Explorer)
Units_Explorer.MoreUnit = new_instancemethod(_Units.Units_Explorer_MoreUnit,None,Units_Explorer)
Units_Explorer.NextUnit = new_instancemethod(_Units.Units_Explorer_NextUnit,None,Units_Explorer)
Units_Explorer.Unit = new_instancemethod(_Units.Units_Explorer_Unit,None,Units_Explorer)
Units_Explorer.IsActive = new_instancemethod(_Units.Units_Explorer_IsActive,None,Units_Explorer)
Units_Explorer_swigregister = _Units.Units_Explorer_swigregister
Units_Explorer_swigregister(Units_Explorer)

class Units_Lexicon(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Creates an empty instance of Lexicon.

        :rtype: None

        """
        _Units.Units_Lexicon_swiginit(self,_Units.new_Units_Lexicon(*args))
    def Creates(self, *args):
        """
        * Reads the file <afilename> to create a sequence of tokens stored in <thesequenceoftokens>.

        :param afilename:
        :type afilename: char *
        :rtype: None

        """
        return _Units.Units_Lexicon_Creates(self, *args)

    def Sequence(self, *args):
        """
        * Returns the first item of the sequence of tokens.

        :rtype: Handle_Units_TokensSequence

        """
        return _Units.Units_Lexicon_Sequence(self, *args)

    def FileName(self, *args):
        """
        * Returns in a AsciiString from TCollection the name of the file.

        :rtype: TCollection_AsciiString

        """
        return _Units.Units_Lexicon_FileName(self, *args)

    def UpToDate(self, *args):
        """
        * Returns true if the file has not changed since the creation of the Lexicon object. Returns false otherwise.

        :rtype: bool

        """
        return _Units.Units_Lexicon_UpToDate(self, *args)

    def AddToken(self, *args):
        """
        * Adds to the lexicon a new token with <aword>, <amean>, <avalue> as arguments. If there is already a token with the field <theword> equal to <aword>, the existing token is updated.

        :param aword:
        :type aword: char *
        :param amean:
        :type amean: char *
        :param avalue:
        :type avalue: float
        :rtype: None

        """
        return _Units.Units_Lexicon_AddToken(self, *args)

    def Dump(self, *args):
        """
        * Useful for debugging.

        :rtype: None

        """
        return _Units.Units_Lexicon_Dump(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Units_Lexicon(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _Units.delete_Units_Lexicon
Units_Lexicon.Creates = new_instancemethod(_Units.Units_Lexicon_Creates,None,Units_Lexicon)
Units_Lexicon.Sequence = new_instancemethod(_Units.Units_Lexicon_Sequence,None,Units_Lexicon)
Units_Lexicon.FileName = new_instancemethod(_Units.Units_Lexicon_FileName,None,Units_Lexicon)
Units_Lexicon.UpToDate = new_instancemethod(_Units.Units_Lexicon_UpToDate,None,Units_Lexicon)
Units_Lexicon.AddToken = new_instancemethod(_Units.Units_Lexicon_AddToken,None,Units_Lexicon)
Units_Lexicon.Dump = new_instancemethod(_Units.Units_Lexicon_Dump,None,Units_Lexicon)
Units_Lexicon_swigregister = _Units.Units_Lexicon_swigregister
Units_Lexicon_swigregister(Units_Lexicon)

class Handle_Units_Lexicon(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _Units.Handle_Units_Lexicon_swiginit(self,_Units.new_Handle_Units_Lexicon(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Units.Handle_Units_Lexicon_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_Lexicon
Handle_Units_Lexicon.Nullify = new_instancemethod(_Units.Handle_Units_Lexicon_Nullify,None,Handle_Units_Lexicon)
Handle_Units_Lexicon.IsNull = new_instancemethod(_Units.Handle_Units_Lexicon_IsNull,None,Handle_Units_Lexicon)
Handle_Units_Lexicon.GetObject = new_instancemethod(_Units.Handle_Units_Lexicon_GetObject,None,Handle_Units_Lexicon)
Handle_Units_Lexicon_swigregister = _Units.Handle_Units_Lexicon_swigregister
Handle_Units_Lexicon_swigregister(Handle_Units_Lexicon)

def Handle_Units_Lexicon_DownCast(*args):
  return _Units.Handle_Units_Lexicon_DownCast(*args)
Handle_Units_Lexicon_DownCast = _Units.Handle_Units_Lexicon_DownCast

class Units_Measurement(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * It is the empty constructor of the class.

        :rtype: None

        * Returns an instance of this class. <avalue> defines the measurement, and <atoken> the token which defines the unit used.

        :param avalue:
        :type avalue: float
        :param atoken:
        :type atoken: Handle_Units_Token &
        :rtype: None

        * Returns an instance of this class. <avalue> defines the measurement, and <aunit> the unit used, described in natural language.

        :param avalue:
        :type avalue: float
        :param aunit:
        :type aunit: char *
        :rtype: None

        """
        _Units.Units_Measurement_swiginit(self,_Units.new_Units_Measurement(*args))
    def Convert(self, *args):
        """
        * Converts (if possible) the measurement object into another unit. <aunit> must have the same dimensionality as the unit contained in the token <thetoken>.

        :param aunit:
        :type aunit: char *
        :rtype: None

        """
        return _Units.Units_Measurement_Convert(self, *args)

    def Integer(self, *args):
        """
        * Returns a Measurement object with the integer value of the measurement contained in <self>.

        :rtype: Units_Measurement

        """
        return _Units.Units_Measurement_Integer(self, *args)

    def Fractional(self, *args):
        """
        * Returns a Measurement object with the fractional value of the measurement contained in <self>.

        :rtype: Units_Measurement

        """
        return _Units.Units_Measurement_Fractional(self, *args)

    def Measurement(self, *args):
        """
        * Returns the value of the measurement.

        :rtype: float

        """
        return _Units.Units_Measurement_Measurement(self, *args)

    def Token(self, *args):
        """
        * Returns the token contained in <self>.

        :rtype: Handle_Units_Token

        """
        return _Units.Units_Measurement_Token(self, *args)

    def Add(self, *args):
        """
        * Returns (if it is possible) a measurement which is the addition of <self> and <ameasurement>. The chosen returned unit is the unit of <self>.

        :param ameasurement:
        :type ameasurement: Units_Measurement &
        :rtype: Units_Measurement

        """
        return _Units.Units_Measurement_Add(self, *args)

    def __add__(self, *args):
        """
        :param ameasurement:
        :type ameasurement: Units_Measurement &
        :rtype: Units_Measurement

        """
        return _Units.Units_Measurement___add__(self, *args)

    def Subtract(self, *args):
        """
        * Returns (if it is possible) a measurement which is the subtraction of <self> and <ameasurement>. The chosen returned unit is the unit of <self>.

        :param ameasurement:
        :type ameasurement: Units_Measurement &
        :rtype: Units_Measurement

        """
        return _Units.Units_Measurement_Subtract(self, *args)

    def __sub__(self, *args):
        """
        :param ameasurement:
        :type ameasurement: Units_Measurement &
        :rtype: Units_Measurement

        """
        return _Units.Units_Measurement___sub__(self, *args)

    def Multiply(self, *args):
        """
        * Returns a measurement which is the multiplication of <self> and <ameasurement>.

        :param ameasurement:
        :type ameasurement: Units_Measurement &
        :rtype: Units_Measurement

        * Returns a measurement which is the multiplication of <self> with the value <avalue>.

        :param avalue:
        :type avalue: float
        :rtype: Units_Measurement

        """
        return _Units.Units_Measurement_Multiply(self, *args)

    def __mul__(self, *args):
        """
        :param ameasurement:
        :type ameasurement: Units_Measurement &
        :rtype: Units_Measurement

        :param avalue:
        :type avalue: float
        :rtype: Units_Measurement

        """
        return _Units.Units_Measurement___mul__(self, *args)

    def Divide(self, *args):
        """
        * Returns a measurement which is the division of <self> by <ameasurement>.

        :param ameasurement:
        :type ameasurement: Units_Measurement &
        :rtype: Units_Measurement

        * Returns a measurement which is the division of <self> by the constant <avalue>.

        :param avalue:
        :type avalue: float
        :rtype: Units_Measurement

        """
        return _Units.Units_Measurement_Divide(self, *args)

    def __div__(self, *args):
        """
        :param ameasurement:
        :type ameasurement: Units_Measurement &
        :rtype: Units_Measurement

        :param avalue:
        :type avalue: float
        :rtype: Units_Measurement

        """
        return _Units.Units_Measurement___div__(self, *args)

    def Power(self, *args):
        """
        * Returns a measurement which is <self> powered <anexponent>.

        :param anexponent:
        :type anexponent: float
        :rtype: Units_Measurement

        """
        return _Units.Units_Measurement_Power(self, *args)

    def HasToken(self, *args):
        """
        :rtype: bool

        """
        return _Units.Units_Measurement_HasToken(self, *args)

    def Dump(self, *args):
        """
        * Useful for debugging.

        :rtype: None

        """
        return _Units.Units_Measurement_Dump(self, *args)

    __swig_destroy__ = _Units.delete_Units_Measurement
Units_Measurement.Convert = new_instancemethod(_Units.Units_Measurement_Convert,None,Units_Measurement)
Units_Measurement.Integer = new_instancemethod(_Units.Units_Measurement_Integer,None,Units_Measurement)
Units_Measurement.Fractional = new_instancemethod(_Units.Units_Measurement_Fractional,None,Units_Measurement)
Units_Measurement.Measurement = new_instancemethod(_Units.Units_Measurement_Measurement,None,Units_Measurement)
Units_Measurement.Token = new_instancemethod(_Units.Units_Measurement_Token,None,Units_Measurement)
Units_Measurement.Add = new_instancemethod(_Units.Units_Measurement_Add,None,Units_Measurement)
Units_Measurement.__add__ = new_instancemethod(_Units.Units_Measurement___add__,None,Units_Measurement)
Units_Measurement.Subtract = new_instancemethod(_Units.Units_Measurement_Subtract,None,Units_Measurement)
Units_Measurement.__sub__ = new_instancemethod(_Units.Units_Measurement___sub__,None,Units_Measurement)
Units_Measurement.Multiply = new_instancemethod(_Units.Units_Measurement_Multiply,None,Units_Measurement)
Units_Measurement.__mul__ = new_instancemethod(_Units.Units_Measurement___mul__,None,Units_Measurement)
Units_Measurement.Divide = new_instancemethod(_Units.Units_Measurement_Divide,None,Units_Measurement)
Units_Measurement.__div__ = new_instancemethod(_Units.Units_Measurement___div__,None,Units_Measurement)
Units_Measurement.Power = new_instancemethod(_Units.Units_Measurement_Power,None,Units_Measurement)
Units_Measurement.HasToken = new_instancemethod(_Units.Units_Measurement_HasToken,None,Units_Measurement)
Units_Measurement.Dump = new_instancemethod(_Units.Units_Measurement_Dump,None,Units_Measurement)
Units_Measurement_swigregister = _Units.Units_Measurement_swigregister
Units_Measurement_swigregister(Units_Measurement)

class Units_QtsSequence(OCC.TCollection.TCollection_BaseSequence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        """
        _Units.Units_QtsSequence_swiginit(self,_Units.new_Units_QtsSequence(*args))
    def Clear(self, *args):
        """
        :rtype: None

        """
        return _Units.Units_QtsSequence_Clear(self, *args)

    def Assign(self, *args):
        """
        :param Other:
        :type Other: Units_QtsSequence &
        :rtype: Units_QtsSequence

        """
        return _Units.Units_QtsSequence_Assign(self, *args)

    def Set(self, *args):
        """
        :param Other:
        :type Other: Units_QtsSequence &
        :rtype: Units_QtsSequence

        """
        return _Units.Units_QtsSequence_Set(self, *args)

    def Append(self, *args):
        """
        :param T:
        :type T: Handle_Units_Quantity &
        :rtype: None

        :param S:
        :type S: Units_QtsSequence &
        :rtype: None

        """
        return _Units.Units_QtsSequence_Append(self, *args)

    def Prepend(self, *args):
        """
        :param T:
        :type T: Handle_Units_Quantity &
        :rtype: None

        :param S:
        :type S: Units_QtsSequence &
        :rtype: None

        """
        return _Units.Units_QtsSequence_Prepend(self, *args)

    def InsertBefore(self, *args):
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_Units_Quantity &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: Units_QtsSequence &
        :rtype: None

        """
        return _Units.Units_QtsSequence_InsertBefore(self, *args)

    def InsertAfter(self, *args):
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_Units_Quantity &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: Units_QtsSequence &
        :rtype: None

        """
        return _Units.Units_QtsSequence_InsertAfter(self, *args)

    def First(self, *args):
        """
        :rtype: Handle_Units_Quantity

        """
        return _Units.Units_QtsSequence_First(self, *args)

    def Last(self, *args):
        """
        :rtype: Handle_Units_Quantity

        """
        return _Units.Units_QtsSequence_Last(self, *args)

    def Split(self, *args):
        """
        :param Index:
        :type Index: int
        :param Sub:
        :type Sub: Units_QtsSequence &
        :rtype: None

        """
        return _Units.Units_QtsSequence_Split(self, *args)

    def Value(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_Units_Quantity

        """
        return _Units.Units_QtsSequence_Value(self, *args)

    def SetValue(self, *args):
        """
        :param Index:
        :type Index: int
        :param I:
        :type I: Handle_Units_Quantity &
        :rtype: None

        """
        return _Units.Units_QtsSequence_SetValue(self, *args)

    def ChangeValue(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_Units_Quantity

        """
        return _Units.Units_QtsSequence_ChangeValue(self, *args)

    def Remove(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: None

        :param FromIndex:
        :type FromIndex: int
        :param ToIndex:
        :type ToIndex: int
        :rtype: None

        """
        return _Units.Units_QtsSequence_Remove(self, *args)

    __swig_destroy__ = _Units.delete_Units_QtsSequence
Units_QtsSequence.Clear = new_instancemethod(_Units.Units_QtsSequence_Clear,None,Units_QtsSequence)
Units_QtsSequence.Assign = new_instancemethod(_Units.Units_QtsSequence_Assign,None,Units_QtsSequence)
Units_QtsSequence.Set = new_instancemethod(_Units.Units_QtsSequence_Set,None,Units_QtsSequence)
Units_QtsSequence.Append = new_instancemethod(_Units.Units_QtsSequence_Append,None,Units_QtsSequence)
Units_QtsSequence.Prepend = new_instancemethod(_Units.Units_QtsSequence_Prepend,None,Units_QtsSequence)
Units_QtsSequence.InsertBefore = new_instancemethod(_Units.Units_QtsSequence_InsertBefore,None,Units_QtsSequence)
Units_QtsSequence.InsertAfter = new_instancemethod(_Units.Units_QtsSequence_InsertAfter,None,Units_QtsSequence)
Units_QtsSequence.First = new_instancemethod(_Units.Units_QtsSequence_First,None,Units_QtsSequence)
Units_QtsSequence.Last = new_instancemethod(_Units.Units_QtsSequence_Last,None,Units_QtsSequence)
Units_QtsSequence.Split = new_instancemethod(_Units.Units_QtsSequence_Split,None,Units_QtsSequence)
Units_QtsSequence.Value = new_instancemethod(_Units.Units_QtsSequence_Value,None,Units_QtsSequence)
Units_QtsSequence.SetValue = new_instancemethod(_Units.Units_QtsSequence_SetValue,None,Units_QtsSequence)
Units_QtsSequence.ChangeValue = new_instancemethod(_Units.Units_QtsSequence_ChangeValue,None,Units_QtsSequence)
Units_QtsSequence.Remove = new_instancemethod(_Units.Units_QtsSequence_Remove,None,Units_QtsSequence)
Units_QtsSequence_swigregister = _Units.Units_QtsSequence_swigregister
Units_QtsSequence_swigregister(Units_QtsSequence)

class Units_QuantitiesSequence(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        """
        _Units.Units_QuantitiesSequence_swiginit(self,_Units.new_Units_QuantitiesSequence(*args))
    def IsEmpty(self, *args):
        """
        :rtype: bool

        """
        return _Units.Units_QuantitiesSequence_IsEmpty(self, *args)

    def Length(self, *args):
        """
        :rtype: int

        """
        return _Units.Units_QuantitiesSequence_Length(self, *args)

    def Clear(self, *args):
        """
        :rtype: None

        """
        return _Units.Units_QuantitiesSequence_Clear(self, *args)

    def Append(self, *args):
        """
        :param anItem:
        :type anItem: Handle_Units_Quantity &
        :rtype: None

        :param aSequence:
        :type aSequence: Handle_Units_QuantitiesSequence &
        :rtype: None

        """
        return _Units.Units_QuantitiesSequence_Append(self, *args)

    def Prepend(self, *args):
        """
        :param anItem:
        :type anItem: Handle_Units_Quantity &
        :rtype: None

        :param aSequence:
        :type aSequence: Handle_Units_QuantitiesSequence &
        :rtype: None

        """
        return _Units.Units_QuantitiesSequence_Prepend(self, *args)

    def Reverse(self, *args):
        """
        :rtype: None

        """
        return _Units.Units_QuantitiesSequence_Reverse(self, *args)

    def InsertBefore(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :param anItem:
        :type anItem: Handle_Units_Quantity &
        :rtype: None

        :param anIndex:
        :type anIndex: int
        :param aSequence:
        :type aSequence: Handle_Units_QuantitiesSequence &
        :rtype: None

        """
        return _Units.Units_QuantitiesSequence_InsertBefore(self, *args)

    def InsertAfter(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :param anItem:
        :type anItem: Handle_Units_Quantity &
        :rtype: None

        :param anIndex:
        :type anIndex: int
        :param aSequence:
        :type aSequence: Handle_Units_QuantitiesSequence &
        :rtype: None

        """
        return _Units.Units_QuantitiesSequence_InsertAfter(self, *args)

    def Exchange(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :param anOtherIndex:
        :type anOtherIndex: int
        :rtype: None

        """
        return _Units.Units_QuantitiesSequence_Exchange(self, *args)

    def Split(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :rtype: Handle_Units_QuantitiesSequence

        """
        return _Units.Units_QuantitiesSequence_Split(self, *args)

    def SetValue(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :param anItem:
        :type anItem: Handle_Units_Quantity &
        :rtype: None

        """
        return _Units.Units_QuantitiesSequence_SetValue(self, *args)

    def Value(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :rtype: Handle_Units_Quantity

        """
        return _Units.Units_QuantitiesSequence_Value(self, *args)

    def ChangeValue(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :rtype: Handle_Units_Quantity

        """
        return _Units.Units_QuantitiesSequence_ChangeValue(self, *args)

    def Remove(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :rtype: None

        :param fromIndex:
        :type fromIndex: int
        :param toIndex:
        :type toIndex: int
        :rtype: None

        """
        return _Units.Units_QuantitiesSequence_Remove(self, *args)

    def Sequence(self, *args):
        """
        :rtype: Units_QtsSequence

        """
        return _Units.Units_QuantitiesSequence_Sequence(self, *args)

    def ChangeSequence(self, *args):
        """
        :rtype: Units_QtsSequence

        """
        return _Units.Units_QuantitiesSequence_ChangeSequence(self, *args)

    def ShallowCopy(self, *args):
        """
        :rtype: Handle_Units_QuantitiesSequence

        """
        return _Units.Units_QuantitiesSequence_ShallowCopy(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Units_QuantitiesSequence(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _Units.delete_Units_QuantitiesSequence
Units_QuantitiesSequence.IsEmpty = new_instancemethod(_Units.Units_QuantitiesSequence_IsEmpty,None,Units_QuantitiesSequence)
Units_QuantitiesSequence.Length = new_instancemethod(_Units.Units_QuantitiesSequence_Length,None,Units_QuantitiesSequence)
Units_QuantitiesSequence.Clear = new_instancemethod(_Units.Units_QuantitiesSequence_Clear,None,Units_QuantitiesSequence)
Units_QuantitiesSequence.Append = new_instancemethod(_Units.Units_QuantitiesSequence_Append,None,Units_QuantitiesSequence)
Units_QuantitiesSequence.Prepend = new_instancemethod(_Units.Units_QuantitiesSequence_Prepend,None,Units_QuantitiesSequence)
Units_QuantitiesSequence.Reverse = new_instancemethod(_Units.Units_QuantitiesSequence_Reverse,None,Units_QuantitiesSequence)
Units_QuantitiesSequence.InsertBefore = new_instancemethod(_Units.Units_QuantitiesSequence_InsertBefore,None,Units_QuantitiesSequence)
Units_QuantitiesSequence.InsertAfter = new_instancemethod(_Units.Units_QuantitiesSequence_InsertAfter,None,Units_QuantitiesSequence)
Units_QuantitiesSequence.Exchange = new_instancemethod(_Units.Units_QuantitiesSequence_Exchange,None,Units_QuantitiesSequence)
Units_QuantitiesSequence.Split = new_instancemethod(_Units.Units_QuantitiesSequence_Split,None,Units_QuantitiesSequence)
Units_QuantitiesSequence.SetValue = new_instancemethod(_Units.Units_QuantitiesSequence_SetValue,None,Units_QuantitiesSequence)
Units_QuantitiesSequence.Value = new_instancemethod(_Units.Units_QuantitiesSequence_Value,None,Units_QuantitiesSequence)
Units_QuantitiesSequence.ChangeValue = new_instancemethod(_Units.Units_QuantitiesSequence_ChangeValue,None,Units_QuantitiesSequence)
Units_QuantitiesSequence.Remove = new_instancemethod(_Units.Units_QuantitiesSequence_Remove,None,Units_QuantitiesSequence)
Units_QuantitiesSequence.Sequence = new_instancemethod(_Units.Units_QuantitiesSequence_Sequence,None,Units_QuantitiesSequence)
Units_QuantitiesSequence.ChangeSequence = new_instancemethod(_Units.Units_QuantitiesSequence_ChangeSequence,None,Units_QuantitiesSequence)
Units_QuantitiesSequence.ShallowCopy = new_instancemethod(_Units.Units_QuantitiesSequence_ShallowCopy,None,Units_QuantitiesSequence)
Units_QuantitiesSequence_swigregister = _Units.Units_QuantitiesSequence_swigregister
Units_QuantitiesSequence_swigregister(Units_QuantitiesSequence)

class Handle_Units_QuantitiesSequence(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _Units.Handle_Units_QuantitiesSequence_swiginit(self,_Units.new_Handle_Units_QuantitiesSequence(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Units.Handle_Units_QuantitiesSequence_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_QuantitiesSequence
Handle_Units_QuantitiesSequence.Nullify = new_instancemethod(_Units.Handle_Units_QuantitiesSequence_Nullify,None,Handle_Units_QuantitiesSequence)
Handle_Units_QuantitiesSequence.IsNull = new_instancemethod(_Units.Handle_Units_QuantitiesSequence_IsNull,None,Handle_Units_QuantitiesSequence)
Handle_Units_QuantitiesSequence.GetObject = new_instancemethod(_Units.Handle_Units_QuantitiesSequence_GetObject,None,Handle_Units_QuantitiesSequence)
Handle_Units_QuantitiesSequence_swigregister = _Units.Handle_Units_QuantitiesSequence_swigregister
Handle_Units_QuantitiesSequence_swigregister(Handle_Units_QuantitiesSequence)

def Handle_Units_QuantitiesSequence_DownCast(*args):
  return _Units.Handle_Units_QuantitiesSequence_DownCast(*args)
Handle_Units_QuantitiesSequence_DownCast = _Units.Handle_Units_QuantitiesSequence_DownCast

class Units_Sentence(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Creates and returns a Sentence, by analyzing the string <astring> with the lexicon <alexicon>.

        :param alexicon:
        :type alexicon: Handle_Units_Lexicon &
        :param astring:
        :type astring: char *
        :rtype: None

        """
        _Units.Units_Sentence_swiginit(self,_Units.new_Units_Sentence(*args))
    def SetConstants(self, *args):
        """
        * For each constant encountered, sets the value.

        :rtype: None

        """
        return _Units.Units_Sentence_SetConstants(self, *args)

    def Sequence(self, *args):
        """
        * Returns <thesequenceoftokens>.

        :rtype: Handle_Units_TokensSequence

        * Sets the field <thesequenceoftokens> to <asequenceoftokens>.

        :param asequenceoftokens:
        :type asequenceoftokens: Handle_Units_TokensSequence &
        :rtype: None

        """
        return _Units.Units_Sentence_Sequence(self, *args)

    def Evaluate(self, *args):
        """
        * Computes and returns in a token the result of the expression.

        :rtype: Handle_Units_Token

        """
        return _Units.Units_Sentence_Evaluate(self, *args)

    def IsDone(self, *args):
        """
        * Return True if number of created tokens > 0 (i.e creation of sentence is succesfull)

        :rtype: bool

        """
        return _Units.Units_Sentence_IsDone(self, *args)

    def Dump(self, *args):
        """
        * Useful for debugging.

        :rtype: None

        """
        return _Units.Units_Sentence_Dump(self, *args)

    __swig_destroy__ = _Units.delete_Units_Sentence
Units_Sentence.SetConstants = new_instancemethod(_Units.Units_Sentence_SetConstants,None,Units_Sentence)
Units_Sentence.Sequence = new_instancemethod(_Units.Units_Sentence_Sequence,None,Units_Sentence)
Units_Sentence.Evaluate = new_instancemethod(_Units.Units_Sentence_Evaluate,None,Units_Sentence)
Units_Sentence.IsDone = new_instancemethod(_Units.Units_Sentence_IsDone,None,Units_Sentence)
Units_Sentence.Dump = new_instancemethod(_Units.Units_Sentence_Dump,None,Units_Sentence)
Units_Sentence_swigregister = _Units.Units_Sentence_swigregister
Units_Sentence_swigregister(Units_Sentence)

class Units_SequenceNodeOfQtsSequence(OCC.TCollection.TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param I:
        :type I: Handle_Units_Quantity &
        :param n:
        :type n: TCollection_SeqNodePtr &
        :param p:
        :type p: TCollection_SeqNodePtr &
        :rtype: None

        """
        _Units.Units_SequenceNodeOfQtsSequence_swiginit(self,_Units.new_Units_SequenceNodeOfQtsSequence(*args))
    def Value(self, *args):
        """
        :rtype: Handle_Units_Quantity

        """
        return _Units.Units_SequenceNodeOfQtsSequence_Value(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Units_SequenceNodeOfQtsSequence(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _Units.delete_Units_SequenceNodeOfQtsSequence
Units_SequenceNodeOfQtsSequence.Value = new_instancemethod(_Units.Units_SequenceNodeOfQtsSequence_Value,None,Units_SequenceNodeOfQtsSequence)
Units_SequenceNodeOfQtsSequence_swigregister = _Units.Units_SequenceNodeOfQtsSequence_swigregister
Units_SequenceNodeOfQtsSequence_swigregister(Units_SequenceNodeOfQtsSequence)

class Handle_Units_SequenceNodeOfQtsSequence(OCC.TCollection.Handle_TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _Units.Handle_Units_SequenceNodeOfQtsSequence_swiginit(self,_Units.new_Handle_Units_SequenceNodeOfQtsSequence(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Units.Handle_Units_SequenceNodeOfQtsSequence_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_SequenceNodeOfQtsSequence
Handle_Units_SequenceNodeOfQtsSequence.Nullify = new_instancemethod(_Units.Handle_Units_SequenceNodeOfQtsSequence_Nullify,None,Handle_Units_SequenceNodeOfQtsSequence)
Handle_Units_SequenceNodeOfQtsSequence.IsNull = new_instancemethod(_Units.Handle_Units_SequenceNodeOfQtsSequence_IsNull,None,Handle_Units_SequenceNodeOfQtsSequence)
Handle_Units_SequenceNodeOfQtsSequence.GetObject = new_instancemethod(_Units.Handle_Units_SequenceNodeOfQtsSequence_GetObject,None,Handle_Units_SequenceNodeOfQtsSequence)
Handle_Units_SequenceNodeOfQtsSequence_swigregister = _Units.Handle_Units_SequenceNodeOfQtsSequence_swigregister
Handle_Units_SequenceNodeOfQtsSequence_swigregister(Handle_Units_SequenceNodeOfQtsSequence)

def Handle_Units_SequenceNodeOfQtsSequence_DownCast(*args):
  return _Units.Handle_Units_SequenceNodeOfQtsSequence_DownCast(*args)
Handle_Units_SequenceNodeOfQtsSequence_DownCast = _Units.Handle_Units_SequenceNodeOfQtsSequence_DownCast

class Units_SequenceNodeOfTksSequence(OCC.TCollection.TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param I:
        :type I: Handle_Units_Token &
        :param n:
        :type n: TCollection_SeqNodePtr &
        :param p:
        :type p: TCollection_SeqNodePtr &
        :rtype: None

        """
        _Units.Units_SequenceNodeOfTksSequence_swiginit(self,_Units.new_Units_SequenceNodeOfTksSequence(*args))
    def Value(self, *args):
        """
        :rtype: Handle_Units_Token

        """
        return _Units.Units_SequenceNodeOfTksSequence_Value(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Units_SequenceNodeOfTksSequence(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _Units.delete_Units_SequenceNodeOfTksSequence
Units_SequenceNodeOfTksSequence.Value = new_instancemethod(_Units.Units_SequenceNodeOfTksSequence_Value,None,Units_SequenceNodeOfTksSequence)
Units_SequenceNodeOfTksSequence_swigregister = _Units.Units_SequenceNodeOfTksSequence_swigregister
Units_SequenceNodeOfTksSequence_swigregister(Units_SequenceNodeOfTksSequence)

class Handle_Units_SequenceNodeOfTksSequence(OCC.TCollection.Handle_TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _Units.Handle_Units_SequenceNodeOfTksSequence_swiginit(self,_Units.new_Handle_Units_SequenceNodeOfTksSequence(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Units.Handle_Units_SequenceNodeOfTksSequence_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_SequenceNodeOfTksSequence
Handle_Units_SequenceNodeOfTksSequence.Nullify = new_instancemethod(_Units.Handle_Units_SequenceNodeOfTksSequence_Nullify,None,Handle_Units_SequenceNodeOfTksSequence)
Handle_Units_SequenceNodeOfTksSequence.IsNull = new_instancemethod(_Units.Handle_Units_SequenceNodeOfTksSequence_IsNull,None,Handle_Units_SequenceNodeOfTksSequence)
Handle_Units_SequenceNodeOfTksSequence.GetObject = new_instancemethod(_Units.Handle_Units_SequenceNodeOfTksSequence_GetObject,None,Handle_Units_SequenceNodeOfTksSequence)
Handle_Units_SequenceNodeOfTksSequence_swigregister = _Units.Handle_Units_SequenceNodeOfTksSequence_swigregister
Handle_Units_SequenceNodeOfTksSequence_swigregister(Handle_Units_SequenceNodeOfTksSequence)

def Handle_Units_SequenceNodeOfTksSequence_DownCast(*args):
  return _Units.Handle_Units_SequenceNodeOfTksSequence_DownCast(*args)
Handle_Units_SequenceNodeOfTksSequence_DownCast = _Units.Handle_Units_SequenceNodeOfTksSequence_DownCast

class Units_SequenceNodeOfUtsSequence(OCC.TCollection.TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param I:
        :type I: Handle_Units_Unit &
        :param n:
        :type n: TCollection_SeqNodePtr &
        :param p:
        :type p: TCollection_SeqNodePtr &
        :rtype: None

        """
        _Units.Units_SequenceNodeOfUtsSequence_swiginit(self,_Units.new_Units_SequenceNodeOfUtsSequence(*args))
    def Value(self, *args):
        """
        :rtype: Handle_Units_Unit

        """
        return _Units.Units_SequenceNodeOfUtsSequence_Value(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Units_SequenceNodeOfUtsSequence(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _Units.delete_Units_SequenceNodeOfUtsSequence
Units_SequenceNodeOfUtsSequence.Value = new_instancemethod(_Units.Units_SequenceNodeOfUtsSequence_Value,None,Units_SequenceNodeOfUtsSequence)
Units_SequenceNodeOfUtsSequence_swigregister = _Units.Units_SequenceNodeOfUtsSequence_swigregister
Units_SequenceNodeOfUtsSequence_swigregister(Units_SequenceNodeOfUtsSequence)

class Handle_Units_SequenceNodeOfUtsSequence(OCC.TCollection.Handle_TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _Units.Handle_Units_SequenceNodeOfUtsSequence_swiginit(self,_Units.new_Handle_Units_SequenceNodeOfUtsSequence(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Units.Handle_Units_SequenceNodeOfUtsSequence_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_SequenceNodeOfUtsSequence
Handle_Units_SequenceNodeOfUtsSequence.Nullify = new_instancemethod(_Units.Handle_Units_SequenceNodeOfUtsSequence_Nullify,None,Handle_Units_SequenceNodeOfUtsSequence)
Handle_Units_SequenceNodeOfUtsSequence.IsNull = new_instancemethod(_Units.Handle_Units_SequenceNodeOfUtsSequence_IsNull,None,Handle_Units_SequenceNodeOfUtsSequence)
Handle_Units_SequenceNodeOfUtsSequence.GetObject = new_instancemethod(_Units.Handle_Units_SequenceNodeOfUtsSequence_GetObject,None,Handle_Units_SequenceNodeOfUtsSequence)
Handle_Units_SequenceNodeOfUtsSequence_swigregister = _Units.Handle_Units_SequenceNodeOfUtsSequence_swigregister
Handle_Units_SequenceNodeOfUtsSequence_swigregister(Handle_Units_SequenceNodeOfUtsSequence)

def Handle_Units_SequenceNodeOfUtsSequence_DownCast(*args):
  return _Units.Handle_Units_SequenceNodeOfUtsSequence_DownCast(*args)
Handle_Units_SequenceNodeOfUtsSequence_DownCast = _Units.Handle_Units_SequenceNodeOfUtsSequence_DownCast

class Units_TksSequence(OCC.TCollection.TCollection_BaseSequence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        """
        _Units.Units_TksSequence_swiginit(self,_Units.new_Units_TksSequence(*args))
    def Clear(self, *args):
        """
        :rtype: None

        """
        return _Units.Units_TksSequence_Clear(self, *args)

    def Assign(self, *args):
        """
        :param Other:
        :type Other: Units_TksSequence &
        :rtype: Units_TksSequence

        """
        return _Units.Units_TksSequence_Assign(self, *args)

    def Set(self, *args):
        """
        :param Other:
        :type Other: Units_TksSequence &
        :rtype: Units_TksSequence

        """
        return _Units.Units_TksSequence_Set(self, *args)

    def Append(self, *args):
        """
        :param T:
        :type T: Handle_Units_Token &
        :rtype: None

        :param S:
        :type S: Units_TksSequence &
        :rtype: None

        """
        return _Units.Units_TksSequence_Append(self, *args)

    def Prepend(self, *args):
        """
        :param T:
        :type T: Handle_Units_Token &
        :rtype: None

        :param S:
        :type S: Units_TksSequence &
        :rtype: None

        """
        return _Units.Units_TksSequence_Prepend(self, *args)

    def InsertBefore(self, *args):
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_Units_Token &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: Units_TksSequence &
        :rtype: None

        """
        return _Units.Units_TksSequence_InsertBefore(self, *args)

    def InsertAfter(self, *args):
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_Units_Token &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: Units_TksSequence &
        :rtype: None

        """
        return _Units.Units_TksSequence_InsertAfter(self, *args)

    def First(self, *args):
        """
        :rtype: Handle_Units_Token

        """
        return _Units.Units_TksSequence_First(self, *args)

    def Last(self, *args):
        """
        :rtype: Handle_Units_Token

        """
        return _Units.Units_TksSequence_Last(self, *args)

    def Split(self, *args):
        """
        :param Index:
        :type Index: int
        :param Sub:
        :type Sub: Units_TksSequence &
        :rtype: None

        """
        return _Units.Units_TksSequence_Split(self, *args)

    def Value(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_Units_Token

        """
        return _Units.Units_TksSequence_Value(self, *args)

    def SetValue(self, *args):
        """
        :param Index:
        :type Index: int
        :param I:
        :type I: Handle_Units_Token &
        :rtype: None

        """
        return _Units.Units_TksSequence_SetValue(self, *args)

    def ChangeValue(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_Units_Token

        """
        return _Units.Units_TksSequence_ChangeValue(self, *args)

    def Remove(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: None

        :param FromIndex:
        :type FromIndex: int
        :param ToIndex:
        :type ToIndex: int
        :rtype: None

        """
        return _Units.Units_TksSequence_Remove(self, *args)

    __swig_destroy__ = _Units.delete_Units_TksSequence
Units_TksSequence.Clear = new_instancemethod(_Units.Units_TksSequence_Clear,None,Units_TksSequence)
Units_TksSequence.Assign = new_instancemethod(_Units.Units_TksSequence_Assign,None,Units_TksSequence)
Units_TksSequence.Set = new_instancemethod(_Units.Units_TksSequence_Set,None,Units_TksSequence)
Units_TksSequence.Append = new_instancemethod(_Units.Units_TksSequence_Append,None,Units_TksSequence)
Units_TksSequence.Prepend = new_instancemethod(_Units.Units_TksSequence_Prepend,None,Units_TksSequence)
Units_TksSequence.InsertBefore = new_instancemethod(_Units.Units_TksSequence_InsertBefore,None,Units_TksSequence)
Units_TksSequence.InsertAfter = new_instancemethod(_Units.Units_TksSequence_InsertAfter,None,Units_TksSequence)
Units_TksSequence.First = new_instancemethod(_Units.Units_TksSequence_First,None,Units_TksSequence)
Units_TksSequence.Last = new_instancemethod(_Units.Units_TksSequence_Last,None,Units_TksSequence)
Units_TksSequence.Split = new_instancemethod(_Units.Units_TksSequence_Split,None,Units_TksSequence)
Units_TksSequence.Value = new_instancemethod(_Units.Units_TksSequence_Value,None,Units_TksSequence)
Units_TksSequence.SetValue = new_instancemethod(_Units.Units_TksSequence_SetValue,None,Units_TksSequence)
Units_TksSequence.ChangeValue = new_instancemethod(_Units.Units_TksSequence_ChangeValue,None,Units_TksSequence)
Units_TksSequence.Remove = new_instancemethod(_Units.Units_TksSequence_Remove,None,Units_TksSequence)
Units_TksSequence_swigregister = _Units.Units_TksSequence_swigregister
Units_TksSequence_swigregister(Units_TksSequence)

class Units_Token(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Creates and returns a empty token.

        :rtype: None

        * Creates and returns a token. <aword> is a string containing the available word.

        :param aword:
        :type aword: char *
        :rtype: None

        * Creates and returns a token. <atoken> is copied in the returned token.

        :param atoken:
        :type atoken: Handle_Units_Token &
        :rtype: None

        * Creates and returns a token. <aword> is a string containing the available word and <amean> gives the signification of the token.

        :param aword:
        :type aword: char *
        :param amean:
        :type amean: char *
        :rtype: None

        * Creates and returns a token. <aword> is a string containing the available word, <amean> gives the signification of the token and <avalue> is the numeric value of the dimension.

        :param aword:
        :type aword: char *
        :param amean:
        :type amean: char *
        :param avalue:
        :type avalue: float
        :rtype: None

        * Creates and returns a token. <aword> is a string containing the available word, <amean> gives the signification of the token, <avalue> is the numeric value of the dimension, and <adimensions> is the dimension of the given word <aword>.

        :param aword:
        :type aword: char *
        :param amean:
        :type amean: char *
        :param avalue:
        :type avalue: float
        :param adimension:
        :type adimension: Handle_Units_Dimensions &
        :rtype: None

        """
        _Units.Units_Token_swiginit(self,_Units.new_Units_Token(*args))
    def Creates(self, *args):
        """
        * Creates and returns a token, which is a ShiftedToken.

        :rtype: Handle_Units_Token

        """
        return _Units.Units_Token_Creates(self, *args)

    def Length(self, *args):
        """
        * Returns the length of the word.

        :rtype: int

        """
        return _Units.Units_Token_Length(self, *args)

    def Word(self, *args):
        """
        * Returns the string <theword>

        :rtype: TCollection_AsciiString

        * Sets the field <theword> to <aword>.

        :param aword:
        :type aword: char *
        :rtype: None

        """
        return _Units.Units_Token_Word(self, *args)

    def Mean(self, *args):
        """
        * Returns the significance of the word <theword>, which is in the field <themean>.

        :rtype: TCollection_AsciiString

        * Sets the field <themean> to <amean>.

        :param amean:
        :type amean: char *
        :rtype: None

        """
        return _Units.Units_Token_Mean(self, *args)

    def Value(self, *args):
        """
        * Returns the value stored in the field <thevalue>.

        :rtype: float

        * Sets the field <thevalue> to <avalue>.

        :param avalue:
        :type avalue: float
        :rtype: None

        """
        return _Units.Units_Token_Value(self, *args)

    def Dimensions(self, *args):
        """
        * Returns the dimensions of the token <thedimensions>.

        :rtype: Handle_Units_Dimensions

        * Sets the field <thedimensions> to <adimensions>.

        :param adimensions:
        :type adimensions: Handle_Units_Dimensions &
        :rtype: None

        """
        return _Units.Units_Token_Dimensions(self, *args)

    def Update(self, *args):
        """
        * Updates the token <self> with the additional signification <amean> by concatenation of the two strings <themean> and <amean>. If the two significations are the same , an information message is written in the output device.

        :param amean:
        :type amean: char *
        :rtype: None

        """
        return _Units.Units_Token_Update(self, *args)

    def Add(self, *args):
        """
        :param aninteger:
        :type aninteger: int
        :rtype: Handle_Units_Token

        * Returns a token which is the addition of <self> and another token <atoken>. The addition is possible if and only if the dimensions are the same.

        :param atoken:
        :type atoken: Handle_Units_Token &
        :rtype: Handle_Units_Token

        """
        return _Units.Units_Token_Add(self, *args)

    def Subtract(self, *args):
        """
        * Returns a token which is the subtraction of <self> and another token <atoken>. The subtraction is possible if and only if the dimensions are the same.

        :param atoken:
        :type atoken: Handle_Units_Token &
        :rtype: Handle_Units_Token

        """
        return _Units.Units_Token_Subtract(self, *args)

    def Multiply(self, *args):
        """
        * Returns a token which is the product of <self> and another token <atoken>.

        :param atoken:
        :type atoken: Handle_Units_Token &
        :rtype: Handle_Units_Token

        """
        return _Units.Units_Token_Multiply(self, *args)

    def Multiplied(self, *args):
        """
        * This virtual method is called by the Measurement methods, to compute the measurement during a conversion.

        :param avalue:
        :type avalue: float
        :rtype: float

        """
        return _Units.Units_Token_Multiplied(self, *args)

    def Divide(self, *args):
        """
        * Returns a token which is the division of <self> by another token <atoken>.

        :param atoken:
        :type atoken: Handle_Units_Token &
        :rtype: Handle_Units_Token

        """
        return _Units.Units_Token_Divide(self, *args)

    def Divided(self, *args):
        """
        * This virtual method is called by the Measurement methods, to compute the measurement during a conversion.

        :param avalue:
        :type avalue: float
        :rtype: float

        """
        return _Units.Units_Token_Divided(self, *args)

    def Power(self, *args):
        """
        * Returns a token which is <self> to the power of another token <atoken>. The computation is possible only if <atoken> is a dimensionless constant.

        :param atoken:
        :type atoken: Handle_Units_Token &
        :rtype: Handle_Units_Token

        * Returns a token which is <self> to the power of <anexponent>.

        :param anexponent:
        :type anexponent: float
        :rtype: Handle_Units_Token

        """
        return _Units.Units_Token_Power(self, *args)

    def IsEqual(self, *args):
        """
        * Returns true if the field <theword> and the string <astring> are the same, false otherwise.

        :param astring:
        :type astring: char *
        :rtype: bool

        * Returns true if the field <theword> and the string <theword> contained in the token <atoken> are the same, false otherwise.

        :param atoken:
        :type atoken: Handle_Units_Token &
        :rtype: bool

        """
        return _Units.Units_Token_IsEqual(self, *args)

    def IsNotEqual(self, *args):
        """
        * Returns false if the field <theword> and the string <astring> are the same, true otherwise.

        :param astring:
        :type astring: char *
        :rtype: bool

        * Returns false if the field <theword> and the string <theword> contained in the token <atoken> are the same, true otherwise.

        :param atoken:
        :type atoken: Handle_Units_Token &
        :rtype: bool

        """
        return _Units.Units_Token_IsNotEqual(self, *args)

    def IsLessOrEqual(self, *args):
        """
        * Returns true if the field <theword> is strictly contained at the beginning of the string <astring>, false otherwise.

        :param astring:
        :type astring: char *
        :rtype: bool

        """
        return _Units.Units_Token_IsLessOrEqual(self, *args)

    def IsGreater(self, *args):
        """
        * Returns false if the field <theword> is strictly contained at the beginning of the string <astring>, true otherwise.

        :param astring:
        :type astring: char *
        :rtype: bool

        * Returns false if the field <theword> is strictly contained at the beginning of the string <astring>, true otherwise.

        :param atoken:
        :type atoken: Handle_Units_Token &
        :rtype: bool

        """
        return _Units.Units_Token_IsGreater(self, *args)

    def IsGreaterOrEqual(self, *args):
        """
        * Returns true if the string <astring> is strictly contained at the beginning of the field <theword> false otherwise.

        :param atoken:
        :type atoken: Handle_Units_Token &
        :rtype: bool

        """
        return _Units.Units_Token_IsGreaterOrEqual(self, *args)

    def Destroy(self, *args):
        """
        * Destroies the Token

        :rtype: void

        """
        return _Units.Units_Token_Destroy(self, *args)

    def Dump(self, *args):
        """
        * Useful for debugging

        :param ashift:
        :type ashift: int
        :param alevel:
        :type alevel: int
        :rtype: void

        """
        return _Units.Units_Token_Dump(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Units_Token(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _Units.delete_Units_Token
Units_Token.Creates = new_instancemethod(_Units.Units_Token_Creates,None,Units_Token)
Units_Token.Length = new_instancemethod(_Units.Units_Token_Length,None,Units_Token)
Units_Token.Word = new_instancemethod(_Units.Units_Token_Word,None,Units_Token)
Units_Token.Mean = new_instancemethod(_Units.Units_Token_Mean,None,Units_Token)
Units_Token.Value = new_instancemethod(_Units.Units_Token_Value,None,Units_Token)
Units_Token.Dimensions = new_instancemethod(_Units.Units_Token_Dimensions,None,Units_Token)
Units_Token.Update = new_instancemethod(_Units.Units_Token_Update,None,Units_Token)
Units_Token.Add = new_instancemethod(_Units.Units_Token_Add,None,Units_Token)
Units_Token.Subtract = new_instancemethod(_Units.Units_Token_Subtract,None,Units_Token)
Units_Token.Multiply = new_instancemethod(_Units.Units_Token_Multiply,None,Units_Token)
Units_Token.Multiplied = new_instancemethod(_Units.Units_Token_Multiplied,None,Units_Token)
Units_Token.Divide = new_instancemethod(_Units.Units_Token_Divide,None,Units_Token)
Units_Token.Divided = new_instancemethod(_Units.Units_Token_Divided,None,Units_Token)
Units_Token.Power = new_instancemethod(_Units.Units_Token_Power,None,Units_Token)
Units_Token.IsEqual = new_instancemethod(_Units.Units_Token_IsEqual,None,Units_Token)
Units_Token.IsNotEqual = new_instancemethod(_Units.Units_Token_IsNotEqual,None,Units_Token)
Units_Token.IsLessOrEqual = new_instancemethod(_Units.Units_Token_IsLessOrEqual,None,Units_Token)
Units_Token.IsGreater = new_instancemethod(_Units.Units_Token_IsGreater,None,Units_Token)
Units_Token.IsGreaterOrEqual = new_instancemethod(_Units.Units_Token_IsGreaterOrEqual,None,Units_Token)
Units_Token.Destroy = new_instancemethod(_Units.Units_Token_Destroy,None,Units_Token)
Units_Token.Dump = new_instancemethod(_Units.Units_Token_Dump,None,Units_Token)
Units_Token_swigregister = _Units.Units_Token_swigregister
Units_Token_swigregister(Units_Token)

class Handle_Units_Token(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _Units.Handle_Units_Token_swiginit(self,_Units.new_Handle_Units_Token(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Units.Handle_Units_Token_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_Token
Handle_Units_Token.Nullify = new_instancemethod(_Units.Handle_Units_Token_Nullify,None,Handle_Units_Token)
Handle_Units_Token.IsNull = new_instancemethod(_Units.Handle_Units_Token_IsNull,None,Handle_Units_Token)
Handle_Units_Token.GetObject = new_instancemethod(_Units.Handle_Units_Token_GetObject,None,Handle_Units_Token)
Handle_Units_Token_swigregister = _Units.Handle_Units_Token_swigregister
Handle_Units_Token_swigregister(Handle_Units_Token)

def Handle_Units_Token_DownCast(*args):
  return _Units.Handle_Units_Token_DownCast(*args)
Handle_Units_Token_DownCast = _Units.Handle_Units_Token_DownCast

class Units_TokensSequence(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        """
        _Units.Units_TokensSequence_swiginit(self,_Units.new_Units_TokensSequence(*args))
    def IsEmpty(self, *args):
        """
        :rtype: bool

        """
        return _Units.Units_TokensSequence_IsEmpty(self, *args)

    def Length(self, *args):
        """
        :rtype: int

        """
        return _Units.Units_TokensSequence_Length(self, *args)

    def Clear(self, *args):
        """
        :rtype: None

        """
        return _Units.Units_TokensSequence_Clear(self, *args)

    def Append(self, *args):
        """
        :param anItem:
        :type anItem: Handle_Units_Token &
        :rtype: None

        :param aSequence:
        :type aSequence: Handle_Units_TokensSequence &
        :rtype: None

        """
        return _Units.Units_TokensSequence_Append(self, *args)

    def Prepend(self, *args):
        """
        :param anItem:
        :type anItem: Handle_Units_Token &
        :rtype: None

        :param aSequence:
        :type aSequence: Handle_Units_TokensSequence &
        :rtype: None

        """
        return _Units.Units_TokensSequence_Prepend(self, *args)

    def Reverse(self, *args):
        """
        :rtype: None

        """
        return _Units.Units_TokensSequence_Reverse(self, *args)

    def InsertBefore(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :param anItem:
        :type anItem: Handle_Units_Token &
        :rtype: None

        :param anIndex:
        :type anIndex: int
        :param aSequence:
        :type aSequence: Handle_Units_TokensSequence &
        :rtype: None

        """
        return _Units.Units_TokensSequence_InsertBefore(self, *args)

    def InsertAfter(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :param anItem:
        :type anItem: Handle_Units_Token &
        :rtype: None

        :param anIndex:
        :type anIndex: int
        :param aSequence:
        :type aSequence: Handle_Units_TokensSequence &
        :rtype: None

        """
        return _Units.Units_TokensSequence_InsertAfter(self, *args)

    def Exchange(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :param anOtherIndex:
        :type anOtherIndex: int
        :rtype: None

        """
        return _Units.Units_TokensSequence_Exchange(self, *args)

    def Split(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :rtype: Handle_Units_TokensSequence

        """
        return _Units.Units_TokensSequence_Split(self, *args)

    def SetValue(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :param anItem:
        :type anItem: Handle_Units_Token &
        :rtype: None

        """
        return _Units.Units_TokensSequence_SetValue(self, *args)

    def Value(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :rtype: Handle_Units_Token

        """
        return _Units.Units_TokensSequence_Value(self, *args)

    def ChangeValue(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :rtype: Handle_Units_Token

        """
        return _Units.Units_TokensSequence_ChangeValue(self, *args)

    def Remove(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :rtype: None

        :param fromIndex:
        :type fromIndex: int
        :param toIndex:
        :type toIndex: int
        :rtype: None

        """
        return _Units.Units_TokensSequence_Remove(self, *args)

    def Sequence(self, *args):
        """
        :rtype: Units_TksSequence

        """
        return _Units.Units_TokensSequence_Sequence(self, *args)

    def ChangeSequence(self, *args):
        """
        :rtype: Units_TksSequence

        """
        return _Units.Units_TokensSequence_ChangeSequence(self, *args)

    def ShallowCopy(self, *args):
        """
        :rtype: Handle_Units_TokensSequence

        """
        return _Units.Units_TokensSequence_ShallowCopy(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Units_TokensSequence(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _Units.delete_Units_TokensSequence
Units_TokensSequence.IsEmpty = new_instancemethod(_Units.Units_TokensSequence_IsEmpty,None,Units_TokensSequence)
Units_TokensSequence.Length = new_instancemethod(_Units.Units_TokensSequence_Length,None,Units_TokensSequence)
Units_TokensSequence.Clear = new_instancemethod(_Units.Units_TokensSequence_Clear,None,Units_TokensSequence)
Units_TokensSequence.Append = new_instancemethod(_Units.Units_TokensSequence_Append,None,Units_TokensSequence)
Units_TokensSequence.Prepend = new_instancemethod(_Units.Units_TokensSequence_Prepend,None,Units_TokensSequence)
Units_TokensSequence.Reverse = new_instancemethod(_Units.Units_TokensSequence_Reverse,None,Units_TokensSequence)
Units_TokensSequence.InsertBefore = new_instancemethod(_Units.Units_TokensSequence_InsertBefore,None,Units_TokensSequence)
Units_TokensSequence.InsertAfter = new_instancemethod(_Units.Units_TokensSequence_InsertAfter,None,Units_TokensSequence)
Units_TokensSequence.Exchange = new_instancemethod(_Units.Units_TokensSequence_Exchange,None,Units_TokensSequence)
Units_TokensSequence.Split = new_instancemethod(_Units.Units_TokensSequence_Split,None,Units_TokensSequence)
Units_TokensSequence.SetValue = new_instancemethod(_Units.Units_TokensSequence_SetValue,None,Units_TokensSequence)
Units_TokensSequence.Value = new_instancemethod(_Units.Units_TokensSequence_Value,None,Units_TokensSequence)
Units_TokensSequence.ChangeValue = new_instancemethod(_Units.Units_TokensSequence_ChangeValue,None,Units_TokensSequence)
Units_TokensSequence.Remove = new_instancemethod(_Units.Units_TokensSequence_Remove,None,Units_TokensSequence)
Units_TokensSequence.Sequence = new_instancemethod(_Units.Units_TokensSequence_Sequence,None,Units_TokensSequence)
Units_TokensSequence.ChangeSequence = new_instancemethod(_Units.Units_TokensSequence_ChangeSequence,None,Units_TokensSequence)
Units_TokensSequence.ShallowCopy = new_instancemethod(_Units.Units_TokensSequence_ShallowCopy,None,Units_TokensSequence)
Units_TokensSequence_swigregister = _Units.Units_TokensSequence_swigregister
Units_TokensSequence_swigregister(Units_TokensSequence)

class Handle_Units_TokensSequence(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _Units.Handle_Units_TokensSequence_swiginit(self,_Units.new_Handle_Units_TokensSequence(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Units.Handle_Units_TokensSequence_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_TokensSequence
Handle_Units_TokensSequence.Nullify = new_instancemethod(_Units.Handle_Units_TokensSequence_Nullify,None,Handle_Units_TokensSequence)
Handle_Units_TokensSequence.IsNull = new_instancemethod(_Units.Handle_Units_TokensSequence_IsNull,None,Handle_Units_TokensSequence)
Handle_Units_TokensSequence.GetObject = new_instancemethod(_Units.Handle_Units_TokensSequence_GetObject,None,Handle_Units_TokensSequence)
Handle_Units_TokensSequence_swigregister = _Units.Handle_Units_TokensSequence_swigregister
Handle_Units_TokensSequence_swigregister(Handle_Units_TokensSequence)

def Handle_Units_TokensSequence_DownCast(*args):
  return _Units.Handle_Units_TokensSequence_DownCast(*args)
Handle_Units_TokensSequence_DownCast = _Units.Handle_Units_TokensSequence_DownCast

class Units_Unit(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Creates and returns a unit. <aname> is the name of the unit, <asymbol> is the usual abbreviation of the unit, and <avalue> is the value in relation to the International System of Units.

        :param aname:
        :type aname: char *
        :param asymbol:
        :type asymbol: char *
        :param avalue:
        :type avalue: float
        :param aquantity:
        :type aquantity: Handle_Units_Quantity &
        :rtype: None

        * Creates and returns a unit. <aname> is the name of the unit, <asymbol> is the usual abbreviation of the unit.

        :param aname:
        :type aname: char *
        :param asymbol:
        :type asymbol: char *
        :rtype: None

        * Creates and returns a unit. <aname> is the name of the unit.

        :param aname:
        :type aname: char *
        :rtype: None

        """
        _Units.Units_Unit_swiginit(self,_Units.new_Units_Unit(*args))
    def Name(self, *args):
        """
        * Returns the name of the unit <thename>

        :rtype: TCollection_AsciiString

        """
        return _Units.Units_Unit_Name(self, *args)

    def Symbol(self, *args):
        """
        * Adds a new symbol <asymbol> attached to <self>.

        :param asymbol:
        :type asymbol: char *
        :rtype: None

        """
        return _Units.Units_Unit_Symbol(self, *args)

    def SymbolsSequence(self, *args):
        """
        * Returns the sequence of symbols <thesymbolssequence>

        :rtype: Handle_TColStd_HSequenceOfHAsciiString

        """
        return _Units.Units_Unit_SymbolsSequence(self, *args)

    def Value(self, *args):
        """
        * Returns the value in relation with the International System of Units.

        :rtype: float

        * Sets the value <avalue> to <self>.

        :param avalue:
        :type avalue: float
        :rtype: None

        """
        return _Units.Units_Unit_Value(self, *args)

    def Quantity(self, *args):
        """
        * Returns <thequantity> contained in <self>.

        :rtype: Handle_Units_Quantity

        * Sets the physical Quantity <aquantity> to <self>.

        :param aquantity:
        :type aquantity: Handle_Units_Quantity &
        :rtype: None

        """
        return _Units.Units_Unit_Quantity(self, *args)

    def Token(self, *args):
        """
        * Starting with <self>, returns a new Token object.

        :rtype: Handle_Units_Token

        """
        return _Units.Units_Unit_Token(self, *args)

    def IsEqual(self, *args):
        """
        * Compares all the symbols linked within <self> with the name of <atoken>, and returns True if there is one symbol equal to the name, False otherwise.

        :param astring:
        :type astring: char *
        :rtype: bool

        """
        return _Units.Units_Unit_IsEqual(self, *args)

    def Dump(self, *args):
        """
        * Useful for debugging

        :param ashift:
        :type ashift: int
        :param alevel:
        :type alevel: int
        :rtype: void

        """
        return _Units.Units_Unit_Dump(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Units_Unit(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _Units.delete_Units_Unit
Units_Unit.Name = new_instancemethod(_Units.Units_Unit_Name,None,Units_Unit)
Units_Unit.Symbol = new_instancemethod(_Units.Units_Unit_Symbol,None,Units_Unit)
Units_Unit.SymbolsSequence = new_instancemethod(_Units.Units_Unit_SymbolsSequence,None,Units_Unit)
Units_Unit.Value = new_instancemethod(_Units.Units_Unit_Value,None,Units_Unit)
Units_Unit.Quantity = new_instancemethod(_Units.Units_Unit_Quantity,None,Units_Unit)
Units_Unit.Token = new_instancemethod(_Units.Units_Unit_Token,None,Units_Unit)
Units_Unit.IsEqual = new_instancemethod(_Units.Units_Unit_IsEqual,None,Units_Unit)
Units_Unit.Dump = new_instancemethod(_Units.Units_Unit_Dump,None,Units_Unit)
Units_Unit_swigregister = _Units.Units_Unit_swigregister
Units_Unit_swigregister(Units_Unit)

class Handle_Units_Unit(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _Units.Handle_Units_Unit_swiginit(self,_Units.new_Handle_Units_Unit(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Units.Handle_Units_Unit_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_Unit
Handle_Units_Unit.Nullify = new_instancemethod(_Units.Handle_Units_Unit_Nullify,None,Handle_Units_Unit)
Handle_Units_Unit.IsNull = new_instancemethod(_Units.Handle_Units_Unit_IsNull,None,Handle_Units_Unit)
Handle_Units_Unit.GetObject = new_instancemethod(_Units.Handle_Units_Unit_GetObject,None,Handle_Units_Unit)
Handle_Units_Unit_swigregister = _Units.Handle_Units_Unit_swigregister
Handle_Units_Unit_swigregister(Handle_Units_Unit)

def Handle_Units_Unit_DownCast(*args):
  return _Units.Handle_Units_Unit_DownCast(*args)
Handle_Units_Unit_DownCast = _Units.Handle_Units_Unit_DownCast

class Units_UnitsDictionary(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Returns an empty instance of UnitsDictionary.

        :rtype: None

        """
        _Units.Units_UnitsDictionary_swiginit(self,_Units.new_Units_UnitsDictionary(*args))
    def Creates(self, *args):
        """
        * Returns a UnitsDictionary object which contains the sequence of all the units you want to consider, physical quantity by physical quantity.

        :param afilename:
        :type afilename: char *
        :rtype: None

        """
        return _Units.Units_UnitsDictionary_Creates(self, *args)

    def Sequence(self, *args):
        """
        * Returns the head of the sequence of physical quantities.

        :rtype: Handle_Units_QuantitiesSequence

        """
        return _Units.Units_UnitsDictionary_Sequence(self, *args)

    def UpToDate(self, *args):
        """
        * Returns true if there has been no modification of the file Units.dat since the creation of the dictionary object, false otherwise.

        :rtype: bool

        """
        return _Units.Units_UnitsDictionary_UpToDate(self, *args)

    def ActiveUnit(self, *args):
        """
        * Returns for <aquantity> the active unit.

        :param aquantity:
        :type aquantity: char *
        :rtype: TCollection_AsciiString

        """
        return _Units.Units_UnitsDictionary_ActiveUnit(self, *args)

    def Dump(self, *args):
        """
        * Dumps only the sequence of quantities without the units if <alevel> is equal to zero, and for each quantity all the units stored if <alevel> is equal to one.

        :param alevel:
        :type alevel: int
        :rtype: None

        * Dumps for a designated physical dimensions <adimensions> all the previously stored units.

        :param adimensions:
        :type adimensions: Handle_Units_Dimensions &
        :rtype: None

        """
        return _Units.Units_UnitsDictionary_Dump(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Units_UnitsDictionary(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _Units.delete_Units_UnitsDictionary
Units_UnitsDictionary.Creates = new_instancemethod(_Units.Units_UnitsDictionary_Creates,None,Units_UnitsDictionary)
Units_UnitsDictionary.Sequence = new_instancemethod(_Units.Units_UnitsDictionary_Sequence,None,Units_UnitsDictionary)
Units_UnitsDictionary.UpToDate = new_instancemethod(_Units.Units_UnitsDictionary_UpToDate,None,Units_UnitsDictionary)
Units_UnitsDictionary.ActiveUnit = new_instancemethod(_Units.Units_UnitsDictionary_ActiveUnit,None,Units_UnitsDictionary)
Units_UnitsDictionary.Dump = new_instancemethod(_Units.Units_UnitsDictionary_Dump,None,Units_UnitsDictionary)
Units_UnitsDictionary_swigregister = _Units.Units_UnitsDictionary_swigregister
Units_UnitsDictionary_swigregister(Units_UnitsDictionary)

class Handle_Units_UnitsDictionary(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _Units.Handle_Units_UnitsDictionary_swiginit(self,_Units.new_Handle_Units_UnitsDictionary(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Units.Handle_Units_UnitsDictionary_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_UnitsDictionary
Handle_Units_UnitsDictionary.Nullify = new_instancemethod(_Units.Handle_Units_UnitsDictionary_Nullify,None,Handle_Units_UnitsDictionary)
Handle_Units_UnitsDictionary.IsNull = new_instancemethod(_Units.Handle_Units_UnitsDictionary_IsNull,None,Handle_Units_UnitsDictionary)
Handle_Units_UnitsDictionary.GetObject = new_instancemethod(_Units.Handle_Units_UnitsDictionary_GetObject,None,Handle_Units_UnitsDictionary)
Handle_Units_UnitsDictionary_swigregister = _Units.Handle_Units_UnitsDictionary_swigregister
Handle_Units_UnitsDictionary_swigregister(Handle_Units_UnitsDictionary)

def Handle_Units_UnitsDictionary_DownCast(*args):
  return _Units.Handle_Units_UnitsDictionary_DownCast(*args)
Handle_Units_UnitsDictionary_DownCast = _Units.Handle_Units_UnitsDictionary_DownCast

class Units_UnitsSequence(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        """
        _Units.Units_UnitsSequence_swiginit(self,_Units.new_Units_UnitsSequence(*args))
    def IsEmpty(self, *args):
        """
        :rtype: bool

        """
        return _Units.Units_UnitsSequence_IsEmpty(self, *args)

    def Length(self, *args):
        """
        :rtype: int

        """
        return _Units.Units_UnitsSequence_Length(self, *args)

    def Clear(self, *args):
        """
        :rtype: None

        """
        return _Units.Units_UnitsSequence_Clear(self, *args)

    def Append(self, *args):
        """
        :param anItem:
        :type anItem: Handle_Units_Unit &
        :rtype: None

        :param aSequence:
        :type aSequence: Handle_Units_UnitsSequence &
        :rtype: None

        """
        return _Units.Units_UnitsSequence_Append(self, *args)

    def Prepend(self, *args):
        """
        :param anItem:
        :type anItem: Handle_Units_Unit &
        :rtype: None

        :param aSequence:
        :type aSequence: Handle_Units_UnitsSequence &
        :rtype: None

        """
        return _Units.Units_UnitsSequence_Prepend(self, *args)

    def Reverse(self, *args):
        """
        :rtype: None

        """
        return _Units.Units_UnitsSequence_Reverse(self, *args)

    def InsertBefore(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :param anItem:
        :type anItem: Handle_Units_Unit &
        :rtype: None

        :param anIndex:
        :type anIndex: int
        :param aSequence:
        :type aSequence: Handle_Units_UnitsSequence &
        :rtype: None

        """
        return _Units.Units_UnitsSequence_InsertBefore(self, *args)

    def InsertAfter(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :param anItem:
        :type anItem: Handle_Units_Unit &
        :rtype: None

        :param anIndex:
        :type anIndex: int
        :param aSequence:
        :type aSequence: Handle_Units_UnitsSequence &
        :rtype: None

        """
        return _Units.Units_UnitsSequence_InsertAfter(self, *args)

    def Exchange(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :param anOtherIndex:
        :type anOtherIndex: int
        :rtype: None

        """
        return _Units.Units_UnitsSequence_Exchange(self, *args)

    def Split(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :rtype: Handle_Units_UnitsSequence

        """
        return _Units.Units_UnitsSequence_Split(self, *args)

    def SetValue(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :param anItem:
        :type anItem: Handle_Units_Unit &
        :rtype: None

        """
        return _Units.Units_UnitsSequence_SetValue(self, *args)

    def Value(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :rtype: Handle_Units_Unit

        """
        return _Units.Units_UnitsSequence_Value(self, *args)

    def ChangeValue(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :rtype: Handle_Units_Unit

        """
        return _Units.Units_UnitsSequence_ChangeValue(self, *args)

    def Remove(self, *args):
        """
        :param anIndex:
        :type anIndex: int
        :rtype: None

        :param fromIndex:
        :type fromIndex: int
        :param toIndex:
        :type toIndex: int
        :rtype: None

        """
        return _Units.Units_UnitsSequence_Remove(self, *args)

    def Sequence(self, *args):
        """
        :rtype: Units_UtsSequence

        """
        return _Units.Units_UnitsSequence_Sequence(self, *args)

    def ChangeSequence(self, *args):
        """
        :rtype: Units_UtsSequence

        """
        return _Units.Units_UnitsSequence_ChangeSequence(self, *args)

    def ShallowCopy(self, *args):
        """
        :rtype: Handle_Units_UnitsSequence

        """
        return _Units.Units_UnitsSequence_ShallowCopy(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Units_UnitsSequence(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _Units.delete_Units_UnitsSequence
Units_UnitsSequence.IsEmpty = new_instancemethod(_Units.Units_UnitsSequence_IsEmpty,None,Units_UnitsSequence)
Units_UnitsSequence.Length = new_instancemethod(_Units.Units_UnitsSequence_Length,None,Units_UnitsSequence)
Units_UnitsSequence.Clear = new_instancemethod(_Units.Units_UnitsSequence_Clear,None,Units_UnitsSequence)
Units_UnitsSequence.Append = new_instancemethod(_Units.Units_UnitsSequence_Append,None,Units_UnitsSequence)
Units_UnitsSequence.Prepend = new_instancemethod(_Units.Units_UnitsSequence_Prepend,None,Units_UnitsSequence)
Units_UnitsSequence.Reverse = new_instancemethod(_Units.Units_UnitsSequence_Reverse,None,Units_UnitsSequence)
Units_UnitsSequence.InsertBefore = new_instancemethod(_Units.Units_UnitsSequence_InsertBefore,None,Units_UnitsSequence)
Units_UnitsSequence.InsertAfter = new_instancemethod(_Units.Units_UnitsSequence_InsertAfter,None,Units_UnitsSequence)
Units_UnitsSequence.Exchange = new_instancemethod(_Units.Units_UnitsSequence_Exchange,None,Units_UnitsSequence)
Units_UnitsSequence.Split = new_instancemethod(_Units.Units_UnitsSequence_Split,None,Units_UnitsSequence)
Units_UnitsSequence.SetValue = new_instancemethod(_Units.Units_UnitsSequence_SetValue,None,Units_UnitsSequence)
Units_UnitsSequence.Value = new_instancemethod(_Units.Units_UnitsSequence_Value,None,Units_UnitsSequence)
Units_UnitsSequence.ChangeValue = new_instancemethod(_Units.Units_UnitsSequence_ChangeValue,None,Units_UnitsSequence)
Units_UnitsSequence.Remove = new_instancemethod(_Units.Units_UnitsSequence_Remove,None,Units_UnitsSequence)
Units_UnitsSequence.Sequence = new_instancemethod(_Units.Units_UnitsSequence_Sequence,None,Units_UnitsSequence)
Units_UnitsSequence.ChangeSequence = new_instancemethod(_Units.Units_UnitsSequence_ChangeSequence,None,Units_UnitsSequence)
Units_UnitsSequence.ShallowCopy = new_instancemethod(_Units.Units_UnitsSequence_ShallowCopy,None,Units_UnitsSequence)
Units_UnitsSequence_swigregister = _Units.Units_UnitsSequence_swigregister
Units_UnitsSequence_swigregister(Units_UnitsSequence)

class Handle_Units_UnitsSequence(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _Units.Handle_Units_UnitsSequence_swiginit(self,_Units.new_Handle_Units_UnitsSequence(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Units.Handle_Units_UnitsSequence_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_UnitsSequence
Handle_Units_UnitsSequence.Nullify = new_instancemethod(_Units.Handle_Units_UnitsSequence_Nullify,None,Handle_Units_UnitsSequence)
Handle_Units_UnitsSequence.IsNull = new_instancemethod(_Units.Handle_Units_UnitsSequence_IsNull,None,Handle_Units_UnitsSequence)
Handle_Units_UnitsSequence.GetObject = new_instancemethod(_Units.Handle_Units_UnitsSequence_GetObject,None,Handle_Units_UnitsSequence)
Handle_Units_UnitsSequence_swigregister = _Units.Handle_Units_UnitsSequence_swigregister
Handle_Units_UnitsSequence_swigregister(Handle_Units_UnitsSequence)

def Handle_Units_UnitsSequence_DownCast(*args):
  return _Units.Handle_Units_UnitsSequence_DownCast(*args)
Handle_Units_UnitsSequence_DownCast = _Units.Handle_Units_UnitsSequence_DownCast

class Units_UnitsSystem(OCC.MMgt.MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Returns an instance of UnitsSystem initialized to the S.I. units system.

        :rtype: None

        * Returns an instance of UnitsSystem initialized to the S.I. units system upgraded by the base system units decription //!	 	file. Attempts to find the four following files: $CSF_`aName`Defaults/.aName $CSF_`aName`SiteDefaults/.aName $CSF_`aName`GroupDefaults/.aName $CSF_`aName`UserDefaults/.aName //!		See : Resource_Manager for the description of this file.

        :param aName:
        :type aName: char *
        :param Verbose: default value is Standard_False
        :type Verbose: bool
        :rtype: None

        """
        _Units.Units_UnitsSystem_swiginit(self,_Units.new_Units_UnitsSystem(*args))
    def QuantitiesSequence(self, *args):
        """
        * Returns the sequence of refined quantities.

        :rtype: Handle_Units_QuantitiesSequence

        """
        return _Units.Units_UnitsSystem_QuantitiesSequence(self, *args)

    def ActiveUnitsSequence(self, *args):
        """
        * Returns a sequence of integer in correspondance with the sequence of quantities, which indicates, for each redefined quantity, the index into the sequence of units, of the active unit.

        :rtype: Handle_TColStd_HSequenceOfInteger

        """
        return _Units.Units_UnitsSystem_ActiveUnitsSequence(self, *args)

    def Specify(self, *args):
        """
        * Specifies for <aquantity> the unit <aunit> used.

        :param aquantity:
        :type aquantity: char *
        :param aunit:
        :type aunit: char *
        :rtype: None

        """
        return _Units.Units_UnitsSystem_Specify(self, *args)

    def Remove(self, *args):
        """
        * Removes for <aquantity> the unit <aunit> used.

        :param aquantity:
        :type aquantity: char *
        :param aunit:
        :type aunit: char *
        :rtype: None

        """
        return _Units.Units_UnitsSystem_Remove(self, *args)

    def Activate(self, *args):
        """
        * Specifies for <aquantity> the unit <aunit> used.

        :param aquantity:
        :type aquantity: char *
        :param aunit:
        :type aunit: char *
        :rtype: None

        """
        return _Units.Units_UnitsSystem_Activate(self, *args)

    def Activates(self, *args):
        """
        * Activates the first unit of all defined system quantities

        :rtype: None

        """
        return _Units.Units_UnitsSystem_Activates(self, *args)

    def ActiveUnit(self, *args):
        """
        * Returns for <aquantity> the active unit.

        :param aquantity:
        :type aquantity: char *
        :rtype: TCollection_AsciiString

        """
        return _Units.Units_UnitsSystem_ActiveUnit(self, *args)

    def ConvertValueToUserSystem(self, *args):
        """
        * Converts a real value <avalue> from the unit <aunit> belonging to the physical dimensions <aquantity> to the corresponding unit of the user system.

        :param aquantity:
        :type aquantity: char *
        :param avalue:
        :type avalue: float
        :param aunit:
        :type aunit: char *
        :rtype: float

        """
        return _Units.Units_UnitsSystem_ConvertValueToUserSystem(self, *args)

    def ConvertSIValueToUserSystem(self, *args):
        """
        * Converts the real value <avalue> from the S.I. system of units to the user system of units. <aquantity> is the physical dimensions of the measurement.

        :param aquantity:
        :type aquantity: char *
        :param avalue:
        :type avalue: float
        :rtype: float

        """
        return _Units.Units_UnitsSystem_ConvertSIValueToUserSystem(self, *args)

    def ConvertUserSystemValueToSI(self, *args):
        """
        * Converts the real value <avalue> from the user system of units to the S.I. system of units. <aquantity> is the physical dimensions of the measurement.

        :param aquantity:
        :type aquantity: char *
        :param avalue:
        :type avalue: float
        :rtype: float

        """
        return _Units.Units_UnitsSystem_ConvertUserSystemValueToSI(self, *args)

    def Dump(self, *args):
        """
        :rtype: None

        """
        return _Units.Units_UnitsSystem_Dump(self, *args)

    def IsEmpty(self, *args):
        """
        * Returns True if no units has been defined in the system.

        :rtype: bool

        """
        return _Units.Units_UnitsSystem_IsEmpty(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Units_UnitsSystem(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _Units.delete_Units_UnitsSystem
Units_UnitsSystem.QuantitiesSequence = new_instancemethod(_Units.Units_UnitsSystem_QuantitiesSequence,None,Units_UnitsSystem)
Units_UnitsSystem.ActiveUnitsSequence = new_instancemethod(_Units.Units_UnitsSystem_ActiveUnitsSequence,None,Units_UnitsSystem)
Units_UnitsSystem.Specify = new_instancemethod(_Units.Units_UnitsSystem_Specify,None,Units_UnitsSystem)
Units_UnitsSystem.Remove = new_instancemethod(_Units.Units_UnitsSystem_Remove,None,Units_UnitsSystem)
Units_UnitsSystem.Activate = new_instancemethod(_Units.Units_UnitsSystem_Activate,None,Units_UnitsSystem)
Units_UnitsSystem.Activates = new_instancemethod(_Units.Units_UnitsSystem_Activates,None,Units_UnitsSystem)
Units_UnitsSystem.ActiveUnit = new_instancemethod(_Units.Units_UnitsSystem_ActiveUnit,None,Units_UnitsSystem)
Units_UnitsSystem.ConvertValueToUserSystem = new_instancemethod(_Units.Units_UnitsSystem_ConvertValueToUserSystem,None,Units_UnitsSystem)
Units_UnitsSystem.ConvertSIValueToUserSystem = new_instancemethod(_Units.Units_UnitsSystem_ConvertSIValueToUserSystem,None,Units_UnitsSystem)
Units_UnitsSystem.ConvertUserSystemValueToSI = new_instancemethod(_Units.Units_UnitsSystem_ConvertUserSystemValueToSI,None,Units_UnitsSystem)
Units_UnitsSystem.Dump = new_instancemethod(_Units.Units_UnitsSystem_Dump,None,Units_UnitsSystem)
Units_UnitsSystem.IsEmpty = new_instancemethod(_Units.Units_UnitsSystem_IsEmpty,None,Units_UnitsSystem)
Units_UnitsSystem_swigregister = _Units.Units_UnitsSystem_swigregister
Units_UnitsSystem_swigregister(Units_UnitsSystem)

class Handle_Units_UnitsSystem(OCC.MMgt.Handle_MMgt_TShared):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _Units.Handle_Units_UnitsSystem_swiginit(self,_Units.new_Handle_Units_UnitsSystem(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Units.Handle_Units_UnitsSystem_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_UnitsSystem
Handle_Units_UnitsSystem.Nullify = new_instancemethod(_Units.Handle_Units_UnitsSystem_Nullify,None,Handle_Units_UnitsSystem)
Handle_Units_UnitsSystem.IsNull = new_instancemethod(_Units.Handle_Units_UnitsSystem_IsNull,None,Handle_Units_UnitsSystem)
Handle_Units_UnitsSystem.GetObject = new_instancemethod(_Units.Handle_Units_UnitsSystem_GetObject,None,Handle_Units_UnitsSystem)
Handle_Units_UnitsSystem_swigregister = _Units.Handle_Units_UnitsSystem_swigregister
Handle_Units_UnitsSystem_swigregister(Handle_Units_UnitsSystem)

def Handle_Units_UnitsSystem_DownCast(*args):
  return _Units.Handle_Units_UnitsSystem_DownCast(*args)
Handle_Units_UnitsSystem_DownCast = _Units.Handle_Units_UnitsSystem_DownCast

class Units_UtsSequence(OCC.TCollection.TCollection_BaseSequence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        """
        _Units.Units_UtsSequence_swiginit(self,_Units.new_Units_UtsSequence(*args))
    def Clear(self, *args):
        """
        :rtype: None

        """
        return _Units.Units_UtsSequence_Clear(self, *args)

    def Assign(self, *args):
        """
        :param Other:
        :type Other: Units_UtsSequence &
        :rtype: Units_UtsSequence

        """
        return _Units.Units_UtsSequence_Assign(self, *args)

    def Set(self, *args):
        """
        :param Other:
        :type Other: Units_UtsSequence &
        :rtype: Units_UtsSequence

        """
        return _Units.Units_UtsSequence_Set(self, *args)

    def Append(self, *args):
        """
        :param T:
        :type T: Handle_Units_Unit &
        :rtype: None

        :param S:
        :type S: Units_UtsSequence &
        :rtype: None

        """
        return _Units.Units_UtsSequence_Append(self, *args)

    def Prepend(self, *args):
        """
        :param T:
        :type T: Handle_Units_Unit &
        :rtype: None

        :param S:
        :type S: Units_UtsSequence &
        :rtype: None

        """
        return _Units.Units_UtsSequence_Prepend(self, *args)

    def InsertBefore(self, *args):
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_Units_Unit &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: Units_UtsSequence &
        :rtype: None

        """
        return _Units.Units_UtsSequence_InsertBefore(self, *args)

    def InsertAfter(self, *args):
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Handle_Units_Unit &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: Units_UtsSequence &
        :rtype: None

        """
        return _Units.Units_UtsSequence_InsertAfter(self, *args)

    def First(self, *args):
        """
        :rtype: Handle_Units_Unit

        """
        return _Units.Units_UtsSequence_First(self, *args)

    def Last(self, *args):
        """
        :rtype: Handle_Units_Unit

        """
        return _Units.Units_UtsSequence_Last(self, *args)

    def Split(self, *args):
        """
        :param Index:
        :type Index: int
        :param Sub:
        :type Sub: Units_UtsSequence &
        :rtype: None

        """
        return _Units.Units_UtsSequence_Split(self, *args)

    def Value(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_Units_Unit

        """
        return _Units.Units_UtsSequence_Value(self, *args)

    def SetValue(self, *args):
        """
        :param Index:
        :type Index: int
        :param I:
        :type I: Handle_Units_Unit &
        :rtype: None

        """
        return _Units.Units_UtsSequence_SetValue(self, *args)

    def ChangeValue(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Handle_Units_Unit

        """
        return _Units.Units_UtsSequence_ChangeValue(self, *args)

    def Remove(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: None

        :param FromIndex:
        :type FromIndex: int
        :param ToIndex:
        :type ToIndex: int
        :rtype: None

        """
        return _Units.Units_UtsSequence_Remove(self, *args)

    __swig_destroy__ = _Units.delete_Units_UtsSequence
Units_UtsSequence.Clear = new_instancemethod(_Units.Units_UtsSequence_Clear,None,Units_UtsSequence)
Units_UtsSequence.Assign = new_instancemethod(_Units.Units_UtsSequence_Assign,None,Units_UtsSequence)
Units_UtsSequence.Set = new_instancemethod(_Units.Units_UtsSequence_Set,None,Units_UtsSequence)
Units_UtsSequence.Append = new_instancemethod(_Units.Units_UtsSequence_Append,None,Units_UtsSequence)
Units_UtsSequence.Prepend = new_instancemethod(_Units.Units_UtsSequence_Prepend,None,Units_UtsSequence)
Units_UtsSequence.InsertBefore = new_instancemethod(_Units.Units_UtsSequence_InsertBefore,None,Units_UtsSequence)
Units_UtsSequence.InsertAfter = new_instancemethod(_Units.Units_UtsSequence_InsertAfter,None,Units_UtsSequence)
Units_UtsSequence.First = new_instancemethod(_Units.Units_UtsSequence_First,None,Units_UtsSequence)
Units_UtsSequence.Last = new_instancemethod(_Units.Units_UtsSequence_Last,None,Units_UtsSequence)
Units_UtsSequence.Split = new_instancemethod(_Units.Units_UtsSequence_Split,None,Units_UtsSequence)
Units_UtsSequence.Value = new_instancemethod(_Units.Units_UtsSequence_Value,None,Units_UtsSequence)
Units_UtsSequence.SetValue = new_instancemethod(_Units.Units_UtsSequence_SetValue,None,Units_UtsSequence)
Units_UtsSequence.ChangeValue = new_instancemethod(_Units.Units_UtsSequence_ChangeValue,None,Units_UtsSequence)
Units_UtsSequence.Remove = new_instancemethod(_Units.Units_UtsSequence_Remove,None,Units_UtsSequence)
Units_UtsSequence_swigregister = _Units.Units_UtsSequence_swigregister
Units_UtsSequence_swigregister(Units_UtsSequence)

class Units_MathSentence(Units_Sentence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Creates and returns a MathSentence object. The string <astring> describes an algebraic formula in natural language.

        :param astring:
        :type astring: char *
        :rtype: None

        """
        _Units.Units_MathSentence_swiginit(self,_Units.new_Units_MathSentence(*args))
    __swig_destroy__ = _Units.delete_Units_MathSentence
Units_MathSentence_swigregister = _Units.Units_MathSentence_swigregister
Units_MathSentence_swigregister(Units_MathSentence)

class Units_ShiftedToken(Units_Token):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Creates and returns a shifted token. <aword> is a string containing the available word, <amean> gives the signification of the token, <avalue> is the numeric value of the dimension, <amove> is the gap, and <adimensions> is the dimension of the given word <aword>.

        :param aword:
        :type aword: char *
        :param amean:
        :type amean: char *
        :param avalue:
        :type avalue: float
        :param amove:
        :type amove: float
        :param adimensions:
        :type adimensions: Handle_Units_Dimensions &
        :rtype: None

        """
        _Units.Units_ShiftedToken_swiginit(self,_Units.new_Units_ShiftedToken(*args))
    def Move(self, *args):
        """
        * Returns the gap <themove>

        :rtype: float

        """
        return _Units.Units_ShiftedToken_Move(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Units_ShiftedToken(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _Units.delete_Units_ShiftedToken
Units_ShiftedToken.Move = new_instancemethod(_Units.Units_ShiftedToken_Move,None,Units_ShiftedToken)
Units_ShiftedToken_swigregister = _Units.Units_ShiftedToken_swigregister
Units_ShiftedToken_swigregister(Units_ShiftedToken)

class Handle_Units_ShiftedToken(Handle_Units_Token):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _Units.Handle_Units_ShiftedToken_swiginit(self,_Units.new_Handle_Units_ShiftedToken(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Units.Handle_Units_ShiftedToken_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_ShiftedToken
Handle_Units_ShiftedToken.Nullify = new_instancemethod(_Units.Handle_Units_ShiftedToken_Nullify,None,Handle_Units_ShiftedToken)
Handle_Units_ShiftedToken.IsNull = new_instancemethod(_Units.Handle_Units_ShiftedToken_IsNull,None,Handle_Units_ShiftedToken)
Handle_Units_ShiftedToken.GetObject = new_instancemethod(_Units.Handle_Units_ShiftedToken_GetObject,None,Handle_Units_ShiftedToken)
Handle_Units_ShiftedToken_swigregister = _Units.Handle_Units_ShiftedToken_swigregister
Handle_Units_ShiftedToken_swigregister(Handle_Units_ShiftedToken)

def Handle_Units_ShiftedToken_DownCast(*args):
  return _Units.Handle_Units_ShiftedToken_DownCast(*args)
Handle_Units_ShiftedToken_DownCast = _Units.Handle_Units_ShiftedToken_DownCast

class Units_ShiftedUnit(Units_Unit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Creates and returns a shifted unit. <aname> is the name of the unit, <asymbol> is the usual abbreviation of the unit, <avalue> is the value in relation to the International System of Units, and <amove> is the gap in relation to another unit.  For example Celcius dregee of temperature is an instance of ShiftedUnit with <avalue> equal to 1. and <amove> equal to 273.15.

        :param aname:
        :type aname: char *
        :param asymbol:
        :type asymbol: char *
        :param avalue:
        :type avalue: float
        :param amove:
        :type amove: float
        :param aquantity:
        :type aquantity: Handle_Units_Quantity &
        :rtype: None

        * Creates and returns a unit. <aname> is the name of the unit, <asymbol> is the usual abbreviation of the unit.

        :param aname:
        :type aname: char *
        :param asymbol:
        :type asymbol: char *
        :rtype: None

        * Creates and returns a unit. <aname> is the name of the unit.

        :param aname:
        :type aname: char *
        :rtype: None

        """
        _Units.Units_ShiftedUnit_swiginit(self,_Units.new_Units_ShiftedUnit(*args))
    def Move(self, *args):
        """
        * Sets the field <themove> to <amove>

        :param amove:
        :type amove: float
        :rtype: None

        * Returns the shifted value <themove>.

        :rtype: float

        """
        return _Units.Units_ShiftedUnit_Move(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Units_ShiftedUnit(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _Units.delete_Units_ShiftedUnit
Units_ShiftedUnit.Move = new_instancemethod(_Units.Units_ShiftedUnit_Move,None,Units_ShiftedUnit)
Units_ShiftedUnit_swigregister = _Units.Units_ShiftedUnit_swigregister
Units_ShiftedUnit_swigregister(Units_ShiftedUnit)

class Handle_Units_ShiftedUnit(Handle_Units_Unit):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _Units.Handle_Units_ShiftedUnit_swiginit(self,_Units.new_Handle_Units_ShiftedUnit(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Units.Handle_Units_ShiftedUnit_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_ShiftedUnit
Handle_Units_ShiftedUnit.Nullify = new_instancemethod(_Units.Handle_Units_ShiftedUnit_Nullify,None,Handle_Units_ShiftedUnit)
Handle_Units_ShiftedUnit.IsNull = new_instancemethod(_Units.Handle_Units_ShiftedUnit_IsNull,None,Handle_Units_ShiftedUnit)
Handle_Units_ShiftedUnit.GetObject = new_instancemethod(_Units.Handle_Units_ShiftedUnit_GetObject,None,Handle_Units_ShiftedUnit)
Handle_Units_ShiftedUnit_swigregister = _Units.Handle_Units_ShiftedUnit_swigregister
Handle_Units_ShiftedUnit_swigregister(Handle_Units_ShiftedUnit)

def Handle_Units_ShiftedUnit_DownCast(*args):
  return _Units.Handle_Units_ShiftedUnit_DownCast(*args)
Handle_Units_ShiftedUnit_DownCast = _Units.Handle_Units_ShiftedUnit_DownCast

class Units_UnitSentence(Units_Sentence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Creates and returns a UnitSentence. The string <astring> describes in natural language the unit or the composed unit to be analysed.

        :param astring:
        :type astring: char *
        :rtype: None

        * Creates and returns a UnitSentence. The string <astring> describes in natural language the unit to be analysed. The sequence of physical quantities <asequenceofquantities> describes the available dictionary of units you want to use.

        :param astring:
        :type astring: char *
        :param aquantitiessequence:
        :type aquantitiessequence: Handle_Units_QuantitiesSequence &
        :rtype: None

        """
        _Units.Units_UnitSentence_swiginit(self,_Units.new_Units_UnitSentence(*args))
    def Analyse(self, *args):
        """
        * Analyzes the sequence of tokens created by the constructor to find the true significance of each token.

        :rtype: None

        """
        return _Units.Units_UnitSentence_Analyse(self, *args)

    def SetUnits(self, *args):
        """
        * For each token which represents a unit, finds in the sequence of physical quantities all the characteristics of the unit found.

        :param aquantitiessequence:
        :type aquantitiessequence: Handle_Units_QuantitiesSequence &
        :rtype: None

        """
        return _Units.Units_UnitSentence_SetUnits(self, *args)

    __swig_destroy__ = _Units.delete_Units_UnitSentence
Units_UnitSentence.Analyse = new_instancemethod(_Units.Units_UnitSentence_Analyse,None,Units_UnitSentence)
Units_UnitSentence.SetUnits = new_instancemethod(_Units.Units_UnitSentence_SetUnits,None,Units_UnitSentence)
Units_UnitSentence_swigregister = _Units.Units_UnitSentence_swigregister
Units_UnitSentence_swigregister(Units_UnitSentence)

class Units_UnitsLexicon(Units_Lexicon):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Returns an empty instance of UnitsLexicon

        :rtype: None

        """
        _Units.Units_UnitsLexicon_swiginit(self,_Units.new_Units_UnitsLexicon(*args))
    def Creates(self, *args):
        """
        * Reads the files <afilename1> and <afilename2> to create a sequence of tokens stored in <thesequenceoftokens>.

        :param afilename1:
        :type afilename1: char *
        :param afilename2:
        :type afilename2: char *
        :param amode: default value is Standard_True
        :type amode: bool
        :rtype: None

        """
        return _Units.Units_UnitsLexicon_Creates(self, *args)

    def FileName2(self, *args):
        """
        * Returns in a AsciiString from TCollection the name of the file.

        :rtype: TCollection_AsciiString

        """
        return _Units.Units_UnitsLexicon_FileName2(self, *args)

    def Dump(self, *args):
        """
        * Useful for debugging.

        :rtype: None

        """
        return _Units.Units_UnitsLexicon_Dump(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Units_UnitsLexicon(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _Units.delete_Units_UnitsLexicon
Units_UnitsLexicon.Creates = new_instancemethod(_Units.Units_UnitsLexicon_Creates,None,Units_UnitsLexicon)
Units_UnitsLexicon.FileName2 = new_instancemethod(_Units.Units_UnitsLexicon_FileName2,None,Units_UnitsLexicon)
Units_UnitsLexicon.Dump = new_instancemethod(_Units.Units_UnitsLexicon_Dump,None,Units_UnitsLexicon)
Units_UnitsLexicon_swigregister = _Units.Units_UnitsLexicon_swigregister
Units_UnitsLexicon_swigregister(Units_UnitsLexicon)

class Handle_Units_UnitsLexicon(Handle_Units_Lexicon):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _Units.Handle_Units_UnitsLexicon_swiginit(self,_Units.new_Handle_Units_UnitsLexicon(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Units.Handle_Units_UnitsLexicon_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_UnitsLexicon
Handle_Units_UnitsLexicon.Nullify = new_instancemethod(_Units.Handle_Units_UnitsLexicon_Nullify,None,Handle_Units_UnitsLexicon)
Handle_Units_UnitsLexicon.IsNull = new_instancemethod(_Units.Handle_Units_UnitsLexicon_IsNull,None,Handle_Units_UnitsLexicon)
Handle_Units_UnitsLexicon.GetObject = new_instancemethod(_Units.Handle_Units_UnitsLexicon_GetObject,None,Handle_Units_UnitsLexicon)
Handle_Units_UnitsLexicon_swigregister = _Units.Handle_Units_UnitsLexicon_swigregister
Handle_Units_UnitsLexicon_swigregister(Handle_Units_UnitsLexicon)

def Handle_Units_UnitsLexicon_DownCast(*args):
  return _Units.Handle_Units_UnitsLexicon_DownCast(*args)
Handle_Units_UnitsLexicon_DownCast = _Units.Handle_Units_UnitsLexicon_DownCast



