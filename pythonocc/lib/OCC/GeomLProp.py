# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _GeomLProp.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_GeomLProp', [dirname(__file__)])
        except ImportError:
            import _GeomLProp
            return _GeomLProp
        if fp is not None:
            try:
                _mod = imp.load_module('_GeomLProp', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _GeomLProp = swig_import_helper()
    del swig_import_helper
else:
    import _GeomLProp
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GeomLProp.delete_SwigPyIterator
    def __iter__(self): return self
SwigPyIterator.value = new_instancemethod(_GeomLProp.SwigPyIterator_value,None,SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_GeomLProp.SwigPyIterator_incr,None,SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_GeomLProp.SwigPyIterator_decr,None,SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_GeomLProp.SwigPyIterator_distance,None,SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_GeomLProp.SwigPyIterator_equal,None,SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_GeomLProp.SwigPyIterator_copy,None,SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_GeomLProp.SwigPyIterator_next,None,SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_GeomLProp.SwigPyIterator___next__,None,SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_GeomLProp.SwigPyIterator_previous,None,SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_GeomLProp.SwigPyIterator_advance,None,SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_GeomLProp.SwigPyIterator___eq__,None,SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_GeomLProp.SwigPyIterator___ne__,None,SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_GeomLProp.SwigPyIterator___iadd__,None,SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_GeomLProp.SwigPyIterator___isub__,None,SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_GeomLProp.SwigPyIterator___add__,None,SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_GeomLProp.SwigPyIterator___sub__,None,SwigPyIterator)
SwigPyIterator_swigregister = _GeomLProp.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import OCC.Geom
import OCC.MMgt
import OCC.Standard
import OCC.gp
import OCC.TCollection
import OCC.GeomAbs
import OCC.TColgp
import OCC.TColStd
def register_handle(handle, base_object):
    """
    Inserts the handle into the base object to
    prevent memory corruption in certain cases
    """
    try:
        if base_object.IsKind("Standard_Transient"):
            base_object.thisHandle = handle
            base_object.thisown = False
    except:
        pass

class geomlprop(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Continuity(*args):
        """
        * Computes the regularity at the junction between C1 and C2. The booleans r1 and r2 are true if the curves must be taken reversed. The point u1 on C1 and the point u2 on C2 must be confused. tl and ta are the linear and angular tolerance used two compare the derivative.

        :param C1:
        :type C1: Handle_Geom_Curve &
        :param C2:
        :type C2: Handle_Geom_Curve &
        :param u1:
        :type u1: float
        :param u2:
        :type u2: float
        :param r1:
        :type r1: bool
        :param r2:
        :type r2: bool
        :param tl:
        :type tl: float
        :param ta:
        :type ta: float
        :rtype: GeomAbs_Shape

        * The same as preciding but using the standard tolerances from package Precision.

        :param C1:
        :type C1: Handle_Geom_Curve &
        :param C2:
        :type C2: Handle_Geom_Curve &
        :param u1:
        :type u1: float
        :param u2:
        :type u2: float
        :param r1:
        :type r1: bool
        :param r2:
        :type r2: bool
        :rtype: GeomAbs_Shape

        """
        return _GeomLProp.geomlprop_Continuity(*args)

    Continuity = staticmethod(Continuity)
    def __init__(self): 
        _GeomLProp.geomlprop_swiginit(self,_GeomLProp.new_geomlprop())
    __swig_destroy__ = _GeomLProp.delete_geomlprop
geomlprop_swigregister = _GeomLProp.geomlprop_swigregister
geomlprop_swigregister(geomlprop)

def geomlprop_Continuity(*args):
  """
    * Computes the regularity at the junction between C1 and C2. The booleans r1 and r2 are true if the curves must be taken reversed. The point u1 on C1 and the point u2 on C2 must be confused. tl and ta are the linear and angular tolerance used two compare the derivative.

    :param C1:
    :type C1: Handle_Geom_Curve &
    :param C2:
    :type C2: Handle_Geom_Curve &
    :param u1:
    :type u1: float
    :param u2:
    :type u2: float
    :param r1:
    :type r1: bool
    :param r2:
    :type r2: bool
    :param tl:
    :type tl: float
    :param ta:
    :type ta: float
    :rtype: GeomAbs_Shape

    * The same as preciding but using the standard tolerances from package Precision.

    :param C1:
    :type C1: Handle_Geom_Curve &
    :param C2:
    :type C2: Handle_Geom_Curve &
    :param u1:
    :type u1: float
    :param u2:
    :type u2: float
    :param r1:
    :type r1: bool
    :param r2:
    :type r2: bool
    :rtype: GeomAbs_Shape

    """
  return _GeomLProp.geomlprop_Continuity(*args)

class GeomLProp_CLProps(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param C:
        :type C: Handle_Geom_Curve &
        :param N:
        :type N: int
        :param Resolution:
        :type Resolution: float
        :rtype: None

        :param C:
        :type C: Handle_Geom_Curve &
        :param U:
        :type U: float
        :param N:
        :type N: int
        :param Resolution:
        :type Resolution: float
        :rtype: None

        :param N:
        :type N: int
        :param Resolution:
        :type Resolution: float
        :rtype: None

        """
        _GeomLProp.GeomLProp_CLProps_swiginit(self,_GeomLProp.new_GeomLProp_CLProps(*args))
    def SetParameter(self, *args):
        """
        :param U:
        :type U: float
        :rtype: None

        """
        return _GeomLProp.GeomLProp_CLProps_SetParameter(self, *args)

    def SetCurve(self, *args):
        """
        :param C:
        :type C: Handle_Geom_Curve &
        :rtype: None

        """
        return _GeomLProp.GeomLProp_CLProps_SetCurve(self, *args)

    def Value(self, *args):
        """
        :rtype: gp_Pnt

        """
        return _GeomLProp.GeomLProp_CLProps_Value(self, *args)

    def D1(self, *args):
        """
        :rtype: gp_Vec

        """
        return _GeomLProp.GeomLProp_CLProps_D1(self, *args)

    def D2(self, *args):
        """
        :rtype: gp_Vec

        """
        return _GeomLProp.GeomLProp_CLProps_D2(self, *args)

    def D3(self, *args):
        """
        :rtype: gp_Vec

        """
        return _GeomLProp.GeomLProp_CLProps_D3(self, *args)

    def IsTangentDefined(self, *args):
        """
        :rtype: bool

        """
        return _GeomLProp.GeomLProp_CLProps_IsTangentDefined(self, *args)

    def Tangent(self, *args):
        """
        :param D:
        :type D: gp_Dir
        :rtype: None

        """
        return _GeomLProp.GeomLProp_CLProps_Tangent(self, *args)

    def Curvature(self, *args):
        """
        :rtype: float

        """
        return _GeomLProp.GeomLProp_CLProps_Curvature(self, *args)

    def Normal(self, *args):
        """
        :param N:
        :type N: gp_Dir
        :rtype: None

        """
        return _GeomLProp.GeomLProp_CLProps_Normal(self, *args)

    def CentreOfCurvature(self, *args):
        """
        :param P:
        :type P: gp_Pnt
        :rtype: None

        """
        return _GeomLProp.GeomLProp_CLProps_CentreOfCurvature(self, *args)

    __swig_destroy__ = _GeomLProp.delete_GeomLProp_CLProps
GeomLProp_CLProps.SetParameter = new_instancemethod(_GeomLProp.GeomLProp_CLProps_SetParameter,None,GeomLProp_CLProps)
GeomLProp_CLProps.SetCurve = new_instancemethod(_GeomLProp.GeomLProp_CLProps_SetCurve,None,GeomLProp_CLProps)
GeomLProp_CLProps.Value = new_instancemethod(_GeomLProp.GeomLProp_CLProps_Value,None,GeomLProp_CLProps)
GeomLProp_CLProps.D1 = new_instancemethod(_GeomLProp.GeomLProp_CLProps_D1,None,GeomLProp_CLProps)
GeomLProp_CLProps.D2 = new_instancemethod(_GeomLProp.GeomLProp_CLProps_D2,None,GeomLProp_CLProps)
GeomLProp_CLProps.D3 = new_instancemethod(_GeomLProp.GeomLProp_CLProps_D3,None,GeomLProp_CLProps)
GeomLProp_CLProps.IsTangentDefined = new_instancemethod(_GeomLProp.GeomLProp_CLProps_IsTangentDefined,None,GeomLProp_CLProps)
GeomLProp_CLProps.Tangent = new_instancemethod(_GeomLProp.GeomLProp_CLProps_Tangent,None,GeomLProp_CLProps)
GeomLProp_CLProps.Curvature = new_instancemethod(_GeomLProp.GeomLProp_CLProps_Curvature,None,GeomLProp_CLProps)
GeomLProp_CLProps.Normal = new_instancemethod(_GeomLProp.GeomLProp_CLProps_Normal,None,GeomLProp_CLProps)
GeomLProp_CLProps.CentreOfCurvature = new_instancemethod(_GeomLProp.GeomLProp_CLProps_CentreOfCurvature,None,GeomLProp_CLProps)
GeomLProp_CLProps_swigregister = _GeomLProp.GeomLProp_CLProps_swigregister
GeomLProp_CLProps_swigregister(GeomLProp_CLProps)

class GeomLProp_CurveTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Value(*args):
        """
        * Computes the point <P> of parameter <U> on the curve <C>.

        :param C:
        :type C: Handle_Geom_Curve &
        :param U:
        :type U: float
        :param P:
        :type P: gp_Pnt
        :rtype: void

        """
        return _GeomLProp.GeomLProp_CurveTool_Value(*args)

    Value = staticmethod(Value)
    def D1(*args):
        """
        * Computes the point <P> and first derivative <V1> of parameter <U> on the curve <C>.

        :param C:
        :type C: Handle_Geom_Curve &
        :param U:
        :type U: float
        :param P:
        :type P: gp_Pnt
        :param V1:
        :type V1: gp_Vec
        :rtype: void

        """
        return _GeomLProp.GeomLProp_CurveTool_D1(*args)

    D1 = staticmethod(D1)
    def D2(*args):
        """
        * Computes the point <P>, the first derivative <V1> and second derivative <V2> of parameter <U> on the curve <C>.

        :param C:
        :type C: Handle_Geom_Curve &
        :param U:
        :type U: float
        :param P:
        :type P: gp_Pnt
        :param V1:
        :type V1: gp_Vec
        :param V2:
        :type V2: gp_Vec
        :rtype: void

        """
        return _GeomLProp.GeomLProp_CurveTool_D2(*args)

    D2 = staticmethod(D2)
    def D3(*args):
        """
        * Computes the point <P>, the first derivative <V1>, the second derivative <V2> and third derivative <V3> of parameter <U> on the curve <C>.

        :param C:
        :type C: Handle_Geom_Curve &
        :param U:
        :type U: float
        :param P:
        :type P: gp_Pnt
        :param V1:
        :type V1: gp_Vec
        :param V2:
        :type V2: gp_Vec
        :param V3:
        :type V3: gp_Vec
        :rtype: void

        """
        return _GeomLProp.GeomLProp_CurveTool_D3(*args)

    D3 = staticmethod(D3)
    def Continuity(*args):
        """
        * returns the order of continuity of the curve <C>. returns 1 : first derivative only is computable returns 2 : first and second derivative only are computable. returns 3 : first, second and third are computable.

        :param C:
        :type C: Handle_Geom_Curve &
        :rtype: int

        """
        return _GeomLProp.GeomLProp_CurveTool_Continuity(*args)

    Continuity = staticmethod(Continuity)
    def FirstParameter(*args):
        """
        * returns the first parameter bound of the curve.

        :param C:
        :type C: Handle_Geom_Curve &
        :rtype: float

        """
        return _GeomLProp.GeomLProp_CurveTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)
    def LastParameter(*args):
        """
        * returns the last parameter bound of the curve. FirstParameter must be less than LastParamenter.

        :param C:
        :type C: Handle_Geom_Curve &
        :rtype: float

        """
        return _GeomLProp.GeomLProp_CurveTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)
    def __init__(self): 
        _GeomLProp.GeomLProp_CurveTool_swiginit(self,_GeomLProp.new_GeomLProp_CurveTool())
    __swig_destroy__ = _GeomLProp.delete_GeomLProp_CurveTool
GeomLProp_CurveTool_swigregister = _GeomLProp.GeomLProp_CurveTool_swigregister
GeomLProp_CurveTool_swigregister(GeomLProp_CurveTool)

def GeomLProp_CurveTool_Value(*args):
  """
    * Computes the point <P> of parameter <U> on the curve <C>.

    :param C:
    :type C: Handle_Geom_Curve &
    :param U:
    :type U: float
    :param P:
    :type P: gp_Pnt
    :rtype: void

    """
  return _GeomLProp.GeomLProp_CurveTool_Value(*args)

def GeomLProp_CurveTool_D1(*args):
  """
    * Computes the point <P> and first derivative <V1> of parameter <U> on the curve <C>.

    :param C:
    :type C: Handle_Geom_Curve &
    :param U:
    :type U: float
    :param P:
    :type P: gp_Pnt
    :param V1:
    :type V1: gp_Vec
    :rtype: void

    """
  return _GeomLProp.GeomLProp_CurveTool_D1(*args)

def GeomLProp_CurveTool_D2(*args):
  """
    * Computes the point <P>, the first derivative <V1> and second derivative <V2> of parameter <U> on the curve <C>.

    :param C:
    :type C: Handle_Geom_Curve &
    :param U:
    :type U: float
    :param P:
    :type P: gp_Pnt
    :param V1:
    :type V1: gp_Vec
    :param V2:
    :type V2: gp_Vec
    :rtype: void

    """
  return _GeomLProp.GeomLProp_CurveTool_D2(*args)

def GeomLProp_CurveTool_D3(*args):
  """
    * Computes the point <P>, the first derivative <V1>, the second derivative <V2> and third derivative <V3> of parameter <U> on the curve <C>.

    :param C:
    :type C: Handle_Geom_Curve &
    :param U:
    :type U: float
    :param P:
    :type P: gp_Pnt
    :param V1:
    :type V1: gp_Vec
    :param V2:
    :type V2: gp_Vec
    :param V3:
    :type V3: gp_Vec
    :rtype: void

    """
  return _GeomLProp.GeomLProp_CurveTool_D3(*args)

def GeomLProp_CurveTool_Continuity(*args):
  """
    * returns the order of continuity of the curve <C>. returns 1 : first derivative only is computable returns 2 : first and second derivative only are computable. returns 3 : first, second and third are computable.

    :param C:
    :type C: Handle_Geom_Curve &
    :rtype: int

    """
  return _GeomLProp.GeomLProp_CurveTool_Continuity(*args)

def GeomLProp_CurveTool_FirstParameter(*args):
  """
    * returns the first parameter bound of the curve.

    :param C:
    :type C: Handle_Geom_Curve &
    :rtype: float

    """
  return _GeomLProp.GeomLProp_CurveTool_FirstParameter(*args)

def GeomLProp_CurveTool_LastParameter(*args):
  """
    * returns the last parameter bound of the curve. FirstParameter must be less than LastParamenter.

    :param C:
    :type C: Handle_Geom_Curve &
    :rtype: float

    """
  return _GeomLProp.GeomLProp_CurveTool_LastParameter(*args)

class GeomLProp_SLProps(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param S:
        :type S: Handle_Geom_Surface &
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param N:
        :type N: int
        :param Resolution:
        :type Resolution: float
        :rtype: None

        :param S:
        :type S: Handle_Geom_Surface &
        :param N:
        :type N: int
        :param Resolution:
        :type Resolution: float
        :rtype: None

        :param N:
        :type N: int
        :param Resolution:
        :type Resolution: float
        :rtype: None

        """
        _GeomLProp.GeomLProp_SLProps_swiginit(self,_GeomLProp.new_GeomLProp_SLProps(*args))
    def SetSurface(self, *args):
        """
        :param S:
        :type S: Handle_Geom_Surface &
        :rtype: None

        """
        return _GeomLProp.GeomLProp_SLProps_SetSurface(self, *args)

    def SetParameters(self, *args):
        """
        :param U:
        :type U: float
        :param V:
        :type V: float
        :rtype: None

        """
        return _GeomLProp.GeomLProp_SLProps_SetParameters(self, *args)

    def Value(self, *args):
        """
        :rtype: gp_Pnt

        """
        return _GeomLProp.GeomLProp_SLProps_Value(self, *args)

    def D1U(self, *args):
        """
        :rtype: gp_Vec

        """
        return _GeomLProp.GeomLProp_SLProps_D1U(self, *args)

    def D1V(self, *args):
        """
        :rtype: gp_Vec

        """
        return _GeomLProp.GeomLProp_SLProps_D1V(self, *args)

    def D2U(self, *args):
        """
        :rtype: gp_Vec

        """
        return _GeomLProp.GeomLProp_SLProps_D2U(self, *args)

    def D2V(self, *args):
        """
        :rtype: gp_Vec

        """
        return _GeomLProp.GeomLProp_SLProps_D2V(self, *args)

    def DUV(self, *args):
        """
        :rtype: gp_Vec

        """
        return _GeomLProp.GeomLProp_SLProps_DUV(self, *args)

    def IsTangentUDefined(self, *args):
        """
        :rtype: bool

        """
        return _GeomLProp.GeomLProp_SLProps_IsTangentUDefined(self, *args)

    def TangentU(self, *args):
        """
        :param D:
        :type D: gp_Dir
        :rtype: None

        """
        return _GeomLProp.GeomLProp_SLProps_TangentU(self, *args)

    def IsTangentVDefined(self, *args):
        """
        :rtype: bool

        """
        return _GeomLProp.GeomLProp_SLProps_IsTangentVDefined(self, *args)

    def TangentV(self, *args):
        """
        :param D:
        :type D: gp_Dir
        :rtype: None

        """
        return _GeomLProp.GeomLProp_SLProps_TangentV(self, *args)

    def IsNormalDefined(self, *args):
        """
        :rtype: bool

        """
        return _GeomLProp.GeomLProp_SLProps_IsNormalDefined(self, *args)

    def Normal(self, *args):
        """
        :rtype: gp_Dir

        """
        return _GeomLProp.GeomLProp_SLProps_Normal(self, *args)

    def IsCurvatureDefined(self, *args):
        """
        :rtype: bool

        """
        return _GeomLProp.GeomLProp_SLProps_IsCurvatureDefined(self, *args)

    def IsUmbilic(self, *args):
        """
        :rtype: bool

        """
        return _GeomLProp.GeomLProp_SLProps_IsUmbilic(self, *args)

    def MaxCurvature(self, *args):
        """
        :rtype: float

        """
        return _GeomLProp.GeomLProp_SLProps_MaxCurvature(self, *args)

    def MinCurvature(self, *args):
        """
        :rtype: float

        """
        return _GeomLProp.GeomLProp_SLProps_MinCurvature(self, *args)

    def CurvatureDirections(self, *args):
        """
        :param MaxD:
        :type MaxD: gp_Dir
        :param MinD:
        :type MinD: gp_Dir
        :rtype: None

        """
        return _GeomLProp.GeomLProp_SLProps_CurvatureDirections(self, *args)

    def MeanCurvature(self, *args):
        """
        :rtype: float

        """
        return _GeomLProp.GeomLProp_SLProps_MeanCurvature(self, *args)

    def GaussianCurvature(self, *args):
        """
        :rtype: float

        """
        return _GeomLProp.GeomLProp_SLProps_GaussianCurvature(self, *args)

    __swig_destroy__ = _GeomLProp.delete_GeomLProp_SLProps
GeomLProp_SLProps.SetSurface = new_instancemethod(_GeomLProp.GeomLProp_SLProps_SetSurface,None,GeomLProp_SLProps)
GeomLProp_SLProps.SetParameters = new_instancemethod(_GeomLProp.GeomLProp_SLProps_SetParameters,None,GeomLProp_SLProps)
GeomLProp_SLProps.Value = new_instancemethod(_GeomLProp.GeomLProp_SLProps_Value,None,GeomLProp_SLProps)
GeomLProp_SLProps.D1U = new_instancemethod(_GeomLProp.GeomLProp_SLProps_D1U,None,GeomLProp_SLProps)
GeomLProp_SLProps.D1V = new_instancemethod(_GeomLProp.GeomLProp_SLProps_D1V,None,GeomLProp_SLProps)
GeomLProp_SLProps.D2U = new_instancemethod(_GeomLProp.GeomLProp_SLProps_D2U,None,GeomLProp_SLProps)
GeomLProp_SLProps.D2V = new_instancemethod(_GeomLProp.GeomLProp_SLProps_D2V,None,GeomLProp_SLProps)
GeomLProp_SLProps.DUV = new_instancemethod(_GeomLProp.GeomLProp_SLProps_DUV,None,GeomLProp_SLProps)
GeomLProp_SLProps.IsTangentUDefined = new_instancemethod(_GeomLProp.GeomLProp_SLProps_IsTangentUDefined,None,GeomLProp_SLProps)
GeomLProp_SLProps.TangentU = new_instancemethod(_GeomLProp.GeomLProp_SLProps_TangentU,None,GeomLProp_SLProps)
GeomLProp_SLProps.IsTangentVDefined = new_instancemethod(_GeomLProp.GeomLProp_SLProps_IsTangentVDefined,None,GeomLProp_SLProps)
GeomLProp_SLProps.TangentV = new_instancemethod(_GeomLProp.GeomLProp_SLProps_TangentV,None,GeomLProp_SLProps)
GeomLProp_SLProps.IsNormalDefined = new_instancemethod(_GeomLProp.GeomLProp_SLProps_IsNormalDefined,None,GeomLProp_SLProps)
GeomLProp_SLProps.Normal = new_instancemethod(_GeomLProp.GeomLProp_SLProps_Normal,None,GeomLProp_SLProps)
GeomLProp_SLProps.IsCurvatureDefined = new_instancemethod(_GeomLProp.GeomLProp_SLProps_IsCurvatureDefined,None,GeomLProp_SLProps)
GeomLProp_SLProps.IsUmbilic = new_instancemethod(_GeomLProp.GeomLProp_SLProps_IsUmbilic,None,GeomLProp_SLProps)
GeomLProp_SLProps.MaxCurvature = new_instancemethod(_GeomLProp.GeomLProp_SLProps_MaxCurvature,None,GeomLProp_SLProps)
GeomLProp_SLProps.MinCurvature = new_instancemethod(_GeomLProp.GeomLProp_SLProps_MinCurvature,None,GeomLProp_SLProps)
GeomLProp_SLProps.CurvatureDirections = new_instancemethod(_GeomLProp.GeomLProp_SLProps_CurvatureDirections,None,GeomLProp_SLProps)
GeomLProp_SLProps.MeanCurvature = new_instancemethod(_GeomLProp.GeomLProp_SLProps_MeanCurvature,None,GeomLProp_SLProps)
GeomLProp_SLProps.GaussianCurvature = new_instancemethod(_GeomLProp.GeomLProp_SLProps_GaussianCurvature,None,GeomLProp_SLProps)
GeomLProp_SLProps_swigregister = _GeomLProp.GeomLProp_SLProps_swigregister
GeomLProp_SLProps_swigregister(GeomLProp_SLProps)

class GeomLProp_SurfaceTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Value(*args):
        """
        * Computes the point <P> of parameter <U> and <V> on the Surface <S>.

        :param S:
        :type S: Handle_Geom_Surface &
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param P:
        :type P: gp_Pnt
        :rtype: void

        """
        return _GeomLProp.GeomLProp_SurfaceTool_Value(*args)

    Value = staticmethod(Value)
    def D1(*args):
        """
        * Computes the point <P> and first derivative <D1*> of parameter <U> and <V> on the Surface <S>.

        :param S:
        :type S: Handle_Geom_Surface &
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param P:
        :type P: gp_Pnt
        :param D1U:
        :type D1U: gp_Vec
        :param D1V:
        :type D1V: gp_Vec
        :rtype: void

        """
        return _GeomLProp.GeomLProp_SurfaceTool_D1(*args)

    D1 = staticmethod(D1)
    def D2(*args):
        """
        * Computes the point <P>, the first derivative <D1*> and second derivative <D2*> of parameter <U> and <V> on the Surface <S>.

        :param S:
        :type S: Handle_Geom_Surface &
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param P:
        :type P: gp_Pnt
        :param D1U:
        :type D1U: gp_Vec
        :param D1V:
        :type D1V: gp_Vec
        :param D2U:
        :type D2U: gp_Vec
        :param D2V:
        :type D2V: gp_Vec
        :param DUV:
        :type DUV: gp_Vec
        :rtype: void

        """
        return _GeomLProp.GeomLProp_SurfaceTool_D2(*args)

    D2 = staticmethod(D2)
    def DN(*args):
        """
        :param S:
        :type S: Handle_Geom_Surface &
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param IU:
        :type IU: int
        :param IV:
        :type IV: int
        :rtype: gp_Vec

        """
        return _GeomLProp.GeomLProp_SurfaceTool_DN(*args)

    DN = staticmethod(DN)
    def Continuity(*args):
        """
        * returns the order of continuity of the Surface <S>. returns 1 : first derivative only is computable returns 2 : first and second derivative only are computable.

        :param S:
        :type S: Handle_Geom_Surface &
        :rtype: int

        """
        return _GeomLProp.GeomLProp_SurfaceTool_Continuity(*args)

    Continuity = staticmethod(Continuity)
    def Bounds(*args):
        """
        * returns the bounds of the Surface.

        :param S:
        :type S: Handle_Geom_Surface &
        :param U1:
        :type U1: float &
        :param V1:
        :type V1: float &
        :param U2:
        :type U2: float &
        :param V2:
        :type V2: float &
        :rtype: void

        """
        return _GeomLProp.GeomLProp_SurfaceTool_Bounds(*args)

    Bounds = staticmethod(Bounds)
    def __init__(self): 
        _GeomLProp.GeomLProp_SurfaceTool_swiginit(self,_GeomLProp.new_GeomLProp_SurfaceTool())
    __swig_destroy__ = _GeomLProp.delete_GeomLProp_SurfaceTool
GeomLProp_SurfaceTool_swigregister = _GeomLProp.GeomLProp_SurfaceTool_swigregister
GeomLProp_SurfaceTool_swigregister(GeomLProp_SurfaceTool)

def GeomLProp_SurfaceTool_Value(*args):
  """
    * Computes the point <P> of parameter <U> and <V> on the Surface <S>.

    :param S:
    :type S: Handle_Geom_Surface &
    :param U:
    :type U: float
    :param V:
    :type V: float
    :param P:
    :type P: gp_Pnt
    :rtype: void

    """
  return _GeomLProp.GeomLProp_SurfaceTool_Value(*args)

def GeomLProp_SurfaceTool_D1(*args):
  """
    * Computes the point <P> and first derivative <D1*> of parameter <U> and <V> on the Surface <S>.

    :param S:
    :type S: Handle_Geom_Surface &
    :param U:
    :type U: float
    :param V:
    :type V: float
    :param P:
    :type P: gp_Pnt
    :param D1U:
    :type D1U: gp_Vec
    :param D1V:
    :type D1V: gp_Vec
    :rtype: void

    """
  return _GeomLProp.GeomLProp_SurfaceTool_D1(*args)

def GeomLProp_SurfaceTool_D2(*args):
  """
    * Computes the point <P>, the first derivative <D1*> and second derivative <D2*> of parameter <U> and <V> on the Surface <S>.

    :param S:
    :type S: Handle_Geom_Surface &
    :param U:
    :type U: float
    :param V:
    :type V: float
    :param P:
    :type P: gp_Pnt
    :param D1U:
    :type D1U: gp_Vec
    :param D1V:
    :type D1V: gp_Vec
    :param D2U:
    :type D2U: gp_Vec
    :param D2V:
    :type D2V: gp_Vec
    :param DUV:
    :type DUV: gp_Vec
    :rtype: void

    """
  return _GeomLProp.GeomLProp_SurfaceTool_D2(*args)

def GeomLProp_SurfaceTool_DN(*args):
  """
    :param S:
    :type S: Handle_Geom_Surface &
    :param U:
    :type U: float
    :param V:
    :type V: float
    :param IU:
    :type IU: int
    :param IV:
    :type IV: int
    :rtype: gp_Vec

    """
  return _GeomLProp.GeomLProp_SurfaceTool_DN(*args)

def GeomLProp_SurfaceTool_Continuity(*args):
  """
    * returns the order of continuity of the Surface <S>. returns 1 : first derivative only is computable returns 2 : first and second derivative only are computable.

    :param S:
    :type S: Handle_Geom_Surface &
    :rtype: int

    """
  return _GeomLProp.GeomLProp_SurfaceTool_Continuity(*args)

def GeomLProp_SurfaceTool_Bounds(*args):
  """
    * returns the bounds of the Surface.

    :param S:
    :type S: Handle_Geom_Surface &
    :param U1:
    :type U1: float &
    :param V1:
    :type V1: float &
    :param U2:
    :type U2: float &
    :param V2:
    :type V2: float &
    :rtype: void

    """
  return _GeomLProp.GeomLProp_SurfaceTool_Bounds(*args)



