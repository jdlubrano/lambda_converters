# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _Geom2dAPI.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Geom2dAPI', [dirname(__file__)])
        except ImportError:
            import _Geom2dAPI
            return _Geom2dAPI
        if fp is not None:
            try:
                _mod = imp.load_module('_Geom2dAPI', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _Geom2dAPI = swig_import_helper()
    del swig_import_helper
else:
    import _Geom2dAPI
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Geom2dAPI.delete_SwigPyIterator
    def __iter__(self): return self
SwigPyIterator.value = new_instancemethod(_Geom2dAPI.SwigPyIterator_value,None,SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_Geom2dAPI.SwigPyIterator_incr,None,SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_Geom2dAPI.SwigPyIterator_decr,None,SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_Geom2dAPI.SwigPyIterator_distance,None,SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_Geom2dAPI.SwigPyIterator_equal,None,SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_Geom2dAPI.SwigPyIterator_copy,None,SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_Geom2dAPI.SwigPyIterator_next,None,SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_Geom2dAPI.SwigPyIterator___next__,None,SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_Geom2dAPI.SwigPyIterator_previous,None,SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_Geom2dAPI.SwigPyIterator_advance,None,SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_Geom2dAPI.SwigPyIterator___eq__,None,SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_Geom2dAPI.SwigPyIterator___ne__,None,SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_Geom2dAPI.SwigPyIterator___iadd__,None,SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_Geom2dAPI.SwigPyIterator___isub__,None,SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_Geom2dAPI.SwigPyIterator___add__,None,SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_Geom2dAPI.SwigPyIterator___sub__,None,SwigPyIterator)
SwigPyIterator_swigregister = _Geom2dAPI.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import OCC.Geom2d
import OCC.MMgt
import OCC.Standard
import OCC.gp
import OCC.GeomAbs
import OCC.TColgp
import OCC.TCollection
import OCC.TColStd
import OCC.Quantity
import OCC.Extrema
import OCC.math
import OCC.Adaptor2d
import OCC.Adaptor3d
import OCC.Geom
import OCC.TopAbs
import OCC.Geom2dInt
import OCC.IntRes2d
import OCC.IntCurve
import OCC.Intf
import OCC.Bnd
import OCC.Approx
import OCC.AppCont
import OCC.AppParCurves
def register_handle(handle, base_object):
    """
    Inserts the handle into the base object to
    prevent memory corruption in certain cases
    """
    try:
        if base_object.IsKind("Standard_Transient"):
            base_object.thisHandle = handle
            base_object.thisown = False
    except:
        pass

class Geom2dAPI_ExtremaCurveCurve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Computes the extrema between - the portion of the curve C1 limited by the two points of parameter (U1min,U1max), and - the portion of the curve C2 limited by the two points of parameter (U2min,U2max). Warning Use the function NbExtrema to obtain the number of solutions. If this algorithm fails, NbExtrema returns 0.

        :param C1:
        :type C1: Handle_Geom2d_Curve &
        :param C2:
        :type C2: Handle_Geom2d_Curve &
        :param U1min:
        :type U1min: Quantity_Parameter
        :param U1max:
        :type U1max: Quantity_Parameter
        :param U2min:
        :type U2min: Quantity_Parameter
        :param U2max:
        :type U2max: Quantity_Parameter
        :rtype: None

        """
        _Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_swiginit(self,_Geom2dAPI.new_Geom2dAPI_ExtremaCurveCurve(*args))
    def NbExtrema(self, *args):
        """
        * Returns the number of extrema computed by this algorithm. Note: if this algorithm fails, NbExtrema returns 0.

        :rtype: int

        """
        return _Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_NbExtrema(self, *args)

    def Points(self, *args):
        """
        * Returns the points P1 on the first curve and P2 on the second curve, which are the ends of the extremum of index Index computed by this algorithm. Exceptions Standard_OutOfRange if Index is not in the range [ 1,NbExtrema ], where NbExtrema is the number of extrema computed by this algorithm.

        :param Index:
        :type Index: int
        :param P1:
        :type P1: gp_Pnt2d
        :param P2:
        :type P2: gp_Pnt2d
        :rtype: None

        """
        return _Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_Points(self, *args)

    def Parameters(self, *args):
        """
        * Returns the parameters U1 of the point on the first curve and U2 of the point on the second curve, which are the ends of the extremum of index Index computed by this algorithm. Exceptions Standard_OutOfRange if Index is not in the range [ 1,NbExtrema ], where NbExtrema is the number of extrema computed by this algorithm.

        :param Index:
        :type Index: int
        :param U1:
        :type U1: Quantity_Parameter &
        :param U2:
        :type U2: Quantity_Parameter &
        :rtype: None

        """
        return _Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_Parameters(self, *args)

    def Distance(self, *args):
        """
        * Computes the distance between the end points of the extremum of index Index computed by this algorithm. Exceptions Standard_OutOfRange if Index is not in the range [ 1,NbExtrema ], where NbExtrema is the number of extrema computed by this algorithm.

        :param Index:
        :type Index: int
        :rtype: Quantity_Length

        """
        return _Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_Distance(self, *args)

    def NearestPoints(self, *args):
        """
        * Returns the points P1 on the first curve and P2 on the second curve, which are the ends of the shortest extremum computed by this algorithm. Exceptions StdFail_NotDone if this algorithm fails.

        :param P1:
        :type P1: gp_Pnt2d
        :param P2:
        :type P2: gp_Pnt2d
        :rtype: None

        """
        return _Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_NearestPoints(self, *args)

    def LowerDistanceParameters(self, *args):
        """
        * Returns the parameters U1 of the point on the first curve and U2 of the point on the second curve, which are the ends of the shortest extremum computed by this algorithm. Exceptions StdFail_NotDone if this algorithm fails.

        :param U1:
        :type U1: Quantity_Parameter &
        :param U2:
        :type U2: Quantity_Parameter &
        :rtype: None

        """
        return _Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_LowerDistanceParameters(self, *args)

    def LowerDistance(self, *args):
        """
        * Computes the distance between the end points of the shortest extremum computed by this algorithm. Exceptions - StdFail_NotDone if this algorithm fails.

        :rtype: Quantity_Length

        """
        return _Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_LowerDistance(self, *args)

    def Extrema(self, *args):
        """
        :rtype: Extrema_ExtCC2d

        """
        return _Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_Extrema(self, *args)

    __swig_destroy__ = _Geom2dAPI.delete_Geom2dAPI_ExtremaCurveCurve
Geom2dAPI_ExtremaCurveCurve.NbExtrema = new_instancemethod(_Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_NbExtrema,None,Geom2dAPI_ExtremaCurveCurve)
Geom2dAPI_ExtremaCurveCurve.Points = new_instancemethod(_Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_Points,None,Geom2dAPI_ExtremaCurveCurve)
Geom2dAPI_ExtremaCurveCurve.Parameters = new_instancemethod(_Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_Parameters,None,Geom2dAPI_ExtremaCurveCurve)
Geom2dAPI_ExtremaCurveCurve.Distance = new_instancemethod(_Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_Distance,None,Geom2dAPI_ExtremaCurveCurve)
Geom2dAPI_ExtremaCurveCurve.NearestPoints = new_instancemethod(_Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_NearestPoints,None,Geom2dAPI_ExtremaCurveCurve)
Geom2dAPI_ExtremaCurveCurve.LowerDistanceParameters = new_instancemethod(_Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_LowerDistanceParameters,None,Geom2dAPI_ExtremaCurveCurve)
Geom2dAPI_ExtremaCurveCurve.LowerDistance = new_instancemethod(_Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_LowerDistance,None,Geom2dAPI_ExtremaCurveCurve)
Geom2dAPI_ExtremaCurveCurve.Extrema = new_instancemethod(_Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_Extrema,None,Geom2dAPI_ExtremaCurveCurve)
Geom2dAPI_ExtremaCurveCurve_swigregister = _Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_swigregister
Geom2dAPI_ExtremaCurveCurve_swigregister(Geom2dAPI_ExtremaCurveCurve)

class Geom2dAPI_InterCurveCurve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Create an empty intersector. Use the function Init for further initialization of the intersection algorithm by curves or curve.

        :rtype: None

        * Creates an object and computes the intersections between the curves C1 and C2.

        :param C1:
        :type C1: Handle_Geom2d_Curve &
        :param C2:
        :type C2: Handle_Geom2d_Curve &
        :param Tol: default value is 1.0e-6
        :type Tol: float
        :rtype: None

        * Creates an object and computes self-intersections of the curve C1. Tolerance value Tol, defaulted to 1.0e-6, defines the precision of computing the intersection points. In case of a tangential intersection, Tol also defines the size of intersection segments (limited portions of the curves) where the distance between all points from two curves (or a curve in case of self-intersection) is less than Tol. Warning Use functions NbPoints and NbSegments to obtain the number of solutions. If the algorithm finds no intersections NbPoints and NbSegments return 0.

        :param C1:
        :type C1: Handle_Geom2d_Curve &
        :param Tol: default value is 1.0e-6
        :type Tol: float
        :rtype: None

        """
        _Geom2dAPI.Geom2dAPI_InterCurveCurve_swiginit(self,_Geom2dAPI.new_Geom2dAPI_InterCurveCurve(*args))
    def Init(self, *args):
        """
        * Initializes an algorithm with the given arguments and computes the intersections between the curves C1. and C2.

        :param C1:
        :type C1: Handle_Geom2d_Curve &
        :param C2:
        :type C2: Handle_Geom2d_Curve &
        :param Tol: default value is 1.0e-6
        :type Tol: float
        :rtype: None

        * Initializes an algorithm with the given arguments and computes the self-intersections of the curve C1. Tolerance value Tol, defaulted to 1.0e-6, defines the precision of computing the intersection points. In case of a tangential intersection, Tol also defines the size of intersection segments (limited portions of the curves) where the distance between all points from two curves (or a curve in case of self-intersection) is less than Tol. Warning Use functions NbPoints and NbSegments to obtain the number of solutions. If the algorithm finds no intersections NbPoints and NbSegments return 0.

        :param C1:
        :type C1: Handle_Geom2d_Curve &
        :param Tol: default value is 1.0e-6
        :type Tol: float
        :rtype: None

        """
        return _Geom2dAPI.Geom2dAPI_InterCurveCurve_Init(self, *args)

    def NbPoints(self, *args):
        """
        * Returns the number of intersection-points in case of cross intersections. NbPoints returns 0 if no intersections were found.

        :rtype: int

        """
        return _Geom2dAPI.Geom2dAPI_InterCurveCurve_NbPoints(self, *args)

    def Point(self, *args):
        """
        * Returns the intersection point of index Index. Intersection points are computed in case of cross intersections with a precision equal to the tolerance value assigned at the time of construction or in the function Init (this value is defaulted to 1.0e-6). Exceptions Standard_OutOfRange if index is not in the range [ 1,NbPoints ], where NbPoints is the number of computed intersection points

        :param Index:
        :type Index: int
        :rtype: gp_Pnt2d

        """
        return _Geom2dAPI.Geom2dAPI_InterCurveCurve_Point(self, *args)

    def NbSegments(self, *args):
        """
        * Returns the number of tangential intersections. NbSegments returns 0 if no intersections were found

        :rtype: int

        """
        return _Geom2dAPI.Geom2dAPI_InterCurveCurve_NbSegments(self, *args)

    def Segment(self, *args):
        """
        * Use this syntax only to get solutions of tangential intersection between two curves. Output values Curve1 and Curve2 are the intersection segments on the first curve and on the second curve accordingly. Parameter Index defines a number of computed solution. An intersection segment is a portion of an initial curve limited by two points. The distance from each point of this segment to the other curve is less or equal to the tolerance value assigned at the time of construction or in function Init (this value is defaulted to 1.0e-6). Exceptions Standard_OutOfRange if Index is not in the range [ 1,NbSegments ], where NbSegments is the number of computed tangential intersections. Standard_NullObject if the algorithm is initialized for the computing of self-intersections on a curve.

        :param Index:
        :type Index: int
        :param Curve1:
        :type Curve1: Handle_Geom2d_Curve &
        :param Curve2:
        :type Curve2: Handle_Geom2d_Curve &
        :rtype: None

        * Use this syntax to get solutions of tangential intersections only in case of a self-intersected curve. Output value Curve1 is the intersection segment of the curve defined by number Index. An intersection segment is a portion of the initial curve limited by two points. The distance between each point of this segment to another portion of the curve is less or equal to the tolerance value assigned at the time of construction or in the function Init (this value is defaulted to 1.0e-6). Exceptions Standard_OutOfRange if Index is not in the range [ 1,NbSegments ], where NbSegments is the number of computed tangential intersections.

        :param Index:
        :type Index: int
        :param Curve1:
        :type Curve1: Handle_Geom2d_Curve &
        :rtype: None

        """
        return _Geom2dAPI.Geom2dAPI_InterCurveCurve_Segment(self, *args)

    def Intersector(self, *args):
        """
        * return the algorithmic object from Intersection.

        :rtype: Geom2dInt_GInter

        """
        return _Geom2dAPI.Geom2dAPI_InterCurveCurve_Intersector(self, *args)

    __swig_destroy__ = _Geom2dAPI.delete_Geom2dAPI_InterCurveCurve
Geom2dAPI_InterCurveCurve.Init = new_instancemethod(_Geom2dAPI.Geom2dAPI_InterCurveCurve_Init,None,Geom2dAPI_InterCurveCurve)
Geom2dAPI_InterCurveCurve.NbPoints = new_instancemethod(_Geom2dAPI.Geom2dAPI_InterCurveCurve_NbPoints,None,Geom2dAPI_InterCurveCurve)
Geom2dAPI_InterCurveCurve.Point = new_instancemethod(_Geom2dAPI.Geom2dAPI_InterCurveCurve_Point,None,Geom2dAPI_InterCurveCurve)
Geom2dAPI_InterCurveCurve.NbSegments = new_instancemethod(_Geom2dAPI.Geom2dAPI_InterCurveCurve_NbSegments,None,Geom2dAPI_InterCurveCurve)
Geom2dAPI_InterCurveCurve.Segment = new_instancemethod(_Geom2dAPI.Geom2dAPI_InterCurveCurve_Segment,None,Geom2dAPI_InterCurveCurve)
Geom2dAPI_InterCurveCurve.Intersector = new_instancemethod(_Geom2dAPI.Geom2dAPI_InterCurveCurve_Intersector,None,Geom2dAPI_InterCurveCurve)
Geom2dAPI_InterCurveCurve_swigregister = _Geom2dAPI.Geom2dAPI_InterCurveCurve_swigregister
Geom2dAPI_InterCurveCurve_swigregister(Geom2dAPI_InterCurveCurve)

class Geom2dAPI_Interpolate(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Tolerance is to check if the points are not too close to one an other It is also used to check if the tangent vector is not too small. There should be at least 2 points if PeriodicFlag is True then the curve will be periodic.

        :param Points:
        :type Points: Handle_TColgp_HArray1OfPnt2d
        :param PeriodicFlag:
        :type PeriodicFlag: bool
        :param Tolerance:
        :type Tolerance: float
        :rtype: None

        * if PeriodicFlag is True then the curve will be periodic Warning: There should be as many parameters as there are points except if PeriodicFlag is True : then there should be one more parameter to close the curve

        :param Points:
        :type Points: Handle_TColgp_HArray1OfPnt2d
        :param Parameters:
        :type Parameters: Handle_TColStd_HArray1OfReal &
        :param PeriodicFlag:
        :type PeriodicFlag: bool
        :param Tolerance:
        :type Tolerance: float
        :rtype: None

        """
        _Geom2dAPI.Geom2dAPI_Interpolate_swiginit(self,_Geom2dAPI.new_Geom2dAPI_Interpolate(*args))
    def Load(self, *args):
        """
        * Assigns this constrained BSpline curve to be tangential to vectors InitialTangent and FinalTangent at its first and last points respectively (i.e. the first and last points of the table of points through which the curve passes, as defined at the time of initialization).

        :param InitialTangent:
        :type InitialTangent: gp_Vec2d
        :param FinalTangent:
        :type FinalTangent: gp_Vec2d
        :rtype: None

        * Assigns this constrained BSpline curve to be tangential to vectors defined in the table Tangents, which is parallel to the table of points through which the curve passes, as defined at the time of initialization. Vectors in the table Tangents are defined only if the flag given in the parallel table TangentFlags is true: only these vectors are set as tangency constraints.

        :param Tangents:
        :type Tangents: TColgp_Array1OfVec2d
        :param TangentFlags:
        :type TangentFlags: Handle_TColStd_HArray1OfBoolean &
        :rtype: None

        """
        return _Geom2dAPI.Geom2dAPI_Interpolate_Load(self, *args)

    def Perform(self, *args):
        """
        * Computes the constrained BSpline curve. Use the function IsDone to verify that the computation is successful, and then the function Curve to obtain the result.

        :rtype: None

        """
        return _Geom2dAPI.Geom2dAPI_Interpolate_Perform(self, *args)

    def Curve(self, *args):
        """
        * Returns the computed BSpline curve. Raises StdFail_NotDone if the interpolation fails.

        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _Geom2dAPI.Geom2dAPI_Interpolate_Curve(self, *args)

    def IsDone(self, *args):
        """
        * Returns true if the constrained BSpline curve is successfully constructed. Note: in this case, the result is given by the function Curve.

        :rtype: bool

        """
        return _Geom2dAPI.Geom2dAPI_Interpolate_IsDone(self, *args)

    __swig_destroy__ = _Geom2dAPI.delete_Geom2dAPI_Interpolate
Geom2dAPI_Interpolate.Load = new_instancemethod(_Geom2dAPI.Geom2dAPI_Interpolate_Load,None,Geom2dAPI_Interpolate)
Geom2dAPI_Interpolate.Perform = new_instancemethod(_Geom2dAPI.Geom2dAPI_Interpolate_Perform,None,Geom2dAPI_Interpolate)
Geom2dAPI_Interpolate.Curve = new_instancemethod(_Geom2dAPI.Geom2dAPI_Interpolate_Curve,None,Geom2dAPI_Interpolate)
Geom2dAPI_Interpolate.IsDone = new_instancemethod(_Geom2dAPI.Geom2dAPI_Interpolate_IsDone,None,Geom2dAPI_Interpolate)
Geom2dAPI_Interpolate_swigregister = _Geom2dAPI.Geom2dAPI_Interpolate_swigregister
Geom2dAPI_Interpolate_swigregister(Geom2dAPI_Interpolate)

class Geom2dAPI_PointsToBSpline(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Constructs an empty approximation algorithm. Use an Init function to define and build the BSpline curve.

        :rtype: None

        * Approximate a BSpline Curve passing through an array of Point. The resulting BSpline will have the following properties: 1- his degree will be in the range [Degmin,Degmax] 2- his continuity will be at least <Continuity> 3- the distance from the point <Points> to the BSpline will be lower to Tol2D

        :param Points:
        :type Points: TColgp_Array1OfPnt2d
        :param DegMin: default value is 3
        :type DegMin: int
        :param DegMax: default value is 8
        :type DegMax: int
        :param Continuity: default value is GeomAbs_C2
        :type Continuity: GeomAbs_Shape
        :param Tol2D: default value is 1.0e-6
        :type Tol2D: float
        :rtype: None

        * Approximate a BSpline Curve passing through an array of Point. Of coordinates :  X = X0 + DX * (i-YValues.Lower()) Y = YValues(i)  With i in the range YValues.Lower(), YValues.Upper()  The BSpline will be parametrized from t = X0 to X0 + DX * (YValues.Upper() - YValues.Lower())  And will satisfy X(t) = t  The resulting BSpline will have the following properties: 1- his degree will be in the range [Degmin,Degmax] 2- his continuity will be at least <Continuity> 3- the distance from the point <Points> to the BSpline will be lower to Tol2D

        :param YValues:
        :type YValues: TColStd_Array1OfReal &
        :param X0:
        :type X0: float
        :param DX:
        :type DX: float
        :param DegMin: default value is 3
        :type DegMin: int
        :param DegMax: default value is 8
        :type DegMax: int
        :param Continuity: default value is GeomAbs_C2
        :type Continuity: GeomAbs_Shape
        :param Tol2D: default value is 1.0e-6
        :type Tol2D: float
        :rtype: None

        * Approximate a BSpline Curve passing through an array of Point. The resulting BSpline will have the following properties: 1- his degree will be in the range [Degmin,Degmax] 2- his continuity will be at least <Continuity> 3- the distance from the point <Points> to the BSpline will be lower to Tol2D

        :param Points:
        :type Points: TColgp_Array1OfPnt2d
        :param ParType:
        :type ParType: Approx_ParametrizationType
        :param DegMin: default value is 3
        :type DegMin: int
        :param DegMax: default value is 8
        :type DegMax: int
        :param Continuity: default value is GeomAbs_C2
        :type Continuity: GeomAbs_Shape
        :param Tol2D: default value is 1.0e-3
        :type Tol2D: float
        :rtype: None

        * Approximate a BSpline Curve passing through an array of Point, which parameters are given by the array <Parameters>. The resulting BSpline will have the following properties: 1- his degree will be in the range [Degmin,Degmax] 2- his continuity will be at least <Continuity> 3- the distance from the point <Points> to the BSpline will be lower to Tol2D

        :param Points:
        :type Points: TColgp_Array1OfPnt2d
        :param Parameters:
        :type Parameters: TColStd_Array1OfReal &
        :param DegMin: default value is 3
        :type DegMin: int
        :param DegMax: default value is 8
        :type DegMax: int
        :param Continuity: default value is GeomAbs_C2
        :type Continuity: GeomAbs_Shape
        :param Tol2D: default value is 1.0e-3
        :type Tol2D: float
        :rtype: None

        * Approximate a BSpline Curve passing through an array of Point using variational smoothing algorithm, which tries to minimize additional criterium: Weight1*CurveLength + Weight2*Curvature + Weight3*Torsion

        :param Points:
        :type Points: TColgp_Array1OfPnt2d
        :param Weight1:
        :type Weight1: float
        :param Weight2:
        :type Weight2: float
        :param Weight3:
        :type Weight3: float
        :param DegMax: default value is 8
        :type DegMax: int
        :param Continuity: default value is GeomAbs_C2
        :type Continuity: GeomAbs_Shape
        :param Tol3D: default value is 1.0e-3
        :type Tol3D: float
        :rtype: None

        """
        _Geom2dAPI.Geom2dAPI_PointsToBSpline_swiginit(self,_Geom2dAPI.new_Geom2dAPI_PointsToBSpline(*args))
    def Init(self, *args):
        """
        * Approximate a BSpline Curve passing through an array of Point. The resulting BSpline will have the following properties: 1- his degree will be in the range [Degmin,Degmax] 2- his continuity will be at least <Continuity> 3- the distance from the point <Points> to the BSpline will be lower to Tol2D

        :param Points:
        :type Points: TColgp_Array1OfPnt2d
        :param DegMin: default value is 3
        :type DegMin: int
        :param DegMax: default value is 8
        :type DegMax: int
        :param Continuity: default value is GeomAbs_C2
        :type Continuity: GeomAbs_Shape
        :param Tol2D: default value is 1.0e-6
        :type Tol2D: float
        :rtype: None

        * Approximate a BSpline Curve passing through an array of Point. Of coordinates :  X = X0 + DX * (i-YValues.Lower()) Y = YValues(i)  With i in the range YValues.Lower(), YValues.Upper()  The BSpline will be parametrized from t = X0 to X0 + DX * (YValues.Upper() - YValues.Lower())  And will satisfy X(t) = t  The resulting BSpline will have the following properties: 1- his degree will be in the range [Degmin,Degmax] 2- his continuity will be at least <Continuity> 3- the distance from the point <Points> to the BSpline will be lower to Tol2D

        :param YValues:
        :type YValues: TColStd_Array1OfReal &
        :param X0:
        :type X0: float
        :param DX:
        :type DX: float
        :param DegMin: default value is 3
        :type DegMin: int
        :param DegMax: default value is 8
        :type DegMax: int
        :param Continuity: default value is GeomAbs_C2
        :type Continuity: GeomAbs_Shape
        :param Tol2D: default value is 1.0e-6
        :type Tol2D: float
        :rtype: None

        * Approximate a BSpline Curve passing through an array of Point. The resulting BSpline will have the following properties: 1- his degree will be in the range [Degmin,Degmax] 2- his continuity will be at least <Continuity> 3- the distance from the point <Points> to the BSpline will be lower to Tol2D

        :param Points:
        :type Points: TColgp_Array1OfPnt2d
        :param ParType:
        :type ParType: Approx_ParametrizationType
        :param DegMin: default value is 3
        :type DegMin: int
        :param DegMax: default value is 8
        :type DegMax: int
        :param Continuity: default value is GeomAbs_C2
        :type Continuity: GeomAbs_Shape
        :param Tol2D: default value is 1.0e-3
        :type Tol2D: float
        :rtype: None

        * Approximate a BSpline Curve passing through an array of Point, which parameters are given by the array <Parameters>. The resulting BSpline will have the following properties: 1- his degree will be in the range [Degmin,Degmax] 2- his continuity will be at least <Continuity> 3- the distance from the point <Points> to the BSpline will be lower to Tol2D

        :param Points:
        :type Points: TColgp_Array1OfPnt2d
        :param Parameters:
        :type Parameters: TColStd_Array1OfReal &
        :param DegMin: default value is 3
        :type DegMin: int
        :param DegMax: default value is 8
        :type DegMax: int
        :param Continuity: default value is GeomAbs_C2
        :type Continuity: GeomAbs_Shape
        :param Tol2D: default value is 1.0e-3
        :type Tol2D: float
        :rtype: None

        * Approximate a BSpline Curve passing through an array of Point using variational smoothing algorithm, which tries to minimize additional criterium: Weight1*CurveLength + Weight2*Curvature + Weight3*Torsion

        :param Points:
        :type Points: TColgp_Array1OfPnt2d
        :param Weight1:
        :type Weight1: float
        :param Weight2:
        :type Weight2: float
        :param Weight3:
        :type Weight3: float
        :param DegMax: default value is 8
        :type DegMax: int
        :param Continuity: default value is GeomAbs_C2
        :type Continuity: GeomAbs_Shape
        :param Tol2D: default value is 1.0e-3
        :type Tol2D: float
        :rtype: None

        """
        return _Geom2dAPI.Geom2dAPI_PointsToBSpline_Init(self, *args)

    def Curve(self, *args):
        """
        * Returns the approximate BSpline Curve

        :rtype: Handle_Geom2d_BSplineCurve

        """
        return _Geom2dAPI.Geom2dAPI_PointsToBSpline_Curve(self, *args)

    def IsDone(self, *args):
        """
        :rtype: bool

        """
        return _Geom2dAPI.Geom2dAPI_PointsToBSpline_IsDone(self, *args)

    __swig_destroy__ = _Geom2dAPI.delete_Geom2dAPI_PointsToBSpline
Geom2dAPI_PointsToBSpline.Init = new_instancemethod(_Geom2dAPI.Geom2dAPI_PointsToBSpline_Init,None,Geom2dAPI_PointsToBSpline)
Geom2dAPI_PointsToBSpline.Curve = new_instancemethod(_Geom2dAPI.Geom2dAPI_PointsToBSpline_Curve,None,Geom2dAPI_PointsToBSpline)
Geom2dAPI_PointsToBSpline.IsDone = new_instancemethod(_Geom2dAPI.Geom2dAPI_PointsToBSpline_IsDone,None,Geom2dAPI_PointsToBSpline)
Geom2dAPI_PointsToBSpline_swigregister = _Geom2dAPI.Geom2dAPI_PointsToBSpline_swigregister
Geom2dAPI_PointsToBSpline_swigregister(Geom2dAPI_PointsToBSpline)

class Geom2dAPI_ProjectPointOnCurve(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        * Constructs an empty projector algorithm. Use an Init function to define the point and the curve on which it is going to work.

        :rtype: None

        * Create the projection of a point <P> on a curve <Curve>

        :param P:
        :type P: gp_Pnt2d
        :param Curve:
        :type Curve: Handle_Geom2d_Curve &
        :rtype: None

        * Create the projection of a point <P> on a curve <Curve> limited by the two points of parameter Umin and Usup. Warning Use the function NbPoints to obtain the number of solutions. If projection fails, NbPoints returns 0.

        :param P:
        :type P: gp_Pnt2d
        :param Curve:
        :type Curve: Handle_Geom2d_Curve &
        :param Umin:
        :type Umin: Quantity_Parameter
        :param Usup:
        :type Usup: Quantity_Parameter
        :rtype: None

        """
        _Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_swiginit(self,_Geom2dAPI.new_Geom2dAPI_ProjectPointOnCurve(*args))
    def Init(self, *args):
        """
        * Initializes this algorithm with the given arguments, and computes the orthogonal projections of a point <P> on a curve <Curve>

        :param P:
        :type P: gp_Pnt2d
        :param Curve:
        :type Curve: Handle_Geom2d_Curve &
        :rtype: None

        * Initializes this algorithm with the given arguments, and computes the orthogonal projections of the point P onto the portion of the curve Curve limited by the two points of parameter Umin and Usup.

        :param P:
        :type P: gp_Pnt2d
        :param Curve:
        :type Curve: Handle_Geom2d_Curve &
        :param Umin:
        :type Umin: Quantity_Parameter
        :param Usup:
        :type Usup: Quantity_Parameter
        :rtype: None

        """
        return _Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_Init(self, *args)

    def NbPoints(self, *args):
        """
        * return the number of of computed orthogonal projectionn points.

        :rtype: int

        """
        return _Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_NbPoints(self, *args)

    def Point(self, *args):
        """
        * Returns the orthogonal projection on the curve. Index is a number of a computed point. Exceptions Standard_OutOfRange if Index is not in the range [ 1,NbPoints ], where NbPoints is the number of solution points.

        :param Index:
        :type Index: int
        :rtype: gp_Pnt2d

        """
        return _Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_Point(self, *args)

    def Parameter(self, *args):
        """
        * Returns the parameter on the curve of a point which is the orthogonal projection. Index is a number of a computed projected point. Exceptions Standard_OutOfRange if Index is not in the range [ 1,NbPoints ], where NbPoints is the number of solution points.

        :param Index:
        :type Index: int
        :rtype: Quantity_Parameter

        * Returns the parameter on the curve of a point which is the orthogonal projection. Index is a number of a computed projected point. Exceptions Standard_OutOfRange if Index is not in the range [ 1,NbPoints ], where NbPoints is the number of solution points

        :param Index:
        :type Index: int
        :param U:
        :type U: Quantity_Parameter &
        :rtype: None

        """
        return _Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_Parameter(self, *args)

    def Distance(self, *args):
        """
        * Computes the distance between the point and its computed orthogonal projection on the curve. Index is a number of computed projected point. Exceptions Standard_OutOfRange if Index is not in the range [ 1,NbPoints ], where NbPoints is the number of solution points.

        :param Index:
        :type Index: int
        :rtype: Quantity_Length

        """
        return _Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_Distance(self, *args)

    def NearestPoint(self, *args):
        """
        * Returns the nearest orthogonal projection of the point on the curve. Exceptions StdFail_NotDone if this algorithm fails.

        :rtype: gp_Pnt2d

        """
        return _Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_NearestPoint(self, *args)

    def LowerDistanceParameter(self, *args):
        """
        * Returns the parameter on the curve of the nearest orthogonal projection of the point. Exceptions StdFail_NotDone if this algorithm fails.

        :rtype: Quantity_Parameter

        """
        return _Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_LowerDistanceParameter(self, *args)

    def LowerDistance(self, *args):
        """
        * Computes the distance between the point and its nearest orthogonal projection on the curve. Exceptions StdFail_NotDone if this algorithm fails.

        :rtype: Quantity_Length

        """
        return _Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_LowerDistance(self, *args)

    def Extrema(self, *args):
        """
        * return the algorithmic object from Extrema

        :rtype: Extrema_ExtPC2d

        """
        return _Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_Extrema(self, *args)

    __swig_destroy__ = _Geom2dAPI.delete_Geom2dAPI_ProjectPointOnCurve
Geom2dAPI_ProjectPointOnCurve.Init = new_instancemethod(_Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_Init,None,Geom2dAPI_ProjectPointOnCurve)
Geom2dAPI_ProjectPointOnCurve.NbPoints = new_instancemethod(_Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_NbPoints,None,Geom2dAPI_ProjectPointOnCurve)
Geom2dAPI_ProjectPointOnCurve.Point = new_instancemethod(_Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_Point,None,Geom2dAPI_ProjectPointOnCurve)
Geom2dAPI_ProjectPointOnCurve.Parameter = new_instancemethod(_Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_Parameter,None,Geom2dAPI_ProjectPointOnCurve)
Geom2dAPI_ProjectPointOnCurve.Distance = new_instancemethod(_Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_Distance,None,Geom2dAPI_ProjectPointOnCurve)
Geom2dAPI_ProjectPointOnCurve.NearestPoint = new_instancemethod(_Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_NearestPoint,None,Geom2dAPI_ProjectPointOnCurve)
Geom2dAPI_ProjectPointOnCurve.LowerDistanceParameter = new_instancemethod(_Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_LowerDistanceParameter,None,Geom2dAPI_ProjectPointOnCurve)
Geom2dAPI_ProjectPointOnCurve.LowerDistance = new_instancemethod(_Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_LowerDistance,None,Geom2dAPI_ProjectPointOnCurve)
Geom2dAPI_ProjectPointOnCurve.Extrema = new_instancemethod(_Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_Extrema,None,Geom2dAPI_ProjectPointOnCurve)
Geom2dAPI_ProjectPointOnCurve_swigregister = _Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_swigregister
Geom2dAPI_ProjectPointOnCurve_swigregister(Geom2dAPI_ProjectPointOnCurve)



