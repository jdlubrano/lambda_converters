# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _Blend.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Blend', [dirname(__file__)])
        except ImportError:
            import _Blend
            return _Blend
        if fp is not None:
            try:
                _mod = imp.load_module('_Blend', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _Blend = swig_import_helper()
    del swig_import_helper
else:
    import _Blend
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Blend.delete_SwigPyIterator
    def __iter__(self): return self
SwigPyIterator.value = new_instancemethod(_Blend.SwigPyIterator_value,None,SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_Blend.SwigPyIterator_incr,None,SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_Blend.SwigPyIterator_decr,None,SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_Blend.SwigPyIterator_distance,None,SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_Blend.SwigPyIterator_equal,None,SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_Blend.SwigPyIterator_copy,None,SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_Blend.SwigPyIterator_next,None,SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_Blend.SwigPyIterator___next__,None,SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_Blend.SwigPyIterator_previous,None,SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_Blend.SwigPyIterator_advance,None,SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_Blend.SwigPyIterator___eq__,None,SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_Blend.SwigPyIterator___ne__,None,SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_Blend.SwigPyIterator___iadd__,None,SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_Blend.SwigPyIterator___isub__,None,SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_Blend.SwigPyIterator___add__,None,SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_Blend.SwigPyIterator___sub__,None,SwigPyIterator)
SwigPyIterator_swigregister = _Blend.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import OCC.math
import OCC.Standard
import OCC.gp
import OCC.TColStd
import OCC.TCollection
import OCC.MMgt
import OCC.GeomAbs
import OCC.TColgp
import OCC.Adaptor2d
import OCC.Geom2d
def register_handle(handle, base_object):
    """
    Inserts the handle into the base object to
    prevent memory corruption in certain cases
    """
    try:
        if base_object.IsKind("Standard_Transient"):
            base_object.thisHandle = handle
            base_object.thisown = False
    except:
        pass

Blend_NoDecroch = _Blend.Blend_NoDecroch
Blend_DecrochRst1 = _Blend.Blend_DecrochRst1
Blend_DecrochRst2 = _Blend.Blend_DecrochRst2
Blend_DecrochBoth = _Blend.Blend_DecrochBoth
Blend_StepTooLarge = _Blend.Blend_StepTooLarge
Blend_StepTooSmall = _Blend.Blend_StepTooSmall
Blend_Backward = _Blend.Blend_Backward
Blend_SamePoints = _Blend.Blend_SamePoints
Blend_OnRst1 = _Blend.Blend_OnRst1
Blend_OnRst2 = _Blend.Blend_OnRst2
Blend_OnRst12 = _Blend.Blend_OnRst12
Blend_OK = _Blend.Blend_OK
class Blend_AppFunction(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def NbVariables(self, *args):
        """
        * returns the number of variables of the function.

        :rtype: int

        """
        return _Blend.Blend_AppFunction_NbVariables(self, *args)

    def NbEquations(self, *args):
        """
        * returns the number of equations of the function.

        :rtype: int

        """
        return _Blend.Blend_AppFunction_NbEquations(self, *args)

    def Value(self, *args):
        """
        * computes the values <F> of the Functions for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :rtype: bool

        """
        return _Blend.Blend_AppFunction_Value(self, *args)

    def Derivatives(self, *args):
        """
        * returns the values <D> of the derivatives for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _Blend.Blend_AppFunction_Derivatives(self, *args)

    def Values(self, *args):
        """
        * returns the values <F> of the functions and the derivatives <D> for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _Blend.Blend_AppFunction_Values(self, *args)

    def Set(self, *args):
        """
        * Sets the value of the parameter along the guide line. This determines the plane in which the solution has to be found.

        :param Param:
        :type Param: float
        :rtype: void

        * Sets the bounds of the parametric interval on the guide line. This determines the derivatives in these values if the function is not Cn.

        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :rtype: void

        """
        return _Blend.Blend_AppFunction_Set(self, *args)

    def GetBounds(self, *args):
        """
        * Returns in the vector InfBound the lowest values allowed for each of the 4 variables. Returns in the vector SupBound the greatest values allowed for each of the 4 variables.

        :param InfBound:
        :type InfBound: math_Vector &
        :param SupBound:
        :type SupBound: math_Vector &
        :rtype: void

        """
        return _Blend.Blend_AppFunction_GetBounds(self, *args)

    def IsSolution(self, *args):
        """
        * Returns Standard_True if Sol is a zero of the function. Tol is the tolerance used in 3d space. The computation is made at the current value of the parameter on the guide line.

        :param Sol:
        :type Sol: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: bool

        """
        return _Blend.Blend_AppFunction_IsSolution(self, *args)

    def GetMinimalDistance(self, *args):
        """
        * Returns the minimal Distance beetween two extremitys of calculed sections.

        :rtype: float

        """
        return _Blend.Blend_AppFunction_GetMinimalDistance(self, *args)

    def Pnt1(self, *args):
        """
        * Returns the point on the first support.

        :rtype: gp_Pnt

        """
        return _Blend.Blend_AppFunction_Pnt1(self, *args)

    def Pnt2(self, *args):
        """
        * Returns the point on the first support.

        :rtype: gp_Pnt

        """
        return _Blend.Blend_AppFunction_Pnt2(self, *args)

    def IsRational(self, *args):
        """
        * Returns if the section is rationnal

        :rtype: bool

        """
        return _Blend.Blend_AppFunction_IsRational(self, *args)

    def GetSectionSize(self, *args):
        """
        * Returns the length of the maximum section

        :rtype: float

        """
        return _Blend.Blend_AppFunction_GetSectionSize(self, *args)

    def GetMinimalWeight(self, *args):
        """
        * Compute the minimal value of weight for each poles of all sections.

        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :rtype: void

        """
        return _Blend.Blend_AppFunction_GetMinimalWeight(self, *args)

    def NbIntervals(self, *args):
        """
        * Returns the number of intervals for continuity <S>. May be one if Continuity(me) >= <S>

        :param S:
        :type S: GeomAbs_Shape
        :rtype: int

        """
        return _Blend.Blend_AppFunction_NbIntervals(self, *args)

    def Intervals(self, *args):
        """
        * Stores in <T> the parameters bounding the intervals of continuity <S>.  The array must provide enough room to accomodate for the parameters. i.e. T.Length() > NbIntervals() raises 	OutOfRange from Standard

        :param T:
        :type T: TColStd_Array1OfReal &
        :param S:
        :type S: GeomAbs_Shape
        :rtype: void

        """
        return _Blend.Blend_AppFunction_Intervals(self, *args)

    def GetShape(self, *args):
        """
        :param NbPoles:
        :type NbPoles: int &
        :param NbKnots:
        :type NbKnots: int &
        :param Degree:
        :type Degree: int &
        :param NbPoles2d:
        :type NbPoles2d: int &
        :rtype: void

        """
        return _Blend.Blend_AppFunction_GetShape(self, *args)

    def GetTolerance(self, *args):
        """
        * Returns in the vector Tolerance the parametric tolerance for each of the 4 variables; Tol is the tolerance used in 3d space.

        :param Tolerance:
        :type Tolerance: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: void

        * Returns the tolerance to reach in approximation to respecte BoundTol error at the Boundary AngleTol tangent error at the Boundary SurfTol error inside the surface.

        :param BoundTol:
        :type BoundTol: float
        :param SurfTol:
        :type SurfTol: float
        :param AngleTol:
        :type AngleTol: float
        :param Tol3d:
        :type Tol3d: math_Vector &
        :param Tol1D:
        :type Tol1D: math_Vector &
        :rtype: void

        """
        return _Blend.Blend_AppFunction_GetTolerance(self, *args)

    def Knots(self, *args):
        """
        :param TKnots:
        :type TKnots: TColStd_Array1OfReal &
        :rtype: void

        """
        return _Blend.Blend_AppFunction_Knots(self, *args)

    def Mults(self, *args):
        """
        :param TMults:
        :type TMults: TColStd_Array1OfInteger &
        :rtype: void

        """
        return _Blend.Blend_AppFunction_Mults(self, *args)

    def Section(self, *args):
        """
        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :rtype: bool

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :rtype: void

        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param D2Poles:
        :type D2Poles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param D2Poles2d:
        :type D2Poles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :param D2Weigths:
        :type D2Weigths: TColStd_Array1OfReal &
        :rtype: bool

        """
        return _Blend.Blend_AppFunction_Section(self, *args)

    def Resolution(self, *args):
        """
        :param IC2d:
        :type IC2d: int
        :param Tol:
        :type Tol: float
        :param TolU:
        :type TolU: float &
        :param TolV:
        :type TolV: float &
        :rtype: void

        """
        return _Blend.Blend_AppFunction_Resolution(self, *args)

    def Parameter(self, *args):
        """
        * Returns the parameter of the point P. Used to impose the parameters in the approximation.

        :param P:
        :type P: Blend_Point &
        :rtype: float

        """
        return _Blend.Blend_AppFunction_Parameter(self, *args)

    __swig_destroy__ = _Blend.delete_Blend_AppFunction
Blend_AppFunction.NbVariables = new_instancemethod(_Blend.Blend_AppFunction_NbVariables,None,Blend_AppFunction)
Blend_AppFunction.NbEquations = new_instancemethod(_Blend.Blend_AppFunction_NbEquations,None,Blend_AppFunction)
Blend_AppFunction.Value = new_instancemethod(_Blend.Blend_AppFunction_Value,None,Blend_AppFunction)
Blend_AppFunction.Derivatives = new_instancemethod(_Blend.Blend_AppFunction_Derivatives,None,Blend_AppFunction)
Blend_AppFunction.Values = new_instancemethod(_Blend.Blend_AppFunction_Values,None,Blend_AppFunction)
Blend_AppFunction.Set = new_instancemethod(_Blend.Blend_AppFunction_Set,None,Blend_AppFunction)
Blend_AppFunction.GetBounds = new_instancemethod(_Blend.Blend_AppFunction_GetBounds,None,Blend_AppFunction)
Blend_AppFunction.IsSolution = new_instancemethod(_Blend.Blend_AppFunction_IsSolution,None,Blend_AppFunction)
Blend_AppFunction.GetMinimalDistance = new_instancemethod(_Blend.Blend_AppFunction_GetMinimalDistance,None,Blend_AppFunction)
Blend_AppFunction.Pnt1 = new_instancemethod(_Blend.Blend_AppFunction_Pnt1,None,Blend_AppFunction)
Blend_AppFunction.Pnt2 = new_instancemethod(_Blend.Blend_AppFunction_Pnt2,None,Blend_AppFunction)
Blend_AppFunction.IsRational = new_instancemethod(_Blend.Blend_AppFunction_IsRational,None,Blend_AppFunction)
Blend_AppFunction.GetSectionSize = new_instancemethod(_Blend.Blend_AppFunction_GetSectionSize,None,Blend_AppFunction)
Blend_AppFunction.GetMinimalWeight = new_instancemethod(_Blend.Blend_AppFunction_GetMinimalWeight,None,Blend_AppFunction)
Blend_AppFunction.NbIntervals = new_instancemethod(_Blend.Blend_AppFunction_NbIntervals,None,Blend_AppFunction)
Blend_AppFunction.Intervals = new_instancemethod(_Blend.Blend_AppFunction_Intervals,None,Blend_AppFunction)
Blend_AppFunction.GetShape = new_instancemethod(_Blend.Blend_AppFunction_GetShape,None,Blend_AppFunction)
Blend_AppFunction.GetTolerance = new_instancemethod(_Blend.Blend_AppFunction_GetTolerance,None,Blend_AppFunction)
Blend_AppFunction.Knots = new_instancemethod(_Blend.Blend_AppFunction_Knots,None,Blend_AppFunction)
Blend_AppFunction.Mults = new_instancemethod(_Blend.Blend_AppFunction_Mults,None,Blend_AppFunction)
Blend_AppFunction.Section = new_instancemethod(_Blend.Blend_AppFunction_Section,None,Blend_AppFunction)
Blend_AppFunction.Resolution = new_instancemethod(_Blend.Blend_AppFunction_Resolution,None,Blend_AppFunction)
Blend_AppFunction.Parameter = new_instancemethod(_Blend.Blend_AppFunction_Parameter,None,Blend_AppFunction)
Blend_AppFunction_swigregister = _Blend.Blend_AppFunction_swigregister
Blend_AppFunction_swigregister(Blend_AppFunction)

class Blend_CurvPointFuncInv(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def NbVariables(self, *args):
        """
        * Returns 3.

        :rtype: int

        """
        return _Blend.Blend_CurvPointFuncInv_NbVariables(self, *args)

    def NbEquations(self, *args):
        """
        * returns the number of equations of the function.

        :rtype: int

        """
        return _Blend.Blend_CurvPointFuncInv_NbEquations(self, *args)

    def Value(self, *args):
        """
        * computes the values <F> of the Functions for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :rtype: bool

        """
        return _Blend.Blend_CurvPointFuncInv_Value(self, *args)

    def Derivatives(self, *args):
        """
        * returns the values <D> of the derivatives for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _Blend.Blend_CurvPointFuncInv_Derivatives(self, *args)

    def Values(self, *args):
        """
        * returns the values <F> of the functions and the derivatives <D> for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _Blend.Blend_CurvPointFuncInv_Values(self, *args)

    def Set(self, *args):
        """
        * Set the Point on which a solution has to be found.

        :param P:
        :type P: gp_Pnt
        :rtype: void

        """
        return _Blend.Blend_CurvPointFuncInv_Set(self, *args)

    def GetTolerance(self, *args):
        """
        * Returns in the vector Tolerance the parametric tolerance for each of the 3 variables; Tol is the tolerance used in 3d space.

        :param Tolerance:
        :type Tolerance: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: void

        """
        return _Blend.Blend_CurvPointFuncInv_GetTolerance(self, *args)

    def GetBounds(self, *args):
        """
        * Returns in the vector InfBound the lowest values allowed for each of the 3 variables. Returns in the vector SupBound the greatest values allowed for each of the 3 variables.

        :param InfBound:
        :type InfBound: math_Vector &
        :param SupBound:
        :type SupBound: math_Vector &
        :rtype: void

        """
        return _Blend.Blend_CurvPointFuncInv_GetBounds(self, *args)

    def IsSolution(self, *args):
        """
        * Returns Standard_True if Sol is a zero of the function. Tol is the tolerance used in 3d space.

        :param Sol:
        :type Sol: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: bool

        """
        return _Blend.Blend_CurvPointFuncInv_IsSolution(self, *args)

    __swig_destroy__ = _Blend.delete_Blend_CurvPointFuncInv
Blend_CurvPointFuncInv.NbVariables = new_instancemethod(_Blend.Blend_CurvPointFuncInv_NbVariables,None,Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv.NbEquations = new_instancemethod(_Blend.Blend_CurvPointFuncInv_NbEquations,None,Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv.Value = new_instancemethod(_Blend.Blend_CurvPointFuncInv_Value,None,Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv.Derivatives = new_instancemethod(_Blend.Blend_CurvPointFuncInv_Derivatives,None,Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv.Values = new_instancemethod(_Blend.Blend_CurvPointFuncInv_Values,None,Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv.Set = new_instancemethod(_Blend.Blend_CurvPointFuncInv_Set,None,Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv.GetTolerance = new_instancemethod(_Blend.Blend_CurvPointFuncInv_GetTolerance,None,Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv.GetBounds = new_instancemethod(_Blend.Blend_CurvPointFuncInv_GetBounds,None,Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv.IsSolution = new_instancemethod(_Blend.Blend_CurvPointFuncInv_IsSolution,None,Blend_CurvPointFuncInv)
Blend_CurvPointFuncInv_swigregister = _Blend.Blend_CurvPointFuncInv_swigregister
Blend_CurvPointFuncInv_swigregister(Blend_CurvPointFuncInv)

class Blend_FuncInv(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def NbVariables(self, *args):
        """
        * Returns 4.

        :rtype: int

        """
        return _Blend.Blend_FuncInv_NbVariables(self, *args)

    def NbEquations(self, *args):
        """
        * returns the number of equations of the function.

        :rtype: int

        """
        return _Blend.Blend_FuncInv_NbEquations(self, *args)

    def Value(self, *args):
        """
        * computes the values <F> of the Functions for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :rtype: bool

        """
        return _Blend.Blend_FuncInv_Value(self, *args)

    def Derivatives(self, *args):
        """
        * returns the values <D> of the derivatives for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _Blend.Blend_FuncInv_Derivatives(self, *args)

    def Values(self, *args):
        """
        * returns the values <F> of the functions and the derivatives <D> for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _Blend.Blend_FuncInv_Values(self, *args)

    def Set(self, *args):
        """
        * Sets the CurveOnSurface on which a solution has to be found. If <OnFirst> is set to Standard_True, the curve will be on the first surface, otherwise the curve is on the second one.

        :param OnFirst:
        :type OnFirst: bool
        :param COnSurf:
        :type COnSurf: Handle_Adaptor2d_HCurve2d &
        :rtype: void

        """
        return _Blend.Blend_FuncInv_Set(self, *args)

    def GetTolerance(self, *args):
        """
        * Returns in the vector Tolerance the parametric tolerance for each of the 4 variables; Tol is the tolerance used in 3d space.

        :param Tolerance:
        :type Tolerance: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: void

        """
        return _Blend.Blend_FuncInv_GetTolerance(self, *args)

    def GetBounds(self, *args):
        """
        * Returns in the vector InfBound the lowest values allowed for each of the 4 variables. Returns in the vector SupBound the greatest values allowed for each of the 4 variables.

        :param InfBound:
        :type InfBound: math_Vector &
        :param SupBound:
        :type SupBound: math_Vector &
        :rtype: void

        """
        return _Blend.Blend_FuncInv_GetBounds(self, *args)

    def IsSolution(self, *args):
        """
        * Returns Standard_True if Sol is a zero of the function. Tol is the tolerance used in 3d space.

        :param Sol:
        :type Sol: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: bool

        """
        return _Blend.Blend_FuncInv_IsSolution(self, *args)

    __swig_destroy__ = _Blend.delete_Blend_FuncInv
Blend_FuncInv.NbVariables = new_instancemethod(_Blend.Blend_FuncInv_NbVariables,None,Blend_FuncInv)
Blend_FuncInv.NbEquations = new_instancemethod(_Blend.Blend_FuncInv_NbEquations,None,Blend_FuncInv)
Blend_FuncInv.Value = new_instancemethod(_Blend.Blend_FuncInv_Value,None,Blend_FuncInv)
Blend_FuncInv.Derivatives = new_instancemethod(_Blend.Blend_FuncInv_Derivatives,None,Blend_FuncInv)
Blend_FuncInv.Values = new_instancemethod(_Blend.Blend_FuncInv_Values,None,Blend_FuncInv)
Blend_FuncInv.Set = new_instancemethod(_Blend.Blend_FuncInv_Set,None,Blend_FuncInv)
Blend_FuncInv.GetTolerance = new_instancemethod(_Blend.Blend_FuncInv_GetTolerance,None,Blend_FuncInv)
Blend_FuncInv.GetBounds = new_instancemethod(_Blend.Blend_FuncInv_GetBounds,None,Blend_FuncInv)
Blend_FuncInv.IsSolution = new_instancemethod(_Blend.Blend_FuncInv_IsSolution,None,Blend_FuncInv)
Blend_FuncInv_swigregister = _Blend.Blend_FuncInv_swigregister
Blend_FuncInv_swigregister(Blend_FuncInv)

class Blend_Point(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        * Creates a point on 2 surfaces, with tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param Tg1:
        :type Tg1: gp_Vec
        :param Tg2:
        :type Tg2: gp_Vec
        :param Tg12d:
        :type Tg12d: gp_Vec2d
        :param Tg22d:
        :type Tg22d: gp_Vec2d
        :rtype: None

        * Creates a point on 2 surfaces, without tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :rtype: None

        * Creates a point on a surface and a curve, with tangents.

        :param Pts:
        :type Pts: gp_Pnt
        :param Ptc:
        :type Ptc: gp_Pnt
        :param Param:
        :type Param: float
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param W:
        :type W: float
        :param Tgs:
        :type Tgs: gp_Vec
        :param Tgc:
        :type Tgc: gp_Vec
        :param Tg2d:
        :type Tg2d: gp_Vec2d
        :rtype: None

        * Creates a point on a surface and a curve, without tangents.

        :param Pts:
        :type Pts: gp_Pnt
        :param Ptc:
        :type Ptc: gp_Pnt
        :param Param:
        :type Param: float
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param W:
        :type W: float
        :rtype: None

        * Creates a point on a surface and a curve on surface, with tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param PC:
        :type PC: float
        :param Tg1:
        :type Tg1: gp_Vec
        :param Tg2:
        :type Tg2: gp_Vec
        :param Tg12d:
        :type Tg12d: gp_Vec2d
        :param Tg22d:
        :type Tg22d: gp_Vec2d
        :rtype: None

        * Creates a point on a surface and a curve on surface, without tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param PC:
        :type PC: float
        :rtype: None

        * Creates a point on two curves on surfaces, with tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param PC1:
        :type PC1: float
        :param PC2:
        :type PC2: float
        :param Tg1:
        :type Tg1: gp_Vec
        :param Tg2:
        :type Tg2: gp_Vec
        :param Tg12d:
        :type Tg12d: gp_Vec2d
        :param Tg22d:
        :type Tg22d: gp_Vec2d
        :rtype: None

        * Creates a point on two curves on surfaces, with tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param PC1:
        :type PC1: float
        :param PC2:
        :type PC2: float
        :rtype: None

        """
        _Blend.Blend_Point_swiginit(self,_Blend.new_Blend_Point(*args))
    def SetValue(self, *args):
        """
        * Set the values for a point on 2 surfaces, with tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param Tg1:
        :type Tg1: gp_Vec
        :param Tg2:
        :type Tg2: gp_Vec
        :param Tg12d:
        :type Tg12d: gp_Vec2d
        :param Tg22d:
        :type Tg22d: gp_Vec2d
        :rtype: None

        * Set the values for a point on 2 surfaces, without tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :rtype: None

        * Set the values for a point on a surface and a curve, with tangents.

        :param Pts:
        :type Pts: gp_Pnt
        :param Ptc:
        :type Ptc: gp_Pnt
        :param Param:
        :type Param: float
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param W:
        :type W: float
        :param Tgs:
        :type Tgs: gp_Vec
        :param Tgc:
        :type Tgc: gp_Vec
        :param Tg2d:
        :type Tg2d: gp_Vec2d
        :rtype: None

        * Set the values for a point on a surface and a curve, without tangents.

        :param Pts:
        :type Pts: gp_Pnt
        :param Ptc:
        :type Ptc: gp_Pnt
        :param Param:
        :type Param: float
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param W:
        :type W: float
        :rtype: None

        * Creates a point on a surface and a curve on surface, with tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param PC:
        :type PC: float
        :param Tg1:
        :type Tg1: gp_Vec
        :param Tg2:
        :type Tg2: gp_Vec
        :param Tg12d:
        :type Tg12d: gp_Vec2d
        :param Tg22d:
        :type Tg22d: gp_Vec2d
        :rtype: None

        * Creates a point on a surface and a curve on surface, without tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param PC:
        :type PC: float
        :rtype: None

        * Creates a point on two curves on surfaces, with tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param PC1:
        :type PC1: float
        :param PC2:
        :type PC2: float
        :param Tg1:
        :type Tg1: gp_Vec
        :param Tg2:
        :type Tg2: gp_Vec
        :param Tg12d:
        :type Tg12d: gp_Vec2d
        :param Tg22d:
        :type Tg22d: gp_Vec2d
        :rtype: None

        * Creates a point on two curves on surfaces, without tangents.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param PC1:
        :type PC1: float
        :param PC2:
        :type PC2: float
        :rtype: None

        * Creates a point on two curves.

        :param Pt1:
        :type Pt1: gp_Pnt
        :param Pt2:
        :type Pt2: gp_Pnt
        :param Param:
        :type Param: float
        :param PC1:
        :type PC1: float
        :param PC2:
        :type PC2: float
        :rtype: None

        """
        return _Blend.Blend_Point_SetValue(self, *args)

    def Parameter(self, *args):
        """
        :rtype: float

        """
        return _Blend.Blend_Point_Parameter(self, *args)

    def IsTangencyPoint(self, *args):
        """
        * Returns Standard_True if it was not possible to compute the tangent vectors at PointOnS1 and/or PointOnS2.

        :rtype: bool

        """
        return _Blend.Blend_Point_IsTangencyPoint(self, *args)

    def PointOnS1(self, *args):
        """
        :rtype: gp_Pnt

        """
        return _Blend.Blend_Point_PointOnS1(self, *args)

    def PointOnS2(self, *args):
        """
        :rtype: gp_Pnt

        """
        return _Blend.Blend_Point_PointOnS2(self, *args)

    def ParametersOnS1(self, *args):
        """
        :param U:
        :type U: float &
        :param V:
        :type V: float &
        :rtype: None

        """
        return _Blend.Blend_Point_ParametersOnS1(self, *args)

    def ParametersOnS2(self, *args):
        """
        :param U:
        :type U: float &
        :param V:
        :type V: float &
        :rtype: None

        """
        return _Blend.Blend_Point_ParametersOnS2(self, *args)

    def TangentOnS1(self, *args):
        """
        :rtype: gp_Vec

        """
        return _Blend.Blend_Point_TangentOnS1(self, *args)

    def TangentOnS2(self, *args):
        """
        :rtype: gp_Vec

        """
        return _Blend.Blend_Point_TangentOnS2(self, *args)

    def Tangent2dOnS1(self, *args):
        """
        :rtype: gp_Vec2d

        """
        return _Blend.Blend_Point_Tangent2dOnS1(self, *args)

    def Tangent2dOnS2(self, *args):
        """
        :rtype: gp_Vec2d

        """
        return _Blend.Blend_Point_Tangent2dOnS2(self, *args)

    def PointOnS(self, *args):
        """
        :rtype: gp_Pnt

        """
        return _Blend.Blend_Point_PointOnS(self, *args)

    def PointOnC(self, *args):
        """
        :rtype: gp_Pnt

        """
        return _Blend.Blend_Point_PointOnC(self, *args)

    def ParametersOnS(self, *args):
        """
        :param U:
        :type U: float &
        :param V:
        :type V: float &
        :rtype: None

        """
        return _Blend.Blend_Point_ParametersOnS(self, *args)

    def ParameterOnC(self, *args):
        """
        :rtype: float

        """
        return _Blend.Blend_Point_ParameterOnC(self, *args)

    def TangentOnS(self, *args):
        """
        :rtype: gp_Vec

        """
        return _Blend.Blend_Point_TangentOnS(self, *args)

    def TangentOnC(self, *args):
        """
        :rtype: gp_Vec

        """
        return _Blend.Blend_Point_TangentOnC(self, *args)

    def Tangent2d(self, *args):
        """
        :rtype: gp_Vec2d

        """
        return _Blend.Blend_Point_Tangent2d(self, *args)

    def PointOnC1(self, *args):
        """
        :rtype: gp_Pnt

        """
        return _Blend.Blend_Point_PointOnC1(self, *args)

    def PointOnC2(self, *args):
        """
        :rtype: gp_Pnt

        """
        return _Blend.Blend_Point_PointOnC2(self, *args)

    def ParameterOnC1(self, *args):
        """
        :rtype: float

        """
        return _Blend.Blend_Point_ParameterOnC1(self, *args)

    def ParameterOnC2(self, *args):
        """
        :rtype: float

        """
        return _Blend.Blend_Point_ParameterOnC2(self, *args)

    def TangentOnC1(self, *args):
        """
        :rtype: gp_Vec

        """
        return _Blend.Blend_Point_TangentOnC1(self, *args)

    def TangentOnC2(self, *args):
        """
        :rtype: gp_Vec

        """
        return _Blend.Blend_Point_TangentOnC2(self, *args)

    __swig_destroy__ = _Blend.delete_Blend_Point
Blend_Point.SetValue = new_instancemethod(_Blend.Blend_Point_SetValue,None,Blend_Point)
Blend_Point.Parameter = new_instancemethod(_Blend.Blend_Point_Parameter,None,Blend_Point)
Blend_Point.IsTangencyPoint = new_instancemethod(_Blend.Blend_Point_IsTangencyPoint,None,Blend_Point)
Blend_Point.PointOnS1 = new_instancemethod(_Blend.Blend_Point_PointOnS1,None,Blend_Point)
Blend_Point.PointOnS2 = new_instancemethod(_Blend.Blend_Point_PointOnS2,None,Blend_Point)
Blend_Point.ParametersOnS1 = new_instancemethod(_Blend.Blend_Point_ParametersOnS1,None,Blend_Point)
Blend_Point.ParametersOnS2 = new_instancemethod(_Blend.Blend_Point_ParametersOnS2,None,Blend_Point)
Blend_Point.TangentOnS1 = new_instancemethod(_Blend.Blend_Point_TangentOnS1,None,Blend_Point)
Blend_Point.TangentOnS2 = new_instancemethod(_Blend.Blend_Point_TangentOnS2,None,Blend_Point)
Blend_Point.Tangent2dOnS1 = new_instancemethod(_Blend.Blend_Point_Tangent2dOnS1,None,Blend_Point)
Blend_Point.Tangent2dOnS2 = new_instancemethod(_Blend.Blend_Point_Tangent2dOnS2,None,Blend_Point)
Blend_Point.PointOnS = new_instancemethod(_Blend.Blend_Point_PointOnS,None,Blend_Point)
Blend_Point.PointOnC = new_instancemethod(_Blend.Blend_Point_PointOnC,None,Blend_Point)
Blend_Point.ParametersOnS = new_instancemethod(_Blend.Blend_Point_ParametersOnS,None,Blend_Point)
Blend_Point.ParameterOnC = new_instancemethod(_Blend.Blend_Point_ParameterOnC,None,Blend_Point)
Blend_Point.TangentOnS = new_instancemethod(_Blend.Blend_Point_TangentOnS,None,Blend_Point)
Blend_Point.TangentOnC = new_instancemethod(_Blend.Blend_Point_TangentOnC,None,Blend_Point)
Blend_Point.Tangent2d = new_instancemethod(_Blend.Blend_Point_Tangent2d,None,Blend_Point)
Blend_Point.PointOnC1 = new_instancemethod(_Blend.Blend_Point_PointOnC1,None,Blend_Point)
Blend_Point.PointOnC2 = new_instancemethod(_Blend.Blend_Point_PointOnC2,None,Blend_Point)
Blend_Point.ParameterOnC1 = new_instancemethod(_Blend.Blend_Point_ParameterOnC1,None,Blend_Point)
Blend_Point.ParameterOnC2 = new_instancemethod(_Blend.Blend_Point_ParameterOnC2,None,Blend_Point)
Blend_Point.TangentOnC1 = new_instancemethod(_Blend.Blend_Point_TangentOnC1,None,Blend_Point)
Blend_Point.TangentOnC2 = new_instancemethod(_Blend.Blend_Point_TangentOnC2,None,Blend_Point)
Blend_Point_swigregister = _Blend.Blend_Point_swigregister
Blend_Point_swigregister(Blend_Point)

class Blend_SequenceNodeOfSequenceOfPoint(OCC.TCollection.TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param I:
        :type I: Blend_Point &
        :param n:
        :type n: TCollection_SeqNodePtr &
        :param p:
        :type p: TCollection_SeqNodePtr &
        :rtype: None

        """
        _Blend.Blend_SequenceNodeOfSequenceOfPoint_swiginit(self,_Blend.new_Blend_SequenceNodeOfSequenceOfPoint(*args))
    def Value(self, *args):
        """
        :rtype: Blend_Point

        """
        return _Blend.Blend_SequenceNodeOfSequenceOfPoint_Value(self, *args)

    def GetHandle(self):
        try:
            return self.thisHandle
        except:
            self.thisHandle = Handle_Blend_SequenceNodeOfSequenceOfPoint(self)
            self.thisown = False
            return self.thisHandle

    __swig_destroy__ = _Blend.delete_Blend_SequenceNodeOfSequenceOfPoint
Blend_SequenceNodeOfSequenceOfPoint.Value = new_instancemethod(_Blend.Blend_SequenceNodeOfSequenceOfPoint_Value,None,Blend_SequenceNodeOfSequenceOfPoint)
Blend_SequenceNodeOfSequenceOfPoint_swigregister = _Blend.Blend_SequenceNodeOfSequenceOfPoint_swigregister
Blend_SequenceNodeOfSequenceOfPoint_swigregister(Blend_SequenceNodeOfSequenceOfPoint)

class Handle_Blend_SequenceNodeOfSequenceOfPoint(OCC.TCollection.Handle_TCollection_SeqNode):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        _Blend.Handle_Blend_SequenceNodeOfSequenceOfPoint_swiginit(self,_Blend.new_Handle_Blend_SequenceNodeOfSequenceOfPoint(*args))
        # register the handle in the base object
        if len(args) > 0:
            register_handle(self, args[0])



    DownCast = staticmethod(_Blend.Handle_Blend_SequenceNodeOfSequenceOfPoint_DownCast)
    __swig_destroy__ = _Blend.delete_Handle_Blend_SequenceNodeOfSequenceOfPoint
Handle_Blend_SequenceNodeOfSequenceOfPoint.Nullify = new_instancemethod(_Blend.Handle_Blend_SequenceNodeOfSequenceOfPoint_Nullify,None,Handle_Blend_SequenceNodeOfSequenceOfPoint)
Handle_Blend_SequenceNodeOfSequenceOfPoint.IsNull = new_instancemethod(_Blend.Handle_Blend_SequenceNodeOfSequenceOfPoint_IsNull,None,Handle_Blend_SequenceNodeOfSequenceOfPoint)
Handle_Blend_SequenceNodeOfSequenceOfPoint.GetObject = new_instancemethod(_Blend.Handle_Blend_SequenceNodeOfSequenceOfPoint_GetObject,None,Handle_Blend_SequenceNodeOfSequenceOfPoint)
Handle_Blend_SequenceNodeOfSequenceOfPoint_swigregister = _Blend.Handle_Blend_SequenceNodeOfSequenceOfPoint_swigregister
Handle_Blend_SequenceNodeOfSequenceOfPoint_swigregister(Handle_Blend_SequenceNodeOfSequenceOfPoint)

def Handle_Blend_SequenceNodeOfSequenceOfPoint_DownCast(*args):
  return _Blend.Handle_Blend_SequenceNodeOfSequenceOfPoint_DownCast(*args)
Handle_Blend_SequenceNodeOfSequenceOfPoint_DownCast = _Blend.Handle_Blend_SequenceNodeOfSequenceOfPoint_DownCast

class Blend_SequenceOfPoint(OCC.TCollection.TCollection_BaseSequence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :rtype: None

        """
        _Blend.Blend_SequenceOfPoint_swiginit(self,_Blend.new_Blend_SequenceOfPoint(*args))
    def Clear(self, *args):
        """
        :rtype: None

        """
        return _Blend.Blend_SequenceOfPoint_Clear(self, *args)

    def Assign(self, *args):
        """
        :param Other:
        :type Other: Blend_SequenceOfPoint &
        :rtype: Blend_SequenceOfPoint

        """
        return _Blend.Blend_SequenceOfPoint_Assign(self, *args)

    def Set(self, *args):
        """
        :param Other:
        :type Other: Blend_SequenceOfPoint &
        :rtype: Blend_SequenceOfPoint

        """
        return _Blend.Blend_SequenceOfPoint_Set(self, *args)

    def Append(self, *args):
        """
        :param T:
        :type T: Blend_Point &
        :rtype: None

        :param S:
        :type S: Blend_SequenceOfPoint &
        :rtype: None

        """
        return _Blend.Blend_SequenceOfPoint_Append(self, *args)

    def Prepend(self, *args):
        """
        :param T:
        :type T: Blend_Point &
        :rtype: None

        :param S:
        :type S: Blend_SequenceOfPoint &
        :rtype: None

        """
        return _Blend.Blend_SequenceOfPoint_Prepend(self, *args)

    def InsertBefore(self, *args):
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Blend_Point &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: Blend_SequenceOfPoint &
        :rtype: None

        """
        return _Blend.Blend_SequenceOfPoint_InsertBefore(self, *args)

    def InsertAfter(self, *args):
        """
        :param Index:
        :type Index: int
        :param T:
        :type T: Blend_Point &
        :rtype: None

        :param Index:
        :type Index: int
        :param S:
        :type S: Blend_SequenceOfPoint &
        :rtype: None

        """
        return _Blend.Blend_SequenceOfPoint_InsertAfter(self, *args)

    def First(self, *args):
        """
        :rtype: Blend_Point

        """
        return _Blend.Blend_SequenceOfPoint_First(self, *args)

    def Last(self, *args):
        """
        :rtype: Blend_Point

        """
        return _Blend.Blend_SequenceOfPoint_Last(self, *args)

    def Split(self, *args):
        """
        :param Index:
        :type Index: int
        :param Sub:
        :type Sub: Blend_SequenceOfPoint &
        :rtype: None

        """
        return _Blend.Blend_SequenceOfPoint_Split(self, *args)

    def Value(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Blend_Point

        """
        return _Blend.Blend_SequenceOfPoint_Value(self, *args)

    def SetValue(self, *args):
        """
        :param Index:
        :type Index: int
        :param I:
        :type I: Blend_Point &
        :rtype: None

        """
        return _Blend.Blend_SequenceOfPoint_SetValue(self, *args)

    def ChangeValue(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: Blend_Point

        """
        return _Blend.Blend_SequenceOfPoint_ChangeValue(self, *args)

    def Remove(self, *args):
        """
        :param Index:
        :type Index: int
        :rtype: None

        :param FromIndex:
        :type FromIndex: int
        :param ToIndex:
        :type ToIndex: int
        :rtype: None

        """
        return _Blend.Blend_SequenceOfPoint_Remove(self, *args)

    __swig_destroy__ = _Blend.delete_Blend_SequenceOfPoint
Blend_SequenceOfPoint.Clear = new_instancemethod(_Blend.Blend_SequenceOfPoint_Clear,None,Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Assign = new_instancemethod(_Blend.Blend_SequenceOfPoint_Assign,None,Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Set = new_instancemethod(_Blend.Blend_SequenceOfPoint_Set,None,Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Append = new_instancemethod(_Blend.Blend_SequenceOfPoint_Append,None,Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Prepend = new_instancemethod(_Blend.Blend_SequenceOfPoint_Prepend,None,Blend_SequenceOfPoint)
Blend_SequenceOfPoint.InsertBefore = new_instancemethod(_Blend.Blend_SequenceOfPoint_InsertBefore,None,Blend_SequenceOfPoint)
Blend_SequenceOfPoint.InsertAfter = new_instancemethod(_Blend.Blend_SequenceOfPoint_InsertAfter,None,Blend_SequenceOfPoint)
Blend_SequenceOfPoint.First = new_instancemethod(_Blend.Blend_SequenceOfPoint_First,None,Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Last = new_instancemethod(_Blend.Blend_SequenceOfPoint_Last,None,Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Split = new_instancemethod(_Blend.Blend_SequenceOfPoint_Split,None,Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Value = new_instancemethod(_Blend.Blend_SequenceOfPoint_Value,None,Blend_SequenceOfPoint)
Blend_SequenceOfPoint.SetValue = new_instancemethod(_Blend.Blend_SequenceOfPoint_SetValue,None,Blend_SequenceOfPoint)
Blend_SequenceOfPoint.ChangeValue = new_instancemethod(_Blend.Blend_SequenceOfPoint_ChangeValue,None,Blend_SequenceOfPoint)
Blend_SequenceOfPoint.Remove = new_instancemethod(_Blend.Blend_SequenceOfPoint_Remove,None,Blend_SequenceOfPoint)
Blend_SequenceOfPoint_swigregister = _Blend.Blend_SequenceOfPoint_swigregister
Blend_SequenceOfPoint_swigregister(Blend_SequenceOfPoint)

class Blend_SurfCurvFuncInv(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def NbVariables(self, *args):
        """
        * Returns 3.

        :rtype: int

        """
        return _Blend.Blend_SurfCurvFuncInv_NbVariables(self, *args)

    def NbEquations(self, *args):
        """
        * returns the number of equations of the function.

        :rtype: int

        """
        return _Blend.Blend_SurfCurvFuncInv_NbEquations(self, *args)

    def Value(self, *args):
        """
        * computes the values <F> of the Functions for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :rtype: bool

        """
        return _Blend.Blend_SurfCurvFuncInv_Value(self, *args)

    def Derivatives(self, *args):
        """
        * returns the values <D> of the derivatives for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _Blend.Blend_SurfCurvFuncInv_Derivatives(self, *args)

    def Values(self, *args):
        """
        * returns the values <F> of the functions and the derivatives <D> for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _Blend.Blend_SurfCurvFuncInv_Values(self, *args)

    def Set(self, *args):
        """
        * Set the Point on which a solution has to be found.

        :param Rst:
        :type Rst: Handle_Adaptor2d_HCurve2d &
        :rtype: void

        """
        return _Blend.Blend_SurfCurvFuncInv_Set(self, *args)

    def GetTolerance(self, *args):
        """
        * Returns in the vector Tolerance the parametric tolerance for each of the 3 variables; Tol is the tolerance used in 3d space.

        :param Tolerance:
        :type Tolerance: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: void

        """
        return _Blend.Blend_SurfCurvFuncInv_GetTolerance(self, *args)

    def GetBounds(self, *args):
        """
        * Returns in the vector InfBound the lowest values allowed for each of the 3 variables. Returns in the vector SupBound the greatest values allowed for each of the 3 variables.

        :param InfBound:
        :type InfBound: math_Vector &
        :param SupBound:
        :type SupBound: math_Vector &
        :rtype: void

        """
        return _Blend.Blend_SurfCurvFuncInv_GetBounds(self, *args)

    def IsSolution(self, *args):
        """
        * Returns Standard_True if Sol is a zero of the function. Tol is the tolerance used in 3d space.

        :param Sol:
        :type Sol: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: bool

        """
        return _Blend.Blend_SurfCurvFuncInv_IsSolution(self, *args)

    __swig_destroy__ = _Blend.delete_Blend_SurfCurvFuncInv
Blend_SurfCurvFuncInv.NbVariables = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_NbVariables,None,Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv.NbEquations = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_NbEquations,None,Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv.Value = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_Value,None,Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv.Derivatives = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_Derivatives,None,Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv.Values = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_Values,None,Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv.Set = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_Set,None,Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv.GetTolerance = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_GetTolerance,None,Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv.GetBounds = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_GetBounds,None,Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv.IsSolution = new_instancemethod(_Blend.Blend_SurfCurvFuncInv_IsSolution,None,Blend_SurfCurvFuncInv)
Blend_SurfCurvFuncInv_swigregister = _Blend.Blend_SurfCurvFuncInv_swigregister
Blend_SurfCurvFuncInv_swigregister(Blend_SurfCurvFuncInv)

class Blend_SurfPointFuncInv(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def NbVariables(self, *args):
        """
        * Returns 3.

        :rtype: int

        """
        return _Blend.Blend_SurfPointFuncInv_NbVariables(self, *args)

    def NbEquations(self, *args):
        """
        * returns the number of equations of the function.

        :rtype: int

        """
        return _Blend.Blend_SurfPointFuncInv_NbEquations(self, *args)

    def Value(self, *args):
        """
        * computes the values <F> of the Functions for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :rtype: bool

        """
        return _Blend.Blend_SurfPointFuncInv_Value(self, *args)

    def Derivatives(self, *args):
        """
        * returns the values <D> of the derivatives for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _Blend.Blend_SurfPointFuncInv_Derivatives(self, *args)

    def Values(self, *args):
        """
        * returns the values <F> of the functions and the derivatives <D> for the variable <X>. Returns True if the computation was done successfully, False otherwise.

        :param X:
        :type X: math_Vector &
        :param F:
        :type F: math_Vector &
        :param D:
        :type D: math_Matrix &
        :rtype: bool

        """
        return _Blend.Blend_SurfPointFuncInv_Values(self, *args)

    def Set(self, *args):
        """
        * Set the Point on which a solution has to be found.

        :param P:
        :type P: gp_Pnt
        :rtype: void

        """
        return _Blend.Blend_SurfPointFuncInv_Set(self, *args)

    def GetTolerance(self, *args):
        """
        * Returns in the vector Tolerance the parametric tolerance for each of the 3 variables; Tol is the tolerance used in 3d space.

        :param Tolerance:
        :type Tolerance: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: void

        """
        return _Blend.Blend_SurfPointFuncInv_GetTolerance(self, *args)

    def GetBounds(self, *args):
        """
        * Returns in the vector InfBound the lowest values allowed for each of the 3 variables. Returns in the vector SupBound the greatest values allowed for each of the 3 variables.

        :param InfBound:
        :type InfBound: math_Vector &
        :param SupBound:
        :type SupBound: math_Vector &
        :rtype: void

        """
        return _Blend.Blend_SurfPointFuncInv_GetBounds(self, *args)

    def IsSolution(self, *args):
        """
        * Returns Standard_True if Sol is a zero of the function. Tol is the tolerance used in 3d space.

        :param Sol:
        :type Sol: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: bool

        """
        return _Blend.Blend_SurfPointFuncInv_IsSolution(self, *args)

    __swig_destroy__ = _Blend.delete_Blend_SurfPointFuncInv
Blend_SurfPointFuncInv.NbVariables = new_instancemethod(_Blend.Blend_SurfPointFuncInv_NbVariables,None,Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv.NbEquations = new_instancemethod(_Blend.Blend_SurfPointFuncInv_NbEquations,None,Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv.Value = new_instancemethod(_Blend.Blend_SurfPointFuncInv_Value,None,Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv.Derivatives = new_instancemethod(_Blend.Blend_SurfPointFuncInv_Derivatives,None,Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv.Values = new_instancemethod(_Blend.Blend_SurfPointFuncInv_Values,None,Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv.Set = new_instancemethod(_Blend.Blend_SurfPointFuncInv_Set,None,Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv.GetTolerance = new_instancemethod(_Blend.Blend_SurfPointFuncInv_GetTolerance,None,Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv.GetBounds = new_instancemethod(_Blend.Blend_SurfPointFuncInv_GetBounds,None,Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv.IsSolution = new_instancemethod(_Blend.Blend_SurfPointFuncInv_IsSolution,None,Blend_SurfPointFuncInv)
Blend_SurfPointFuncInv_swigregister = _Blend.Blend_SurfPointFuncInv_swigregister
Blend_SurfPointFuncInv_swigregister(Blend_SurfPointFuncInv)

class Blend_CSFunction(Blend_AppFunction):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def Set(self, *args):
        """
        * Sets the value of the parameter along the guide line. This determines the plane in which the solution has to be found.

        :param Param:
        :type Param: float
        :rtype: void

        * Sets the bounds of the parametric interval on the guide line. This determines the derivatives in these values if the function is not Cn.

        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :rtype: void

        """
        return _Blend.Blend_CSFunction_Set(self, *args)

    def PointOnS(self, *args):
        """
        * Returns the point on the surface.

        :rtype: gp_Pnt

        """
        return _Blend.Blend_CSFunction_PointOnS(self, *args)

    def PointOnC(self, *args):
        """
        * Returns the point on the curve.

        :rtype: gp_Pnt

        """
        return _Blend.Blend_CSFunction_PointOnC(self, *args)

    def Pnt2d(self, *args):
        """
        * Returns U,V coordinates of the point on the surface.

        :rtype: gp_Pnt2d

        """
        return _Blend.Blend_CSFunction_Pnt2d(self, *args)

    def ParameterOnC(self, *args):
        """
        * Returns parameter of the point on the curve.

        :rtype: float

        """
        return _Blend.Blend_CSFunction_ParameterOnC(self, *args)

    def IsTangencyPoint(self, *args):
        """
        * Returns True when it is not possible to compute the tangent vectors at PointOnS and/or PointOnC.

        :rtype: bool

        """
        return _Blend.Blend_CSFunction_IsTangencyPoint(self, *args)

    def TangentOnS(self, *args):
        """
        * Returns the tangent vector at PointOnS, in 3d space.

        :rtype: gp_Vec

        """
        return _Blend.Blend_CSFunction_TangentOnS(self, *args)

    def Tangent2d(self, *args):
        """
        * Returns the tangent vector at PointOnS, in the parametric space of the first surface.

        :rtype: gp_Vec2d

        """
        return _Blend.Blend_CSFunction_Tangent2d(self, *args)

    def TangentOnC(self, *args):
        """
        * Returns the tangent vector at PointOnC, in 3d space.

        :rtype: gp_Vec

        """
        return _Blend.Blend_CSFunction_TangentOnC(self, *args)

    def Tangent(self, *args):
        """
        * Returns the tangent vector at the section, at the beginning and the end of the section, and returns the normal (of the surfaces) at these points.

        :param U:
        :type U: float
        :param V:
        :type V: float
        :param TgS:
        :type TgS: gp_Vec
        :param NormS:
        :type NormS: gp_Vec
        :rtype: void

        """
        return _Blend.Blend_CSFunction_Tangent(self, *args)

    def GetTolerance(self, *args):
        """
        * Returns in the vector Tolerance the parametric tolerance for each of the 3 variables; Tol is the tolerance used in 3d space.

        :param Tolerance:
        :type Tolerance: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: void

        * Returns the tolerance to reach in approximation to respecte BoundTol error at the Boundary AngleTol tangent error at the Boundary SurfTol error inside the surface.

        :param BoundTol:
        :type BoundTol: float
        :param SurfTol:
        :type SurfTol: float
        :param AngleTol:
        :type AngleTol: float
        :param Tol3d:
        :type Tol3d: math_Vector &
        :param Tol1D:
        :type Tol1D: math_Vector &
        :rtype: void

        """
        return _Blend.Blend_CSFunction_GetTolerance(self, *args)

    def Section(self, *args):
        """
        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :rtype: bool

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :rtype: void

        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param D2Poles:
        :type D2Poles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param D2Poles2d:
        :type D2Poles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :param D2Weigths:
        :type D2Weigths: TColStd_Array1OfReal &
        :rtype: bool

        """
        return _Blend.Blend_CSFunction_Section(self, *args)

    __swig_destroy__ = _Blend.delete_Blend_CSFunction
Blend_CSFunction.Set = new_instancemethod(_Blend.Blend_CSFunction_Set,None,Blend_CSFunction)
Blend_CSFunction.PointOnS = new_instancemethod(_Blend.Blend_CSFunction_PointOnS,None,Blend_CSFunction)
Blend_CSFunction.PointOnC = new_instancemethod(_Blend.Blend_CSFunction_PointOnC,None,Blend_CSFunction)
Blend_CSFunction.Pnt2d = new_instancemethod(_Blend.Blend_CSFunction_Pnt2d,None,Blend_CSFunction)
Blend_CSFunction.ParameterOnC = new_instancemethod(_Blend.Blend_CSFunction_ParameterOnC,None,Blend_CSFunction)
Blend_CSFunction.IsTangencyPoint = new_instancemethod(_Blend.Blend_CSFunction_IsTangencyPoint,None,Blend_CSFunction)
Blend_CSFunction.TangentOnS = new_instancemethod(_Blend.Blend_CSFunction_TangentOnS,None,Blend_CSFunction)
Blend_CSFunction.Tangent2d = new_instancemethod(_Blend.Blend_CSFunction_Tangent2d,None,Blend_CSFunction)
Blend_CSFunction.TangentOnC = new_instancemethod(_Blend.Blend_CSFunction_TangentOnC,None,Blend_CSFunction)
Blend_CSFunction.Tangent = new_instancemethod(_Blend.Blend_CSFunction_Tangent,None,Blend_CSFunction)
Blend_CSFunction.GetTolerance = new_instancemethod(_Blend.Blend_CSFunction_GetTolerance,None,Blend_CSFunction)
Blend_CSFunction.Section = new_instancemethod(_Blend.Blend_CSFunction_Section,None,Blend_CSFunction)
Blend_CSFunction_swigregister = _Blend.Blend_CSFunction_swigregister
Blend_CSFunction_swigregister(Blend_CSFunction)

class Blend_Function(Blend_AppFunction):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def Set(self, *args):
        """
        * Sets the value of the parameter along the guide line. This determines the plane in which the solution has to be found.

        :param Param:
        :type Param: float
        :rtype: void

        * Sets the bounds of the parametric interval on the guide line. This determines the derivatives in these values if the function is not Cn.

        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :rtype: void

        """
        return _Blend.Blend_Function_Set(self, *args)

    def PointOnS1(self, *args):
        """
        * Returns the point on the first surface, at parameter Sol(1),Sol(2) (Sol is the vector used in the call of IsSolution.

        :rtype: gp_Pnt

        """
        return _Blend.Blend_Function_PointOnS1(self, *args)

    def PointOnS2(self, *args):
        """
        * Returns the point on the second surface, at parameter Sol(3),Sol(4) (Sol is the vector used in the call of IsSolution.

        :rtype: gp_Pnt

        """
        return _Blend.Blend_Function_PointOnS2(self, *args)

    def IsTangencyPoint(self, *args):
        """
        * Returns True when it is not possible to compute the tangent vectors at PointOnS1 and/or PointOnS2.

        :rtype: bool

        """
        return _Blend.Blend_Function_IsTangencyPoint(self, *args)

    def TangentOnS1(self, *args):
        """
        * Returns the tangent vector at PointOnS1, in 3d space.

        :rtype: gp_Vec

        """
        return _Blend.Blend_Function_TangentOnS1(self, *args)

    def Tangent2dOnS1(self, *args):
        """
        * Returns the tangent vector at PointOnS1, in the parametric space of the first surface.

        :rtype: gp_Vec2d

        """
        return _Blend.Blend_Function_Tangent2dOnS1(self, *args)

    def TangentOnS2(self, *args):
        """
        * Returns the tangent vector at PointOnS2, in 3d space.

        :rtype: gp_Vec

        """
        return _Blend.Blend_Function_TangentOnS2(self, *args)

    def Tangent2dOnS2(self, *args):
        """
        * Returns the tangent vector at PointOnS2, in the parametric space of the second surface.

        :rtype: gp_Vec2d

        """
        return _Blend.Blend_Function_Tangent2dOnS2(self, *args)

    def Tangent(self, *args):
        """
        * Returns the tangent vector at the section, at the beginning and the end of the section, and returns the normal (of the surfaces) at these points.

        :param U1:
        :type U1: float
        :param V1:
        :type V1: float
        :param U2:
        :type U2: float
        :param V2:
        :type V2: float
        :param TgFirst:
        :type TgFirst: gp_Vec
        :param TgLast:
        :type TgLast: gp_Vec
        :param NormFirst:
        :type NormFirst: gp_Vec
        :param NormLast:
        :type NormLast: gp_Vec
        :rtype: void

        """
        return _Blend.Blend_Function_Tangent(self, *args)

    def TwistOnS1(self, *args):
        """
        :rtype: bool

        """
        return _Blend.Blend_Function_TwistOnS1(self, *args)

    def TwistOnS2(self, *args):
        """
        :rtype: bool

        """
        return _Blend.Blend_Function_TwistOnS2(self, *args)

    def GetTolerance(self, *args):
        """
        * Returns in the vector Tolerance the parametric tolerance for each of the 4 variables; Tol is the tolerance used in 3d space.

        :param Tolerance:
        :type Tolerance: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: void

        * Returns the tolerance to reach in approximation to respecte BoundTol error at the Boundary AngleTol tangent error at the Boundary SurfTol error inside the surface.

        :param BoundTol:
        :type BoundTol: float
        :param SurfTol:
        :type SurfTol: float
        :param AngleTol:
        :type AngleTol: float
        :param Tol3d:
        :type Tol3d: math_Vector &
        :param Tol1D:
        :type Tol1D: math_Vector &
        :rtype: void

        """
        return _Blend.Blend_Function_GetTolerance(self, *args)

    def Section(self, *args):
        """
        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :rtype: bool

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :rtype: void

        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param D2Poles:
        :type D2Poles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param D2Poles2d:
        :type D2Poles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :param D2Weigths:
        :type D2Weigths: TColStd_Array1OfReal &
        :rtype: bool

        """
        return _Blend.Blend_Function_Section(self, *args)

    __swig_destroy__ = _Blend.delete_Blend_Function
Blend_Function.Set = new_instancemethod(_Blend.Blend_Function_Set,None,Blend_Function)
Blend_Function.PointOnS1 = new_instancemethod(_Blend.Blend_Function_PointOnS1,None,Blend_Function)
Blend_Function.PointOnS2 = new_instancemethod(_Blend.Blend_Function_PointOnS2,None,Blend_Function)
Blend_Function.IsTangencyPoint = new_instancemethod(_Blend.Blend_Function_IsTangencyPoint,None,Blend_Function)
Blend_Function.TangentOnS1 = new_instancemethod(_Blend.Blend_Function_TangentOnS1,None,Blend_Function)
Blend_Function.Tangent2dOnS1 = new_instancemethod(_Blend.Blend_Function_Tangent2dOnS1,None,Blend_Function)
Blend_Function.TangentOnS2 = new_instancemethod(_Blend.Blend_Function_TangentOnS2,None,Blend_Function)
Blend_Function.Tangent2dOnS2 = new_instancemethod(_Blend.Blend_Function_Tangent2dOnS2,None,Blend_Function)
Blend_Function.Tangent = new_instancemethod(_Blend.Blend_Function_Tangent,None,Blend_Function)
Blend_Function.TwistOnS1 = new_instancemethod(_Blend.Blend_Function_TwistOnS1,None,Blend_Function)
Blend_Function.TwistOnS2 = new_instancemethod(_Blend.Blend_Function_TwistOnS2,None,Blend_Function)
Blend_Function.GetTolerance = new_instancemethod(_Blend.Blend_Function_GetTolerance,None,Blend_Function)
Blend_Function.Section = new_instancemethod(_Blend.Blend_Function_Section,None,Blend_Function)
Blend_Function_swigregister = _Blend.Blend_Function_swigregister
Blend_Function_swigregister(Blend_Function)

class Blend_RstRstFunction(Blend_AppFunction):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def Set(self, *args):
        """
        * Sets the value of the parameter along the guide line. This determines the plane in which the solution has to be found.

        :param Param:
        :type Param: float
        :rtype: void

        * Sets the bounds of the parametric interval on the guide line. This determines the derivatives in these values if the function is not Cn.

        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :rtype: void

        """
        return _Blend.Blend_RstRstFunction_Set(self, *args)

    def PointOnRst1(self, *args):
        """
        * Returns the point on the surface.

        :rtype: gp_Pnt

        """
        return _Blend.Blend_RstRstFunction_PointOnRst1(self, *args)

    def PointOnRst2(self, *args):
        """
        * Returns the point on the curve.

        :rtype: gp_Pnt

        """
        return _Blend.Blend_RstRstFunction_PointOnRst2(self, *args)

    def Pnt2dOnRst1(self, *args):
        """
        * Returns U,V coordinates of the point on the surface.

        :rtype: gp_Pnt2d

        """
        return _Blend.Blend_RstRstFunction_Pnt2dOnRst1(self, *args)

    def Pnt2dOnRst2(self, *args):
        """
        * Returns U,V coordinates of the point on the curve on surface.

        :rtype: gp_Pnt2d

        """
        return _Blend.Blend_RstRstFunction_Pnt2dOnRst2(self, *args)

    def ParameterOnRst1(self, *args):
        """
        * Returns parameter of the point on the curve.

        :rtype: float

        """
        return _Blend.Blend_RstRstFunction_ParameterOnRst1(self, *args)

    def ParameterOnRst2(self, *args):
        """
        * Returns parameter of the point on the curve.

        :rtype: float

        """
        return _Blend.Blend_RstRstFunction_ParameterOnRst2(self, *args)

    def IsTangencyPoint(self, *args):
        """
        * Returns True when it is not possible to compute the tangent vectors at PointOnS and/or PointOnRst.

        :rtype: bool

        """
        return _Blend.Blend_RstRstFunction_IsTangencyPoint(self, *args)

    def TangentOnRst1(self, *args):
        """
        * Returns the tangent vector at PointOnS, in 3d space.

        :rtype: gp_Vec

        """
        return _Blend.Blend_RstRstFunction_TangentOnRst1(self, *args)

    def Tangent2dOnRst1(self, *args):
        """
        * Returns the tangent vector at PointOnS, in the parametric space of the first surface.

        :rtype: gp_Vec2d

        """
        return _Blend.Blend_RstRstFunction_Tangent2dOnRst1(self, *args)

    def TangentOnRst2(self, *args):
        """
        * Returns the tangent vector at PointOnC, in 3d space.

        :rtype: gp_Vec

        """
        return _Blend.Blend_RstRstFunction_TangentOnRst2(self, *args)

    def Tangent2dOnRst2(self, *args):
        """
        * Returns the tangent vector at PointOnRst, in the parametric space of the second surface.

        :rtype: gp_Vec2d

        """
        return _Blend.Blend_RstRstFunction_Tangent2dOnRst2(self, *args)

    def Decroch(self, *args):
        """
        * Enables to implement a criterion of decrochage specific to the function. Warning: Can be called without previous call of issolution but the values calculated can be senseless.

        :param Sol:
        :type Sol: math_Vector &
        :param NRst1:
        :type NRst1: gp_Vec
        :param TgRst1:
        :type TgRst1: gp_Vec
        :param NRst2:
        :type NRst2: gp_Vec
        :param TgRst2:
        :type TgRst2: gp_Vec
        :rtype: Blend_DecrochStatus

        """
        return _Blend.Blend_RstRstFunction_Decroch(self, *args)

    def GetTolerance(self, *args):
        """
        * Returns in the vector Tolerance the parametric tolerance for each variable; Tol is the tolerance used in 3d space.

        :param Tolerance:
        :type Tolerance: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: void

        * Returns the tolerance to reach in approximation to respecte BoundTol error at the Boundary AngleTol tangent error at the Boundary SurfTol error inside the surface.

        :param BoundTol:
        :type BoundTol: float
        :param SurfTol:
        :type SurfTol: float
        :param AngleTol:
        :type AngleTol: float
        :param Tol3d:
        :type Tol3d: math_Vector &
        :param Tol1D:
        :type Tol1D: math_Vector &
        :rtype: void

        """
        return _Blend.Blend_RstRstFunction_GetTolerance(self, *args)

    def Section(self, *args):
        """
        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :rtype: void

        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :rtype: bool

        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param D2Poles:
        :type D2Poles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param D2Poles2d:
        :type D2Poles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :param D2Weigths:
        :type D2Weigths: TColStd_Array1OfReal &
        :rtype: bool

        """
        return _Blend.Blend_RstRstFunction_Section(self, *args)

    __swig_destroy__ = _Blend.delete_Blend_RstRstFunction
Blend_RstRstFunction.Set = new_instancemethod(_Blend.Blend_RstRstFunction_Set,None,Blend_RstRstFunction)
Blend_RstRstFunction.PointOnRst1 = new_instancemethod(_Blend.Blend_RstRstFunction_PointOnRst1,None,Blend_RstRstFunction)
Blend_RstRstFunction.PointOnRst2 = new_instancemethod(_Blend.Blend_RstRstFunction_PointOnRst2,None,Blend_RstRstFunction)
Blend_RstRstFunction.Pnt2dOnRst1 = new_instancemethod(_Blend.Blend_RstRstFunction_Pnt2dOnRst1,None,Blend_RstRstFunction)
Blend_RstRstFunction.Pnt2dOnRst2 = new_instancemethod(_Blend.Blend_RstRstFunction_Pnt2dOnRst2,None,Blend_RstRstFunction)
Blend_RstRstFunction.ParameterOnRst1 = new_instancemethod(_Blend.Blend_RstRstFunction_ParameterOnRst1,None,Blend_RstRstFunction)
Blend_RstRstFunction.ParameterOnRst2 = new_instancemethod(_Blend.Blend_RstRstFunction_ParameterOnRst2,None,Blend_RstRstFunction)
Blend_RstRstFunction.IsTangencyPoint = new_instancemethod(_Blend.Blend_RstRstFunction_IsTangencyPoint,None,Blend_RstRstFunction)
Blend_RstRstFunction.TangentOnRst1 = new_instancemethod(_Blend.Blend_RstRstFunction_TangentOnRst1,None,Blend_RstRstFunction)
Blend_RstRstFunction.Tangent2dOnRst1 = new_instancemethod(_Blend.Blend_RstRstFunction_Tangent2dOnRst1,None,Blend_RstRstFunction)
Blend_RstRstFunction.TangentOnRst2 = new_instancemethod(_Blend.Blend_RstRstFunction_TangentOnRst2,None,Blend_RstRstFunction)
Blend_RstRstFunction.Tangent2dOnRst2 = new_instancemethod(_Blend.Blend_RstRstFunction_Tangent2dOnRst2,None,Blend_RstRstFunction)
Blend_RstRstFunction.Decroch = new_instancemethod(_Blend.Blend_RstRstFunction_Decroch,None,Blend_RstRstFunction)
Blend_RstRstFunction.GetTolerance = new_instancemethod(_Blend.Blend_RstRstFunction_GetTolerance,None,Blend_RstRstFunction)
Blend_RstRstFunction.Section = new_instancemethod(_Blend.Blend_RstRstFunction_Section,None,Blend_RstRstFunction)
Blend_RstRstFunction_swigregister = _Blend.Blend_RstRstFunction_swigregister
Blend_RstRstFunction_swigregister(Blend_RstRstFunction)

class Blend_SurfRstFunction(Blend_AppFunction):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def Set(self, *args):
        """
        * Sets the value of the parameter along the guide line. This determines the plane in which the solution has to be found.

        :param Param:
        :type Param: float
        :rtype: void

        * Sets the bounds of the parametric interval on the guide line. This determines the derivatives in these values if the function is not Cn.

        :param First:
        :type First: float
        :param Last:
        :type Last: float
        :rtype: void

        """
        return _Blend.Blend_SurfRstFunction_Set(self, *args)

    def PointOnS(self, *args):
        """
        * Returns the point on the surface.

        :rtype: gp_Pnt

        """
        return _Blend.Blend_SurfRstFunction_PointOnS(self, *args)

    def PointOnRst(self, *args):
        """
        * Returns the point on the curve.

        :rtype: gp_Pnt

        """
        return _Blend.Blend_SurfRstFunction_PointOnRst(self, *args)

    def Pnt2dOnS(self, *args):
        """
        * Returns U,V coordinates of the point on the surface.

        :rtype: gp_Pnt2d

        """
        return _Blend.Blend_SurfRstFunction_Pnt2dOnS(self, *args)

    def Pnt2dOnRst(self, *args):
        """
        * Returns U,V coordinates of the point on the curve on surface.

        :rtype: gp_Pnt2d

        """
        return _Blend.Blend_SurfRstFunction_Pnt2dOnRst(self, *args)

    def ParameterOnRst(self, *args):
        """
        * Returns parameter of the point on the curve.

        :rtype: float

        """
        return _Blend.Blend_SurfRstFunction_ParameterOnRst(self, *args)

    def IsTangencyPoint(self, *args):
        """
        * Returns True when it is not possible to compute the tangent vectors at PointOnS and/or PointOnRst.

        :rtype: bool

        """
        return _Blend.Blend_SurfRstFunction_IsTangencyPoint(self, *args)

    def TangentOnS(self, *args):
        """
        * Returns the tangent vector at PointOnS, in 3d space.

        :rtype: gp_Vec

        """
        return _Blend.Blend_SurfRstFunction_TangentOnS(self, *args)

    def Tangent2dOnS(self, *args):
        """
        * Returns the tangent vector at PointOnS, in the parametric space of the first surface.

        :rtype: gp_Vec2d

        """
        return _Blend.Blend_SurfRstFunction_Tangent2dOnS(self, *args)

    def TangentOnRst(self, *args):
        """
        * Returns the tangent vector at PointOnC, in 3d space.

        :rtype: gp_Vec

        """
        return _Blend.Blend_SurfRstFunction_TangentOnRst(self, *args)

    def Tangent2dOnRst(self, *args):
        """
        * Returns the tangent vector at PointOnRst, in the parametric space of the second surface.

        :rtype: gp_Vec2d

        """
        return _Blend.Blend_SurfRstFunction_Tangent2dOnRst(self, *args)

    def Decroch(self, *args):
        """
        * Enables implementation of a criterion of decrochage specific to the function.

        :param Sol:
        :type Sol: math_Vector &
        :param NS:
        :type NS: gp_Vec
        :param TgS:
        :type TgS: gp_Vec
        :rtype: bool

        """
        return _Blend.Blend_SurfRstFunction_Decroch(self, *args)

    def GetTolerance(self, *args):
        """
        * Returns in the vector Tolerance the parametric tolerance for each variable; Tol is the tolerance used in 3d space.

        :param Tolerance:
        :type Tolerance: math_Vector &
        :param Tol:
        :type Tol: float
        :rtype: void

        * Returns the tolerance to reach in approximation to respecte BoundTol error at the Boundary AngleTol tangent error at the Boundary SurfTol error inside the surface.

        :param BoundTol:
        :type BoundTol: float
        :param SurfTol:
        :type SurfTol: float
        :param AngleTol:
        :type AngleTol: float
        :param Tol3d:
        :type Tol3d: math_Vector &
        :param Tol1D:
        :type Tol1D: math_Vector &
        :rtype: void

        """
        return _Blend.Blend_SurfRstFunction_GetTolerance(self, *args)

    def Section(self, *args):
        """
        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :rtype: bool

        * Used for the first and last section The method returns Standard_True if the derivatives are computed, otherwise it returns Standard_False.

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param DPoles:
        :type DPoles: TColgp_Array1OfVec
        :param D2Poles:
        :type D2Poles: TColgp_Array1OfVec
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param DPoles2d:
        :type DPoles2d: TColgp_Array1OfVec2d
        :param D2Poles2d:
        :type D2Poles2d: TColgp_Array1OfVec2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :param DWeigths:
        :type DWeigths: TColStd_Array1OfReal &
        :param D2Weigths:
        :type D2Weigths: TColStd_Array1OfReal &
        :rtype: bool

        :param P:
        :type P: Blend_Point &
        :param Poles:
        :type Poles: TColgp_Array1OfPnt
        :param Poles2d:
        :type Poles2d: TColgp_Array1OfPnt2d
        :param Weigths:
        :type Weigths: TColStd_Array1OfReal &
        :rtype: void

        """
        return _Blend.Blend_SurfRstFunction_Section(self, *args)

    __swig_destroy__ = _Blend.delete_Blend_SurfRstFunction
Blend_SurfRstFunction.Set = new_instancemethod(_Blend.Blend_SurfRstFunction_Set,None,Blend_SurfRstFunction)
Blend_SurfRstFunction.PointOnS = new_instancemethod(_Blend.Blend_SurfRstFunction_PointOnS,None,Blend_SurfRstFunction)
Blend_SurfRstFunction.PointOnRst = new_instancemethod(_Blend.Blend_SurfRstFunction_PointOnRst,None,Blend_SurfRstFunction)
Blend_SurfRstFunction.Pnt2dOnS = new_instancemethod(_Blend.Blend_SurfRstFunction_Pnt2dOnS,None,Blend_SurfRstFunction)
Blend_SurfRstFunction.Pnt2dOnRst = new_instancemethod(_Blend.Blend_SurfRstFunction_Pnt2dOnRst,None,Blend_SurfRstFunction)
Blend_SurfRstFunction.ParameterOnRst = new_instancemethod(_Blend.Blend_SurfRstFunction_ParameterOnRst,None,Blend_SurfRstFunction)
Blend_SurfRstFunction.IsTangencyPoint = new_instancemethod(_Blend.Blend_SurfRstFunction_IsTangencyPoint,None,Blend_SurfRstFunction)
Blend_SurfRstFunction.TangentOnS = new_instancemethod(_Blend.Blend_SurfRstFunction_TangentOnS,None,Blend_SurfRstFunction)
Blend_SurfRstFunction.Tangent2dOnS = new_instancemethod(_Blend.Blend_SurfRstFunction_Tangent2dOnS,None,Blend_SurfRstFunction)
Blend_SurfRstFunction.TangentOnRst = new_instancemethod(_Blend.Blend_SurfRstFunction_TangentOnRst,None,Blend_SurfRstFunction)
Blend_SurfRstFunction.Tangent2dOnRst = new_instancemethod(_Blend.Blend_SurfRstFunction_Tangent2dOnRst,None,Blend_SurfRstFunction)
Blend_SurfRstFunction.Decroch = new_instancemethod(_Blend.Blend_SurfRstFunction_Decroch,None,Blend_SurfRstFunction)
Blend_SurfRstFunction.GetTolerance = new_instancemethod(_Blend.Blend_SurfRstFunction_GetTolerance,None,Blend_SurfRstFunction)
Blend_SurfRstFunction.Section = new_instancemethod(_Blend.Blend_SurfRstFunction_Section,None,Blend_SurfRstFunction)
Blend_SurfRstFunction_swigregister = _Blend.Blend_SurfRstFunction_swigregister
Blend_SurfRstFunction_swigregister(Blend_SurfRstFunction)



