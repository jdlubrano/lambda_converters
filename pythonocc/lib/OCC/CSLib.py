# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.



from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _CSLib.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_CSLib', [dirname(__file__)])
        except ImportError:
            import _CSLib
            return _CSLib
        if fp is not None:
            try:
                _mod = imp.load_module('_CSLib', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _CSLib = swig_import_helper()
    del swig_import_helper
else:
    import _CSLib
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _CSLib.delete_SwigPyIterator
    def __iter__(self): return self
SwigPyIterator.value = new_instancemethod(_CSLib.SwigPyIterator_value,None,SwigPyIterator)
SwigPyIterator.incr = new_instancemethod(_CSLib.SwigPyIterator_incr,None,SwigPyIterator)
SwigPyIterator.decr = new_instancemethod(_CSLib.SwigPyIterator_decr,None,SwigPyIterator)
SwigPyIterator.distance = new_instancemethod(_CSLib.SwigPyIterator_distance,None,SwigPyIterator)
SwigPyIterator.equal = new_instancemethod(_CSLib.SwigPyIterator_equal,None,SwigPyIterator)
SwigPyIterator.copy = new_instancemethod(_CSLib.SwigPyIterator_copy,None,SwigPyIterator)
SwigPyIterator.next = new_instancemethod(_CSLib.SwigPyIterator_next,None,SwigPyIterator)
SwigPyIterator.__next__ = new_instancemethod(_CSLib.SwigPyIterator___next__,None,SwigPyIterator)
SwigPyIterator.previous = new_instancemethod(_CSLib.SwigPyIterator_previous,None,SwigPyIterator)
SwigPyIterator.advance = new_instancemethod(_CSLib.SwigPyIterator_advance,None,SwigPyIterator)
SwigPyIterator.__eq__ = new_instancemethod(_CSLib.SwigPyIterator___eq__,None,SwigPyIterator)
SwigPyIterator.__ne__ = new_instancemethod(_CSLib.SwigPyIterator___ne__,None,SwigPyIterator)
SwigPyIterator.__iadd__ = new_instancemethod(_CSLib.SwigPyIterator___iadd__,None,SwigPyIterator)
SwigPyIterator.__isub__ = new_instancemethod(_CSLib.SwigPyIterator___isub__,None,SwigPyIterator)
SwigPyIterator.__add__ = new_instancemethod(_CSLib.SwigPyIterator___add__,None,SwigPyIterator)
SwigPyIterator.__sub__ = new_instancemethod(_CSLib.SwigPyIterator___sub__,None,SwigPyIterator)
SwigPyIterator_swigregister = _CSLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import OCC.gp
import OCC.Standard
import OCC.TColgp
import OCC.TCollection
import OCC.MMgt
import OCC.math
import OCC.TColStd
def register_handle(handle, base_object):
    """
    Inserts the handle into the base object to
    prevent memory corruption in certain cases
    """
    try:
        if base_object.IsKind("Standard_Transient"):
            base_object.thisHandle = handle
            base_object.thisown = False
    except:
        pass

CSLib_Done = _CSLib.CSLib_Done
CSLib_D1uIsNull = _CSLib.CSLib_D1uIsNull
CSLib_D1vIsNull = _CSLib.CSLib_D1vIsNull
CSLib_D1IsNull = _CSLib.CSLib_D1IsNull
CSLib_D1uD1vRatioIsNull = _CSLib.CSLib_D1uD1vRatioIsNull
CSLib_D1vD1uRatioIsNull = _CSLib.CSLib_D1vD1uRatioIsNull
CSLib_D1uIsParallelD1v = _CSLib.CSLib_D1uIsParallelD1v
CSLib_Singular = _CSLib.CSLib_Singular
CSLib_Defined = _CSLib.CSLib_Defined
CSLib_InfinityOfSolutions = _CSLib.CSLib_InfinityOfSolutions
CSLib_D1NuIsNull = _CSLib.CSLib_D1NuIsNull
CSLib_D1NvIsNull = _CSLib.CSLib_D1NvIsNull
CSLib_D1NIsNull = _CSLib.CSLib_D1NIsNull
CSLib_D1NuNvRatioIsNull = _CSLib.CSLib_D1NuNvRatioIsNull
CSLib_D1NvNuRatioIsNull = _CSLib.CSLib_D1NvNuRatioIsNull
CSLib_D1NuIsParallelD1Nv = _CSLib.CSLib_D1NuIsParallelD1Nv
class cslib(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Normal(*args):
        """
        * The following functions computes the normal to a surface inherits FunctionWithDerivative from math Computes the normal direction of a surface as the cross product between D1U and D1V. If D1U has null length or D1V has null length or D1U and D1V are parallel the normal is undefined. To check that D1U and D1V are colinear the sinus of the angle between D1U and D1V is computed and compared with SinTol. The normal is computed if Status == Done else the Status gives the reason why the computation has failed.

        :param D1U:
        :type D1U: gp_Vec
        :param D1V:
        :type D1V: gp_Vec
        :param SinTol:
        :type SinTol: float
        :param Status:
        :type Status: CSLib_DerivativeStatus &
        :param Normal:
        :type Normal: gp_Dir
        :rtype: void

        * If there is a singularity on the surface the previous method cannot compute the local normal. This method computes an approched normal direction of a surface. It does a limited development and needs the second derivatives on the surface as input data. It computes the normal as follow : N(u, v) = D1U ^ D1V N(u0+du,v0+dv) = N0 + DN/du(u0,v0) * du + DN/dv(u0,v0) * dv + Eps with Eps->0 so we can have the equivalence N ~ dN/du + dN/dv. DNu = ||DN/du|| and DNv = ||DN/dv|| . if DNu IsNull (DNu <= Resolution from gp) the answer Done = True the normal direction is given by DN/dv . if DNv IsNull (DNv <= Resolution from gp) the answer Done = True the normal direction is given by DN/du . if the two directions DN/du and DN/dv are parallel Done = True the normal direction is given either by DN/du or DN/dv. To check that the two directions are colinear the sinus of the angle between these directions is computed and compared with SinTol. . if DNu/DNv or DNv/DNu is lower or equal than Real Epsilon Done = False, the normal is undefined . if DNu IsNull and DNv is Null Done = False, there is an indetermination and we should do a limited developpement at order 2 (it means that we cannot omit Eps). . if DNu Is not Null and DNv Is not Null Done = False, there are an infinity of normals at the considered point on the surface.

        :param D1U:
        :type D1U: gp_Vec
        :param D1V:
        :type D1V: gp_Vec
        :param D2U:
        :type D2U: gp_Vec
        :param D2V:
        :type D2V: gp_Vec
        :param D2UV:
        :type D2UV: gp_Vec
        :param SinTol:
        :type SinTol: float
        :param Done:
        :type Done: bool
        :param Status:
        :type Status: CSLib_NormalStatus &
        :param Normal:
        :type Normal: gp_Dir
        :rtype: void

        * Computes the normal direction of a surface as the cross product between D1U and D1V.

        :param D1U:
        :type D1U: gp_Vec
        :param D1V:
        :type D1V: gp_Vec
        :param MagTol:
        :type MagTol: float
        :param Status:
        :type Status: CSLib_NormalStatus &
        :param Normal:
        :type Normal: gp_Dir
        :rtype: void

        * find the first order k0 of deriviative of NUV where: foreach order < k0 all the derivatives of NUV are null all the derivatives of NUV corresponding to the order k0 are collinear and have the same sens. In this case, normal at U,V is unique.

        :param MaxOrder:
        :type MaxOrder: int
        :param DerNUV:
        :type DerNUV: TColgp_Array2OfVec
        :param MagTol:
        :type MagTol: float
        :param U:
        :type U: float
        :param V:
        :type V: float
        :param Umin:
        :type Umin: float
        :param Umax:
        :type Umax: float
        :param Vmin:
        :type Vmin: float
        :param Vmax:
        :type Vmax: float
        :param Status:
        :type Status: CSLib_NormalStatus &
        :param Normal:
        :type Normal: gp_Dir
        :param OrderU:
        :type OrderU: int &
        :param OrderV:
        :type OrderV: int &
        :rtype: void

        """
        return _CSLib.cslib_Normal(*args)

    Normal = staticmethod(Normal)
    def DNNUV(*args):
        """
        * -- Computes the derivative of order Nu in the --  direction U and Nv in the direction V of the not --  normalized normal vector at the point P(U,V) The  array DerSurf contain the derivative (i,j) of the surface  for i=0,Nu+1 ; j=0,Nv+1

        :param Nu:
        :type Nu: int
        :param Nv:
        :type Nv: int
        :param DerSurf:
        :type DerSurf: TColgp_Array2OfVec
        :rtype: gp_Vec

        * Computes the derivatives of order Nu in the direction Nu and Nv in the direction Nv of the not normalized vector N(u,v) = dS1/du * dS2/dv (cases where we use an osculating surface) DerSurf1 are the derivatives of S1

        :param Nu:
        :type Nu: int
        :param Nv:
        :type Nv: int
        :param DerSurf1:
        :type DerSurf1: TColgp_Array2OfVec
        :param DerSurf2:
        :type DerSurf2: TColgp_Array2OfVec
        :rtype: gp_Vec

        """
        return _CSLib.cslib_DNNUV(*args)

    DNNUV = staticmethod(DNNUV)
    def DNNormal(*args):
        """
        * -- Computes the derivative of order Nu in the --  direction U and Nv in the direction V of the  normalized normal vector at the point P(U,V) array  DerNUV contain the derivative (i+Iduref,j+Idvref)  of D1U ^ D1V for i=0,Nu ; j=0,Nv Iduref and Idvref  correspond to a derivative of D1U ^ D1V which can  be used to compute the normalized normal vector.  In the regular cases , Iduref=Idvref=0.

        :param Nu:
        :type Nu: int
        :param Nv:
        :type Nv: int
        :param DerNUV:
        :type DerNUV: TColgp_Array2OfVec
        :param Iduref: default value is 0
        :type Iduref: int
        :param Idvref: default value is 0
        :type Idvref: int
        :rtype: gp_Vec

        """
        return _CSLib.cslib_DNNormal(*args)

    DNNormal = staticmethod(DNNormal)
    def __init__(self): 
        _CSLib.cslib_swiginit(self,_CSLib.new_cslib())
    __swig_destroy__ = _CSLib.delete_cslib
cslib_swigregister = _CSLib.cslib_swigregister
cslib_swigregister(cslib)

def cslib_Normal(*args):
  """
    * The following functions computes the normal to a surface inherits FunctionWithDerivative from math Computes the normal direction of a surface as the cross product between D1U and D1V. If D1U has null length or D1V has null length or D1U and D1V are parallel the normal is undefined. To check that D1U and D1V are colinear the sinus of the angle between D1U and D1V is computed and compared with SinTol. The normal is computed if Status == Done else the Status gives the reason why the computation has failed.

    :param D1U:
    :type D1U: gp_Vec
    :param D1V:
    :type D1V: gp_Vec
    :param SinTol:
    :type SinTol: float
    :param Status:
    :type Status: CSLib_DerivativeStatus &
    :param Normal:
    :type Normal: gp_Dir
    :rtype: void

    * If there is a singularity on the surface the previous method cannot compute the local normal. This method computes an approched normal direction of a surface. It does a limited development and needs the second derivatives on the surface as input data. It computes the normal as follow : N(u, v) = D1U ^ D1V N(u0+du,v0+dv) = N0 + DN/du(u0,v0) * du + DN/dv(u0,v0) * dv + Eps with Eps->0 so we can have the equivalence N ~ dN/du + dN/dv. DNu = ||DN/du|| and DNv = ||DN/dv|| . if DNu IsNull (DNu <= Resolution from gp) the answer Done = True the normal direction is given by DN/dv . if DNv IsNull (DNv <= Resolution from gp) the answer Done = True the normal direction is given by DN/du . if the two directions DN/du and DN/dv are parallel Done = True the normal direction is given either by DN/du or DN/dv. To check that the two directions are colinear the sinus of the angle between these directions is computed and compared with SinTol. . if DNu/DNv or DNv/DNu is lower or equal than Real Epsilon Done = False, the normal is undefined . if DNu IsNull and DNv is Null Done = False, there is an indetermination and we should do a limited developpement at order 2 (it means that we cannot omit Eps). . if DNu Is not Null and DNv Is not Null Done = False, there are an infinity of normals at the considered point on the surface.

    :param D1U:
    :type D1U: gp_Vec
    :param D1V:
    :type D1V: gp_Vec
    :param D2U:
    :type D2U: gp_Vec
    :param D2V:
    :type D2V: gp_Vec
    :param D2UV:
    :type D2UV: gp_Vec
    :param SinTol:
    :type SinTol: float
    :param Done:
    :type Done: bool
    :param Status:
    :type Status: CSLib_NormalStatus &
    :param Normal:
    :type Normal: gp_Dir
    :rtype: void

    * Computes the normal direction of a surface as the cross product between D1U and D1V.

    :param D1U:
    :type D1U: gp_Vec
    :param D1V:
    :type D1V: gp_Vec
    :param MagTol:
    :type MagTol: float
    :param Status:
    :type Status: CSLib_NormalStatus &
    :param Normal:
    :type Normal: gp_Dir
    :rtype: void

    * find the first order k0 of deriviative of NUV where: foreach order < k0 all the derivatives of NUV are null all the derivatives of NUV corresponding to the order k0 are collinear and have the same sens. In this case, normal at U,V is unique.

    :param MaxOrder:
    :type MaxOrder: int
    :param DerNUV:
    :type DerNUV: TColgp_Array2OfVec
    :param MagTol:
    :type MagTol: float
    :param U:
    :type U: float
    :param V:
    :type V: float
    :param Umin:
    :type Umin: float
    :param Umax:
    :type Umax: float
    :param Vmin:
    :type Vmin: float
    :param Vmax:
    :type Vmax: float
    :param Status:
    :type Status: CSLib_NormalStatus &
    :param Normal:
    :type Normal: gp_Dir
    :param OrderU:
    :type OrderU: int &
    :param OrderV:
    :type OrderV: int &
    :rtype: void

    """
  return _CSLib.cslib_Normal(*args)

def cslib_DNNUV(*args):
  """
    * -- Computes the derivative of order Nu in the --  direction U and Nv in the direction V of the not --  normalized normal vector at the point P(U,V) The  array DerSurf contain the derivative (i,j) of the surface  for i=0,Nu+1 ; j=0,Nv+1

    :param Nu:
    :type Nu: int
    :param Nv:
    :type Nv: int
    :param DerSurf:
    :type DerSurf: TColgp_Array2OfVec
    :rtype: gp_Vec

    * Computes the derivatives of order Nu in the direction Nu and Nv in the direction Nv of the not normalized vector N(u,v) = dS1/du * dS2/dv (cases where we use an osculating surface) DerSurf1 are the derivatives of S1

    :param Nu:
    :type Nu: int
    :param Nv:
    :type Nv: int
    :param DerSurf1:
    :type DerSurf1: TColgp_Array2OfVec
    :param DerSurf2:
    :type DerSurf2: TColgp_Array2OfVec
    :rtype: gp_Vec

    """
  return _CSLib.cslib_DNNUV(*args)

def cslib_DNNormal(*args):
  """
    * -- Computes the derivative of order Nu in the --  direction U and Nv in the direction V of the  normalized normal vector at the point P(U,V) array  DerNUV contain the derivative (i+Iduref,j+Idvref)  of D1U ^ D1V for i=0,Nu ; j=0,Nv Iduref and Idvref  correspond to a derivative of D1U ^ D1V which can  be used to compute the normalized normal vector.  In the regular cases , Iduref=Idvref=0.

    :param Nu:
    :type Nu: int
    :param Nv:
    :type Nv: int
    :param DerNUV:
    :type DerNUV: TColgp_Array2OfVec
    :param Iduref: default value is 0
    :type Iduref: int
    :param Idvref: default value is 0
    :type Idvref: int
    :rtype: gp_Vec

    """
  return _CSLib.cslib_DNNormal(*args)

class CSLib_Class2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param TP:
        :type TP: TColgp_Array1OfPnt2d
        :param aTolu:
        :type aTolu: float
        :param aTolv:
        :type aTolv: float
        :param umin:
        :type umin: float
        :param vmin:
        :type vmin: float
        :param umax:
        :type umax: float
        :param vmax:
        :type vmax: float
        :rtype: None

        """
        _CSLib.CSLib_Class2d_swiginit(self,_CSLib.new_CSLib_Class2d(*args))
    def SiDans(self, *args):
        """
        :param P:
        :type P: gp_Pnt2d
        :rtype: int

        """
        return _CSLib.CSLib_Class2d_SiDans(self, *args)

    def SiDans_OnMode(self, *args):
        """
        :param P:
        :type P: gp_Pnt2d
        :param Tol:
        :type Tol: float
        :rtype: int

        """
        return _CSLib.CSLib_Class2d_SiDans_OnMode(self, *args)

    def InternalSiDans(self, *args):
        """
        :param X:
        :type X: float
        :param Y:
        :type Y: float
        :rtype: int

        """
        return _CSLib.CSLib_Class2d_InternalSiDans(self, *args)

    def InternalSiDansOuOn(self, *args):
        """
        :param X:
        :type X: float
        :param Y:
        :type Y: float
        :rtype: int

        """
        return _CSLib.CSLib_Class2d_InternalSiDansOuOn(self, *args)

    def Copy(self, *args):
        """
        :param Other:
        :type Other: CSLib_Class2d &
        :rtype: CSLib_Class2d

        """
        return _CSLib.CSLib_Class2d_Copy(self, *args)

    def Set(self, *args):
        """
        :param Other:
        :type Other: CSLib_Class2d &
        :rtype: CSLib_Class2d

        """
        return _CSLib.CSLib_Class2d_Set(self, *args)

    def Destroy(self, *args):
        """
        :rtype: None

        """
        return _CSLib.CSLib_Class2d_Destroy(self, *args)

    __swig_destroy__ = _CSLib.delete_CSLib_Class2d
CSLib_Class2d.SiDans = new_instancemethod(_CSLib.CSLib_Class2d_SiDans,None,CSLib_Class2d)
CSLib_Class2d.SiDans_OnMode = new_instancemethod(_CSLib.CSLib_Class2d_SiDans_OnMode,None,CSLib_Class2d)
CSLib_Class2d.InternalSiDans = new_instancemethod(_CSLib.CSLib_Class2d_InternalSiDans,None,CSLib_Class2d)
CSLib_Class2d.InternalSiDansOuOn = new_instancemethod(_CSLib.CSLib_Class2d_InternalSiDansOuOn,None,CSLib_Class2d)
CSLib_Class2d.Copy = new_instancemethod(_CSLib.CSLib_Class2d_Copy,None,CSLib_Class2d)
CSLib_Class2d.Set = new_instancemethod(_CSLib.CSLib_Class2d_Set,None,CSLib_Class2d)
CSLib_Class2d.Destroy = new_instancemethod(_CSLib.CSLib_Class2d_Destroy,None,CSLib_Class2d)
CSLib_Class2d_swigregister = _CSLib.CSLib_Class2d_swigregister
CSLib_Class2d_swigregister(CSLib_Class2d)

class CSLib_NormalPolyDef(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        :param k0:
        :type k0: int
        :param li:
        :type li: TColStd_Array1OfReal &
        :rtype: None

        """
        _CSLib.CSLib_NormalPolyDef_swiginit(self,_CSLib.new_CSLib_NormalPolyDef(*args))
    def Value(self, *args):
        """
        * computes the value <F>of the function for the variable <X>. Returns True if the calculation were successfully done, False otherwise.

        :param X:
        :type X: float
        :param F:
        :type F: float &
        :rtype: bool

        """
        return _CSLib.CSLib_NormalPolyDef_Value(self, *args)

    def Derivative(self, *args):
        """
        * computes the derivative <D> of the function for the variable <X>. Returns True if the calculation were successfully done, False otherwise.

        :param X:
        :type X: float
        :param D:
        :type D: float &
        :rtype: bool

        """
        return _CSLib.CSLib_NormalPolyDef_Derivative(self, *args)

    def Values(self, *args):
        """
        * computes the value <F> and the derivative <D> of the function for the variable <X>. Returns True if the calculation were successfully done, False otherwise.

        :param X:
        :type X: float
        :param F:
        :type F: float &
        :param D:
        :type D: float &
        :rtype: bool

        """
        return _CSLib.CSLib_NormalPolyDef_Values(self, *args)

    __swig_destroy__ = _CSLib.delete_CSLib_NormalPolyDef
CSLib_NormalPolyDef.Value = new_instancemethod(_CSLib.CSLib_NormalPolyDef_Value,None,CSLib_NormalPolyDef)
CSLib_NormalPolyDef.Derivative = new_instancemethod(_CSLib.CSLib_NormalPolyDef_Derivative,None,CSLib_NormalPolyDef)
CSLib_NormalPolyDef.Values = new_instancemethod(_CSLib.CSLib_NormalPolyDef_Values,None,CSLib_NormalPolyDef)
CSLib_NormalPolyDef_swigregister = _CSLib.CSLib_NormalPolyDef_swigregister
CSLib_NormalPolyDef_swigregister(CSLib_NormalPolyDef)



